(function(root, factory) {
    if (typeof exports === "object" && exports) {
        factory(exports);
    } else {
        var mustache = {};
        factory(mustache);
        if (typeof define === "function" && define.amd) {
            define(mustache);
        } else {
            root.Mustache = mustache;
        }
    }
})(this, function(mustache) {
    var whiteRe = /\s*/;
    var spaceRe = /\s+/;
    var nonSpaceRe = /\S/;
    var eqRe = /\s*=/;
    var curlyRe = /\s*\}/;
    var tagRe = /#|\^|\/|>|\{|&|=|!/;
    var RegExp_test = RegExp.prototype.test;
    function testRegExp(re, string) {
        return RegExp_test.call(re, string);
    }
    function isWhitespace(string) {
        return !testRegExp(nonSpaceRe, string);
    }
    var Object_toString = Object.prototype.toString;
    var isArray = Array.isArray || function(object) {
        return Object_toString.call(object) === "[object Array]";
    };
    function isFunction(object) {
        return typeof object === "function";
    }
    function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;"
    };
    function escapeHtml(string) {
        return String(string).replace(/[&<>"'\/]/g, function(s) {
            return entityMap[s];
        });
    }
    function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
    }
    Scanner.prototype.eos = function() {
        return this.tail === "";
    };
    Scanner.prototype.scan = function(re) {
        var match = this.tail.match(re);
        if (match && match.index === 0) {
            var string = match[0];
            this.tail = this.tail.substring(string.length);
            this.pos += string.length;
            return string;
        }
        return "";
    };
    Scanner.prototype.scanUntil = function(re) {
        var index = this.tail.search(re), match;
        switch (index) {
          case -1:
            match = this.tail;
            this.tail = "";
            break;

          case 0:
            match = "";
            break;

          default:
            match = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match.length;
        return match;
    };
    function Context(view, parent) {
        this.view = view == null ? {} : view;
        this.parent = parent;
        this._cache = {
            ".": this.view
        };
    }
    Context.make = function(view) {
        return view instanceof Context ? view : new Context(view);
    };
    Context.prototype.push = function(view) {
        return new Context(view, this);
    };
    Context.prototype.lookup = function(name) {
        var value;
        if (name in this._cache) {
            value = this._cache[name];
        } else {
            var context = this;
            while (context) {
                if (name.indexOf(".") > 0) {
                    value = context.view;
                    var names = name.split("."), i = 0;
                    while (value != null && i < names.length) {
                        value = value[names[i++]];
                    }
                } else {
                    value = context.view[name];
                }
                if (value != null) break;
                context = context.parent;
            }
            this._cache[name] = value;
        }
        if (isFunction(value)) {
            value = value.call(this.view);
        }
        return value;
    };
    function Writer() {
        this.clearCache();
    }
    Writer.prototype.clearCache = function() {
        this._cache = {};
        this._partialCache = {};
    };
    Writer.prototype.compile = function(template, tags) {
        var fn = this._cache[template];
        if (!fn) {
            var tokens = mustache.parse(template, tags);
            fn = this._cache[template] = this.compileTokens(tokens, template);
        }
        return fn;
    };
    Writer.prototype.compilePartial = function(name, template, tags) {
        var fn = this.compile(template, tags);
        this._partialCache[name] = fn;
        return fn;
    };
    Writer.prototype.getPartial = function(name) {
        if (!(name in this._partialCache) && this._loadPartial) {
            this.compilePartial(name, this._loadPartial(name));
        }
        return this._partialCache[name];
    };
    Writer.prototype.compileTokens = function(tokens, template) {
        var self = this;
        return function(view, partials) {
            if (partials) {
                if (isFunction(partials)) {
                    self._loadPartial = partials;
                } else {
                    for (var name in partials) {
                        self.compilePartial(name, partials[name]);
                    }
                }
            }
            return renderTokens(tokens, self, Context.make(view), template);
        };
    };
    Writer.prototype.render = function(template, view, partials) {
        return this.compile(template)(view, partials);
    };
    function renderTokens(tokens, writer, context, template) {
        var buffer = "";
        function subRender(template) {
            return writer.render(template, context);
        }
        var token, tokenValue, value;
        for (var i = 0, len = tokens.length; i < len; ++i) {
            token = tokens[i];
            tokenValue = token[1];
            switch (token[0]) {
              case "#":
                value = context.lookup(tokenValue);
                if (typeof value === "object" || typeof value === "string") {
                    if (isArray(value)) {
                        for (var j = 0, jlen = value.length; j < jlen; ++j) {
                            buffer += renderTokens(token[4], writer, context.push(value[j]), template);
                        }
                    } else if (value) {
                        buffer += renderTokens(token[4], writer, context.push(value), template);
                    }
                } else if (isFunction(value)) {
                    var text = template == null ? null : template.slice(token[3], token[5]);
                    value = value.call(context.view, text, subRender);
                    if (value != null) buffer += value;
                } else if (value) {
                    buffer += renderTokens(token[4], writer, context, template);
                }
                break;

              case "^":
                value = context.lookup(tokenValue);
                if (!value || isArray(value) && value.length === 0) {
                    buffer += renderTokens(token[4], writer, context, template);
                }
                break;

              case ">":
                value = writer.getPartial(tokenValue);
                if (isFunction(value)) buffer += value(context);
                break;

              case "&":
                value = context.lookup(tokenValue);
                if (value != null) buffer += value;
                break;

              case "name":
                value = context.lookup(tokenValue);
                if (value != null) buffer += mustache.escape(value);
                break;

              case "text":
                buffer += tokenValue;
                break;
            }
        }
        return buffer;
    }
    function nestTokens(tokens) {
        var tree = [];
        var collector = tree;
        var sections = [];
        var token;
        for (var i = 0, len = tokens.length; i < len; ++i) {
            token = tokens[i];
            switch (token[0]) {
              case "#":
              case "^":
                sections.push(token);
                collector.push(token);
                collector = token[4] = [];
                break;

              case "/":
                var section = sections.pop();
                section[5] = token[2];
                collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;
                break;

              default:
                collector.push(token);
            }
        }
        return tree;
    }
    function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, len = tokens.length; i < len; ++i) {
            token = tokens[i];
            if (token) {
                if (token[0] === "text" && lastToken && lastToken[0] === "text") {
                    lastToken[1] += token[1];
                    lastToken[3] = token[3];
                } else {
                    lastToken = token;
                    squashedTokens.push(token);
                }
            }
        }
        return squashedTokens;
    }
    function escapeTags(tags) {
        return [ new RegExp(escapeRegExp(tags[0]) + "\\s*"), new RegExp("\\s*" + escapeRegExp(tags[1])) ];
    }
    function parseTemplate(template, tags) {
        template = template || "";
        tags = tags || mustache.tags;
        if (typeof tags === "string") tags = tags.split(spaceRe);
        if (tags.length !== 2) throw new Error("Invalid tags: " + tags.join(", "));
        var tagRes = escapeTags(tags);
        var scanner = new Scanner(template);
        var sections = [];
        var tokens = [];
        var spaces = [];
        var hasTag = false;
        var nonSpace = false;
        function stripSpace() {
            if (hasTag && !nonSpace) {
                while (spaces.length) {
                    delete tokens[spaces.pop()];
                }
            } else {
                spaces = [];
            }
            hasTag = false;
            nonSpace = false;
        }
        var start, type, value, chr, token, openSection;
        while (!scanner.eos()) {
            start = scanner.pos;
            value = scanner.scanUntil(tagRes[0]);
            if (value) {
                for (var i = 0, len = value.length; i < len; ++i) {
                    chr = value.charAt(i);
                    if (isWhitespace(chr)) {
                        spaces.push(tokens.length);
                    } else {
                        nonSpace = true;
                    }
                    tokens.push([ "text", chr, start, start + 1 ]);
                    start += 1;
                    if (chr == "\n") stripSpace();
                }
            }
            if (!scanner.scan(tagRes[0])) break;
            hasTag = true;
            type = scanner.scan(tagRe) || "name";
            scanner.scan(whiteRe);
            if (type === "=") {
                value = scanner.scanUntil(eqRe);
                scanner.scan(eqRe);
                scanner.scanUntil(tagRes[1]);
            } else if (type === "{") {
                value = scanner.scanUntil(new RegExp("\\s*" + escapeRegExp("}" + tags[1])));
                scanner.scan(curlyRe);
                scanner.scanUntil(tagRes[1]);
                type = "&";
            } else {
                value = scanner.scanUntil(tagRes[1]);
            }
            if (!scanner.scan(tagRes[1])) throw new Error("Unclosed tag at " + scanner.pos);
            token = [ type, value, start, scanner.pos ];
            tokens.push(token);
            if (type === "#" || type === "^") {
                sections.push(token);
            } else if (type === "/") {
                openSection = sections.pop();
                if (!openSection) {
                    throw new Error('Unopened section "' + value + '" at ' + start);
                }
                if (openSection[1] !== value) {
                    throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
                }
            } else if (type === "name" || type === "{" || type === "&") {
                nonSpace = true;
            } else if (type === "=") {
                tags = value.split(spaceRe);
                if (tags.length !== 2) {
                    throw new Error("Invalid tags at " + start + ": " + tags.join(", "));
                }
                tagRes = escapeTags(tags);
            }
        }
        openSection = sections.pop();
        if (openSection) {
            throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
        }
        return nestTokens(squashTokens(tokens));
    }
    mustache.name = "mustache.js";
    mustache.version = "0.7.3";
    mustache.tags = [ "{{", "}}" ];
    mustache.Scanner = Scanner;
    mustache.Context = Context;
    mustache.Writer = Writer;
    mustache.parse = parseTemplate;
    mustache.escape = escapeHtml;
    var defaultWriter = new Writer();
    mustache.clearCache = function() {
        return defaultWriter.clearCache();
    };
    mustache.compile = function(template, tags) {
        return defaultWriter.compile(template, tags);
    };
    mustache.compilePartial = function(name, template, tags) {
        return defaultWriter.compilePartial(name, template, tags);
    };
    mustache.compileTokens = function(tokens, template) {
        return defaultWriter.compileTokens(tokens, template);
    };
    mustache.render = function(template, view, partials) {
        return defaultWriter.render(template, view, partials);
    };
    mustache.to_html = function(template, view, partials, send) {
        var result = mustache.render(template, view, partials);
        if (isFunction(send)) {
            send(result);
        } else {
            return result;
        }
    };
});

(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var arr = [];
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var document = window.document, version = "2.1.1", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (;i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
            return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0;
        },
        isPlainObject: function(obj) {
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }
            return true;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (;j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (;i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function(elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (;i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = function(window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function(elem) {
            var i = 0, len = this.length;
            for (;i < len; i++) {
                if (this[i] === elem) {
                    return i;
                }
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)", rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + characterEncoding + ")"),
            CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
            TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {}
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            if (!selector || typeof selector !== "string") {
                return results;
            }
            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                return [];
            }
            if (documentIsHTML && !seed) {
                if (match = rquickExpr.exec(selector)) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType === 9 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                        groups = tokenize(selector);
                        if (old = context.getAttribute("id")) {
                            nid = old.replace(rescape, "\\$&");
                        } else {
                            context.setAttribute("id", nid);
                        }
                        nid = "[id='" + nid + "'] ";
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(",");
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {} finally {
                            if (!old) {
                                context.removeAttribute("id");
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + " ") > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = doc.documentElement;
            documentIsHTML = !isXML(doc);
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener("unload", function() {
                        setDocument();
                    }, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", function() {
                        setDocument();
                    });
                }
            }
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(doc.createComment(""));
                return !div.getElementsByTagName("*").length;
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function(div) {
                div.innerHTML = "<div class='a'></div><div class='a i'></div>";
                div.firstChild.className = "i";
                return div.getElementsByClassName("i").length === 2;
            });
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== strundefined && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [ m ] : [];
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
            } else {
                delete Expr.find["ID"];
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== strundefined) {
                    return context.getElementsByTagName(tag);
                }
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function(div) {
                    div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";
                    if (div.querySelectorAll("[msallowclip^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                });
                assert(function(div) {
                    var input = doc.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(div) {
                    support.disconnectedMatch = matches.call(div, "div");
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }
                    return match.slice(0, 4);
                },
                CHILD: function(match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [ forward ? parent.firstChild : parent.lastChild ];
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [ pseudo, pseudo, "", argument ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf.call(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        return !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: function(elem) {
                    return elem.disabled === false;
                },
                disabled: function(elem) {
                    return elem.disabled === true;
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                selected: function(elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                parent: function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                text: function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;--i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for (;i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                outerCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (;i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (;i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf.call(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            } ];
            for (;i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (;j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
                if (outermost) {
                    outermostContext = context !== document && context;
                }
                for (;i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        while (matcher = elementMatchers[j++]) {
                            if (matcher(elem, context, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }
                    if (bySet) {
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while (matcher = setMatchers[j++]) {
                        matcher(unmatched, setMatched, context, xml);
                    }
                    if (seed) {
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched);
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                        Sizzle.uniqueSort(results);
                    }
                }
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function(div1) {
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
        var match, elem;
        if (!selector) {
            return this;
        }
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match = [ null, selector, null ];
            } else {
                match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {
                            if (jQuery.isFunction(this[match])) {
                                this[match](context[match]);
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }
                    return this;
                } else {
                    elem = document.getElementById(match[2]);
                    if (elem && elem.parentNode) {
                        this.length = 1;
                        this[0] = elem;
                    }
                    this.context = document;
                    this.selector = selector;
                    return this;
                }
            } else if (!context || context.jquery) {
                return (context || rootjQuery).find(selector);
            } else {
                return this.constructor(context).find(selector);
            }
        } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
        } else if (jQuery.isFunction(selector)) {
            return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
            this.selector = selector.selector;
            this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.extend({
        dir: function(elem, dir, until) {
            var matched = [], truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        },
        sibling: function(n, elem) {
            var matched = [];
            for (;n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
            return matched;
        }
    });
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (;i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (;i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function(elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for (;list && firingIndex < firingLength; firingIndex++) {
                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                    memory = false;
                    break;
                }
            }
            firing = false;
            if (list) {
                if (stack) {
                    if (stack.length) {
                        fire(stack.shift());
                    }
                } else if (memory) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        }, self = {
            add: function() {
                if (list) {
                    var start = list.length;
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            if (type === "function") {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && type !== "string") {
                                add(arg);
                            }
                        });
                    })(arguments);
                    if (firing) {
                        firingLength = list.length;
                    } else if (memory) {
                        firingStart = start;
                        fire(memory);
                    }
                }
                return this;
            },
            remove: function() {
                if (list) {
                    jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (firing) {
                                if (index <= firingLength) {
                                    firingLength--;
                                }
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
            },
            empty: function() {
                list = [];
                firingLength = 0;
                return this;
            },
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                stack = undefined;
                if (!memory) {
                    self.disable();
                }
                return this;
            },
            locked: function() {
                return !stack;
            },
            fireWith: function(context, args) {
                if (list && (!fired || stack)) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if (firing) {
                        stack.push(args);
                    } else {
                        fire(args);
                    }
                }
                return this;
            },
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                } else {
                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function() {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function(subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                    }
                };
            }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (;i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [ jQuery ]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        jQuery.ready();
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete") {
                setTimeout(jQuery.ready);
            } else {
                document.addEventListener("DOMContentLoaded", completed, false);
                window.addEventListener("load", completed, false);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (;i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    jQuery.acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function() {
                return {};
            }
        });
        this.expando = jQuery.expando + Math.random();
    }
    Data.uid = 1;
    Data.accepts = jQuery.acceptData;
    Data.prototype = {
        key: function(owner) {
            if (!Data.accepts(owner)) {
                return 0;
            }
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = {
                        value: unlock
                    };
                    Object.defineProperties(owner, descriptor);
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor);
                }
            }
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};
            }
            return unlock;
        },
        set: function(owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if (typeof data === "string") {
                cache[data] = value;
            } else {
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data);
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
            }
            return cache;
        },
        get: function(owner, key) {
            var cache = this.cache[this.key(owner)];
            return key === undefined ? cache : cache[key];
        },
        access: function(owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (key === undefined) {
                this.cache[unlock] = {};
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [ key, camel ];
                    } else {
                        name = camel;
                        name = name in cache ? [ name ] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
        },
        hasData: function(owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
        },
        discard: function(owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]];
            }
        }
    };
    var data_priv = new Data();
    var data_user = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                data_user.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },
        data: function(elem, name, data) {
            return data_user.access(elem, name, data);
        },
        removeData: function(elem, name) {
            data_user.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return data_priv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            data_priv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);
                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        data_priv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            if (typeof key === "object") {
                return this.each(function() {
                    data_user.set(this, key);
                });
            }
            return access(this, function(value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && value === undefined) {
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function() {
                    var data = data_user.get(this, camelKey);
                    data_user.set(this, camelKey, value);
                    if (key.indexOf("-") !== -1 && data !== undefined) {
                        data_user.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                data_user.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = data_priv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [ elements ]);
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    var isHidden = function(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var strundefined = typeof undefined;
    support.focusinBubbles = "onfocusin" in window;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, "events");
            }
        },
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf(".") >= 0) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (;cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                for (;cur !== this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                noBubble: true
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    data_priv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        data_priv.remove(doc, fix);
                    } else {
                        data_priv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function(types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
                if (typeof selector !== "string") {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (;i < l; i++) {
            data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
        }
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);
            data_user.set(dest, udataCur);
        }
    }
    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
        },
        buildFragment: function(elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
            for (;i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === "object") {
                        jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"));
                        tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp = fragment.firstChild;
                        tmp.textContent = "";
                    }
                }
            }
            fragment.textContent = "";
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(fragment.appendChild(elem), "script");
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            return fragment;
        },
        cleanData: function(elems) {
            var data, elem, type, key, special = jQuery.event.special, i = 0;
            for (;(elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];
                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            delete data_priv.cache[key];
                        }
                    }
                }
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    });
    jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function(selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (;(elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function() {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = "";
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (;i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var arg = arguments[0];
            this.domManip(arguments, function(elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function(selector) {
            return this.remove(selector, true);
        },
        domManip: function(args, callback) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
                return this.each(function(index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;
                    for (;i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, "script"));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                }
                            }
                        }
                    }
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (;i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === "none" || !display) {
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    };
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
        }
        if (computed) {
            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function() {
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement("div"), div = document.createElement("div");
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
        container.appendChild(div);
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";
            docElem.removeChild(container);
        }
        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function() {
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function() {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function() {
                    var ret, marginDiv = div.appendChild(document.createElement("div"));
                    marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                    marginDiv.style.marginRight = marginDiv.style.width = "0";
                    div.style.width = "1px";
                    docElem.appendChild(container);
                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
                    docElem.removeChild(container);
                    return ret;
                }
            });
        }
    })();
    jQuery.swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        for (;i < 4; i += 2) {
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (;index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = data_priv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== "none" || !hidden) {
                    data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = "number";
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
            }
        };
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            return jQuery.swap(elem, {
                display: "inline-block"
            }, curCSS, [ elem, "marginRight" ]);
        }
    });
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [ value ];
                for (;i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (;i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
        "*": [ function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
                unit = unit || start[3];
                parts = parts || [];
                start = +target || 1;
                do {
                    scale = scale || ".5";
                    start = start / scale;
                    jQuery.style(tween.elem, prop, start + unit);
                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
            }
            if (parts) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
            }
            return tween;
        } ]
    };
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        includeWidth = includeWidth ? 1 : 0;
        for (;i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
        for (;index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
            display = jQuery.css(elem, "display");
            checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access(elem, "fxshow", {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                data_priv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for (;index < length; index++) {
                animation.tweens[index].run(percent);
            }
            deferred.notifyWith(elem, [ animation, percent, remaining ]);
            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [ animation ]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {}
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (;index < length; index++) {
                    animation.tweens[index].run(1);
                }
                if (gotoEnd) {
                    deferred.resolveWith(elem, [ animation, gotoEnd ]);
                } else {
                    deferred.rejectWith(elem, [ animation, gotoEnd ]);
                }
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (;index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.split(" ");
            }
            var prop, index = 0, length = props.length;
            for (;index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || data_priv.get(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (;i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                }
            }
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }
    jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : "";
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function() {
                if (type === "string") {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) {
                        data_priv.set(this, "__className__", this.className);
                    }
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                }
            });
        },
        hasClass: function(selector) {
            var className = " " + selector + " ", i = 0, l = this.length;
            for (;i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (;i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    };
    jQuery.parseXML = function(data) {
        var xml, tmp;
        if (!data || typeof data !== "string") {
            return null;
        }
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };
    var ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*");
    try {
        ajaxLocation = location.href;
    } catch (e) {
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === "*") {
                    current = prev;
                } else if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    if (!state) {
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (state < 2) {
                            for (code in map) {
                                statusCode[code] = [ statusCode[code], map[code] ];
                            }
                        } else {
                            jqXHR.always(map[jqXHR.status]);
                        }
                    }
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";
                    } else if (status === 304) {
                        statusText = "notmodified";
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                } else {
                    deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
                }
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join("&").replace(r20, "+");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest();
        } catch (e) {}
    };
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.ActiveXObject) {
        jQuery(window).on("unload", function() {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]();
            }
        });
    }
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr(), id = ++xhrId;
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;
                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    complete(xhr.status, xhr.statusText);
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {
                                        text: xhr.responseText
                                    } : undefined, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    xhr.onerror = callback("error");
                    callback = xhrCallbacks[id] = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            jqXHR.always(function() {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return "script";
        }
    });
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [ context.createElement(parsed[1]) ];
        }
        parsed = jQuery.buildFragment([ data ], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params
            }).done(function(responseText) {
                response = arguments;
                self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function(jqXHR, status) {
                self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
            });
        }
        return this;
    };
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
                elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                top: 0,
                left: 0
            }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function() {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement["client" + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.size = function() {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
});

(function($) {
    $.fn.extend({
        slimScroll: function(options) {
            var defaults = {
                width: "auto",
                height: "250px",
                size: "7px",
                color: "#000",
                position: "right",
                distance: "1px",
                start: "top",
                opacity: .4,
                alwaysVisible: false,
                disableFadeOut: false,
                railVisible: false,
                railColor: "#333",
                railOpacity: .2,
                railDraggable: true,
                railClass: "slimScrollRail",
                barClass: "slimScrollBar",
                wrapperClass: "slimScrollDiv",
                allowPageScroll: false,
                wheelStep: 20,
                touchScrollStep: 200,
                borderRadius: "7px",
                railBorderRadius: "7px"
            };
            var o = $.extend(defaults, options);
            this.each(function() {
                var isOverPanel, isOverBar, isDragg, queueHide, touchDif, barHeight, percentScroll, lastScroll, divS = "<div></div>", minBarHeight = 30, releaseScroll = false;
                var me = $(this);
                if (me.parent().hasClass(o.wrapperClass)) {
                    var offset = me.scrollTop();
                    bar = me.parent().find("." + o.barClass);
                    rail = me.parent().find("." + o.railClass);
                    getBarHeight();
                    if ($.isPlainObject(options)) {
                        if ("height" in options && options.height == "auto") {
                            me.parent().css("height", "auto");
                            me.css("height", "auto");
                            var height = me.parent().parent().height();
                            me.parent().css("height", height);
                            me.css("height", height);
                        }
                        if ("scrollTo" in options) {
                            offset = parseInt(o.scrollTo);
                        } else if ("scrollBy" in options) {
                            offset += parseInt(o.scrollBy);
                        } else if ("destroy" in options) {
                            bar.remove();
                            rail.remove();
                            me.unwrap();
                            return;
                        }
                        scrollContent(offset, false, true);
                    }
                    return;
                } else if ($.isPlainObject(options)) {
                    if ("destroy" in options) {
                        return;
                    }
                }
                o.height = o.height == "auto" ? me.parent().height() : o.height;
                var wrapper = $(divS).addClass(o.wrapperClass).css({
                    position: "relative",
                    overflow: "hidden",
                    width: o.width,
                    height: o.height
                });
                me.css({
                    overflow: "hidden",
                    width: o.width,
                    height: o.height
                });
                var rail = $(divS).addClass(o.railClass).css({
                    width: o.size,
                    height: "100%",
                    position: "absolute",
                    top: 0,
                    display: o.alwaysVisible && o.railVisible ? "block" : "none",
                    "border-radius": o.railBorderRadius,
                    background: o.railColor,
                    opacity: o.railOpacity,
                    zIndex: 90
                });
                var bar = $(divS).addClass(o.barClass).css({
                    background: o.color,
                    width: o.size,
                    position: "absolute",
                    top: 0,
                    opacity: o.opacity,
                    display: o.alwaysVisible ? "block" : "none",
                    "border-radius": o.borderRadius,
                    BorderRadius: o.borderRadius,
                    MozBorderRadius: o.borderRadius,
                    WebkitBorderRadius: o.borderRadius,
                    zIndex: 99
                });
                var posCss = o.position == "right" ? {
                    right: o.distance
                } : {
                    left: o.distance
                };
                rail.css(posCss);
                bar.css(posCss);
                me.wrap(wrapper);
                me.parent().append(bar);
                me.parent().append(rail);
                if (o.railDraggable) {
                    bar.bind("mousedown", function(e) {
                        var $doc = $(document);
                        isDragg = true;
                        t = parseFloat(bar.css("top"));
                        pageY = e.pageY;
                        $doc.bind("mousemove.slimscroll", function(e) {
                            currTop = t + e.pageY - pageY;
                            bar.css("top", currTop);
                            scrollContent(0, bar.position().top, false);
                        });
                        $doc.bind("mouseup.slimscroll", function(e) {
                            isDragg = false;
                            hideBar();
                            $doc.unbind(".slimscroll");
                        });
                        return false;
                    }).bind("selectstart.slimscroll", function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        return false;
                    });
                }
                rail.hover(function() {
                    showBar();
                }, function() {
                    hideBar();
                });
                bar.hover(function() {
                    isOverBar = true;
                }, function() {
                    isOverBar = false;
                });
                me.hover(function() {
                    isOverPanel = true;
                    showBar();
                    hideBar();
                }, function() {
                    isOverPanel = false;
                    hideBar();
                });
                me.bind("touchstart", function(e, b) {
                    if (e.originalEvent.touches.length) {
                        touchDif = e.originalEvent.touches[0].pageY;
                    }
                });
                me.bind("touchmove", function(e) {
                    if (!releaseScroll) {
                        e.originalEvent.preventDefault();
                    }
                    if (e.originalEvent.touches.length) {
                        var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
                        scrollContent(diff, true);
                        touchDif = e.originalEvent.touches[0].pageY;
                    }
                });
                getBarHeight();
                if (o.start === "bottom") {
                    bar.css({
                        top: me.outerHeight() - bar.outerHeight()
                    });
                    scrollContent(0, true);
                } else if (o.start !== "top") {
                    scrollContent($(o.start).position().top, null, true);
                    if (!o.alwaysVisible) {
                        bar.hide();
                    }
                }
                attachWheel();
                function _onWheel(e) {
                    if (!isOverPanel) {
                        return;
                    }
                    var e = e || window.event;
                    var delta = 0;
                    if (e.wheelDelta) {
                        delta = -e.wheelDelta / 120;
                    }
                    if (e.detail) {
                        delta = e.detail / 3;
                    }
                    var target = e.target || e.srcTarget || e.srcElement;
                    if ($(target).closest("." + o.wrapperClass).is(me.parent())) {
                        scrollContent(delta, true);
                    }
                    if (e.preventDefault && !releaseScroll) {
                        e.preventDefault();
                    }
                    if (!releaseScroll) {
                        e.returnValue = false;
                    }
                }
                function scrollContent(y, isWheel, isJump) {
                    releaseScroll = false;
                    var delta = y;
                    var maxTop = me.outerHeight() - bar.outerHeight();
                    if (isWheel) {
                        delta = parseInt(bar.css("top")) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();
                        delta = Math.min(Math.max(delta, 0), maxTop);
                        delta = y > 0 ? Math.ceil(delta) : Math.floor(delta);
                        bar.css({
                            top: delta + "px"
                        });
                    }
                    percentScroll = parseInt(bar.css("top")) / (me.outerHeight() - bar.outerHeight());
                    delta = percentScroll * (me[0].scrollHeight - me.outerHeight());
                    if (isJump) {
                        delta = y;
                        var offsetTop = delta / me[0].scrollHeight * me.outerHeight();
                        offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
                        bar.css({
                            top: offsetTop + "px"
                        });
                    }
                    me.scrollTop(delta);
                    me.trigger("slimscrolling", ~~delta);
                    showBar();
                    hideBar();
                }
                function attachWheel() {
                    if (window.addEventListener) {
                        this.addEventListener("DOMMouseScroll", _onWheel, false);
                        this.addEventListener("mousewheel", _onWheel, false);
                    } else {
                        document.attachEvent("onmousewheel", _onWheel);
                    }
                }
                function getBarHeight() {
                    barHeight = Math.max(me.outerHeight() / me[0].scrollHeight * me.outerHeight(), minBarHeight);
                    bar.css({
                        height: barHeight + "px"
                    });
                    var display = barHeight == me.outerHeight() ? "none" : "block";
                    bar.css({
                        display: display
                    });
                }
                function showBar() {
                    getBarHeight();
                    clearTimeout(queueHide);
                    if (percentScroll == ~~percentScroll) {
                        releaseScroll = o.allowPageScroll;
                        if (lastScroll != percentScroll) {
                            var msg = ~~percentScroll == 0 ? "top" : "bottom";
                            me.trigger("slimscroll", msg);
                        }
                    } else {
                        releaseScroll = false;
                    }
                    lastScroll = percentScroll;
                    if (barHeight >= me.outerHeight()) {
                        releaseScroll = true;
                        return;
                    }
                    bar.stop(true, true).fadeIn("fast");
                    if (o.railVisible) {
                        rail.stop(true, true).fadeIn("fast");
                    }
                }
                function hideBar() {
                    if (!o.alwaysVisible) {
                        queueHide = setTimeout(function() {
                            if (!(o.disableFadeOut && isOverPanel) && !isOverBar && !isDragg) {
                                bar.fadeOut("slow");
                                rail.fadeOut("slow");
                            }
                        }, 1e3);
                    }
                }
            });
            return this;
        }
    });
    $.fn.extend({
        slimscroll: $.fn.slimScroll
    });
})(jQuery);

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(typeof jQuery != "undefined" ? jQuery : window.Zepto);
    }
})(function($) {
    "use strict";
    var feature = {};
    feature.fileapi = $("<input type='file'/>").get(0).files !== undefined;
    feature.formdata = window.FormData !== undefined;
    var hasProp = !!$.fn.prop;
    $.fn.attr2 = function() {
        if (!hasProp) {
            return this.attr.apply(this, arguments);
        }
        var val = this.prop.apply(this, arguments);
        if (val && val.jquery || typeof val === "string") {
            return val;
        }
        return this.attr.apply(this, arguments);
    };
    $.fn.ajaxSubmit = function(options) {
        if (!this.length) {
            log("ajaxSubmit: skipping submit process - no element selected");
            return this;
        }
        var method, action, url, $form = this;
        if (typeof options == "function") {
            options = {
                success: options
            };
        } else if (options === undefined) {
            options = {};
        }
        method = options.type || this.attr2("method");
        action = options.url || this.attr2("action");
        url = typeof action === "string" ? $.trim(action) : "";
        url = url || window.location.href || "";
        if (url) {
            url = (url.match(/^([^#]+)/) || [])[1];
        }
        options = $.extend(true, {
            url: url,
            success: $.ajaxSettings.success,
            type: method || $.ajaxSettings.type,
            iframeSrc: /^https/i.test(window.location.href || "") ? "javascript:false" : "about:blank"
        }, options);
        var veto = {};
        this.trigger("form-pre-serialize", [ this, options, veto ]);
        if (veto.veto) {
            log("ajaxSubmit: submit vetoed via form-pre-serialize trigger");
            return this;
        }
        if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
            log("ajaxSubmit: submit aborted via beforeSerialize callback");
            return this;
        }
        var traditional = options.traditional;
        if (traditional === undefined) {
            traditional = $.ajaxSettings.traditional;
        }
        var elements = [];
        var qx, a = this.formToArray(options.semantic, elements);
        if (options.data) {
            options.extraData = options.data;
            qx = $.param(options.data, traditional);
        }
        if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
            log("ajaxSubmit: submit aborted via beforeSubmit callback");
            return this;
        }
        this.trigger("form-submit-validate", [ a, this, options, veto ]);
        if (veto.veto) {
            log("ajaxSubmit: submit vetoed via form-submit-validate trigger");
            return this;
        }
        var q = $.param(a, traditional);
        if (qx) {
            q = q ? q + "&" + qx : qx;
        }
        if (options.type.toUpperCase() == "GET") {
            options.url += (options.url.indexOf("?") >= 0 ? "&" : "?") + q;
            options.data = null;
        } else {
            options.data = q;
        }
        var callbacks = [];
        if (options.resetForm) {
            callbacks.push(function() {
                $form.resetForm();
            });
        }
        if (options.clearForm) {
            callbacks.push(function() {
                $form.clearForm(options.includeHidden);
            });
        }
        if (!options.dataType && options.target) {
            var oldSuccess = options.success || function() {};
            callbacks.push(function(data) {
                var fn = options.replaceTarget ? "replaceWith" : "html";
                $(options.target)[fn](data).each(oldSuccess, arguments);
            });
        } else if (options.success) {
            callbacks.push(options.success);
        }
        options.success = function(data, status, xhr) {
            var context = options.context || this;
            for (var i = 0, max = callbacks.length; i < max; i++) {
                callbacks[i].apply(context, [ data, status, xhr || $form, $form ]);
            }
        };
        if (options.error) {
            var oldError = options.error;
            options.error = function(xhr, status, error) {
                var context = options.context || this;
                oldError.apply(context, [ xhr, status, error, $form ]);
            };
        }
        if (options.complete) {
            var oldComplete = options.complete;
            options.complete = function(xhr, status) {
                var context = options.context || this;
                oldComplete.apply(context, [ xhr, status, $form ]);
            };
        }
        var fileInputs = $("input[type=file]:enabled", this).filter(function() {
            return $(this).val() !== "";
        });
        var hasFileInputs = fileInputs.length > 0;
        var mp = "multipart/form-data";
        var multipart = $form.attr("enctype") == mp || $form.attr("encoding") == mp;
        var fileAPI = feature.fileapi && feature.formdata;
        log("fileAPI :" + fileAPI);
        var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;
        var jqxhr;
        if (options.iframe !== false && (options.iframe || shouldUseFrame)) {
            if (options.closeKeepAlive) {
                $.get(options.closeKeepAlive, function() {
                    jqxhr = fileUploadIframe(a);
                });
            } else {
                jqxhr = fileUploadIframe(a);
            }
        } else if ((hasFileInputs || multipart) && fileAPI) {
            jqxhr = fileUploadXhr(a);
        } else {
            jqxhr = $.ajax(options);
        }
        $form.removeData("jqxhr").data("jqxhr", jqxhr);
        for (var k = 0; k < elements.length; k++) {
            elements[k] = null;
        }
        this.trigger("form-submit-notify", [ this, options ]);
        return this;
        function deepSerialize(extraData) {
            var serialized = $.param(extraData, options.traditional).split("&");
            var len = serialized.length;
            var result = [];
            var i, part;
            for (i = 0; i < len; i++) {
                serialized[i] = serialized[i].replace(/\+/g, " ");
                part = serialized[i].split("=");
                result.push([ decodeURIComponent(part[0]), decodeURIComponent(part[1]) ]);
            }
            return result;
        }
        function fileUploadXhr(a) {
            var formdata = new FormData();
            for (var i = 0; i < a.length; i++) {
                formdata.append(a[i].name, a[i].value);
            }
            if (options.extraData) {
                var serializedData = deepSerialize(options.extraData);
                for (i = 0; i < serializedData.length; i++) {
                    if (serializedData[i]) {
                        formdata.append(serializedData[i][0], serializedData[i][1]);
                    }
                }
            }
            options.data = null;
            var s = $.extend(true, {}, $.ajaxSettings, options, {
                contentType: false,
                processData: false,
                cache: false,
                type: method || "POST"
            });
            if (options.uploadProgress) {
                s.xhr = function() {
                    var xhr = $.ajaxSettings.xhr();
                    if (xhr.upload) {
                        xhr.upload.addEventListener("progress", function(event) {
                            var percent = 0;
                            var position = event.loaded || event.position;
                            var total = event.total;
                            if (event.lengthComputable) {
                                percent = Math.ceil(position / total * 100);
                            }
                            options.uploadProgress(event, position, total, percent);
                        }, false);
                    }
                    return xhr;
                };
            }
            s.data = null;
            var beforeSend = s.beforeSend;
            s.beforeSend = function(xhr, o) {
                if (options.formData) {
                    o.data = options.formData;
                } else {
                    o.data = formdata;
                }
                if (beforeSend) {
                    beforeSend.call(this, xhr, o);
                }
            };
            return $.ajax(s);
        }
        function fileUploadIframe(a) {
            var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
            var deferred = $.Deferred();
            deferred.abort = function(status) {
                xhr.abort(status);
            };
            if (a) {
                for (i = 0; i < elements.length; i++) {
                    el = $(elements[i]);
                    if (hasProp) {
                        el.prop("disabled", false);
                    } else {
                        el.removeAttr("disabled");
                    }
                }
            }
            s = $.extend(true, {}, $.ajaxSettings, options);
            s.context = s.context || s;
            id = "jqFormIO" + new Date().getTime();
            if (s.iframeTarget) {
                $io = $(s.iframeTarget);
                n = $io.attr2("name");
                if (!n) {
                    $io.attr2("name", id);
                } else {
                    id = n;
                }
            } else {
                $io = $('<iframe name="' + id + '" src="' + s.iframeSrc + '" />');
                $io.css({
                    position: "absolute",
                    top: "-1000px",
                    left: "-1000px"
                });
            }
            io = $io[0];
            xhr = {
                aborted: 0,
                responseText: null,
                responseXML: null,
                status: 0,
                statusText: "n/a",
                getAllResponseHeaders: function() {},
                getResponseHeader: function() {},
                setRequestHeader: function() {},
                abort: function(status) {
                    var e = status === "timeout" ? "timeout" : "aborted";
                    log("aborting upload... " + e);
                    this.aborted = 1;
                    try {
                        if (io.contentWindow.document.execCommand) {
                            io.contentWindow.document.execCommand("Stop");
                        }
                    } catch (ignore) {}
                    $io.attr("src", s.iframeSrc);
                    xhr.error = e;
                    if (s.error) {
                        s.error.call(s.context, xhr, e, status);
                    }
                    if (g) {
                        $.event.trigger("ajaxError", [ xhr, s, e ]);
                    }
                    if (s.complete) {
                        s.complete.call(s.context, xhr, e);
                    }
                }
            };
            g = s.global;
            if (g && 0 === $.active++) {
                $.event.trigger("ajaxStart");
            }
            if (g) {
                $.event.trigger("ajaxSend", [ xhr, s ]);
            }
            if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
                if (s.global) {
                    $.active--;
                }
                deferred.reject();
                return deferred;
            }
            if (xhr.aborted) {
                deferred.reject();
                return deferred;
            }
            sub = form.clk;
            if (sub) {
                n = sub.name;
                if (n && !sub.disabled) {
                    s.extraData = s.extraData || {};
                    s.extraData[n] = sub.value;
                    if (sub.type == "image") {
                        s.extraData[n + ".x"] = form.clk_x;
                        s.extraData[n + ".y"] = form.clk_y;
                    }
                }
            }
            var CLIENT_TIMEOUT_ABORT = 1;
            var SERVER_ABORT = 2;
            function getDoc(frame) {
                var doc = null;
                try {
                    if (frame.contentWindow) {
                        doc = frame.contentWindow.document;
                    }
                } catch (err) {
                    log("cannot get iframe.contentWindow document: " + err);
                }
                if (doc) {
                    return doc;
                }
                try {
                    doc = frame.contentDocument ? frame.contentDocument : frame.document;
                } catch (err) {
                    log("cannot get iframe.contentDocument: " + err);
                    doc = frame.document;
                }
                return doc;
            }
            var csrf_token = $("meta[name=csrf-token]").attr("content");
            var csrf_param = $("meta[name=csrf-param]").attr("content");
            if (csrf_param && csrf_token) {
                s.extraData = s.extraData || {};
                s.extraData[csrf_param] = csrf_token;
            }
            function doSubmit() {
                var t = $form.attr2("target"), a = $form.attr2("action"), mp = "multipart/form-data", et = $form.attr("enctype") || $form.attr("encoding") || mp;
                form.setAttribute("target", id);
                if (!method || /post/i.test(method)) {
                    form.setAttribute("method", "POST");
                }
                if (a != s.url) {
                    form.setAttribute("action", s.url);
                }
                if (!s.skipEncodingOverride && (!method || /post/i.test(method))) {
                    $form.attr({
                        encoding: "multipart/form-data",
                        enctype: "multipart/form-data"
                    });
                }
                if (s.timeout) {
                    timeoutHandle = setTimeout(function() {
                        timedOut = true;
                        cb(CLIENT_TIMEOUT_ABORT);
                    }, s.timeout);
                }
                function checkState() {
                    try {
                        var state = getDoc(io).readyState;
                        log("state = " + state);
                        if (state && state.toLowerCase() == "uninitialized") {
                            setTimeout(checkState, 50);
                        }
                    } catch (e) {
                        log("Server abort: ", e, " (", e.name, ")");
                        cb(SERVER_ABORT);
                        if (timeoutHandle) {
                            clearTimeout(timeoutHandle);
                        }
                        timeoutHandle = undefined;
                    }
                }
                var extraInputs = [];
                try {
                    if (s.extraData) {
                        for (var n in s.extraData) {
                            if (s.extraData.hasOwnProperty(n)) {
                                if ($.isPlainObject(s.extraData[n]) && s.extraData[n].hasOwnProperty("name") && s.extraData[n].hasOwnProperty("value")) {
                                    extraInputs.push($('<input type="hidden" name="' + s.extraData[n].name + '">').val(s.extraData[n].value).appendTo(form)[0]);
                                } else {
                                    extraInputs.push($('<input type="hidden" name="' + n + '">').val(s.extraData[n]).appendTo(form)[0]);
                                }
                            }
                        }
                    }
                    if (!s.iframeTarget) {
                        $io.appendTo("body");
                    }
                    if (io.attachEvent) {
                        io.attachEvent("onload", cb);
                    } else {
                        io.addEventListener("load", cb, false);
                    }
                    setTimeout(checkState, 15);
                    try {
                        form.submit();
                    } catch (err) {
                        var submitFn = document.createElement("form").submit;
                        submitFn.apply(form);
                    }
                } finally {
                    form.setAttribute("action", a);
                    form.setAttribute("enctype", et);
                    if (t) {
                        form.setAttribute("target", t);
                    } else {
                        $form.removeAttr("target");
                    }
                    $(extraInputs).remove();
                }
            }
            if (s.forceSync) {
                doSubmit();
            } else {
                setTimeout(doSubmit, 10);
            }
            var data, doc, domCheckCount = 50, callbackProcessed;
            function cb(e) {
                if (xhr.aborted || callbackProcessed) {
                    return;
                }
                doc = getDoc(io);
                if (!doc) {
                    log("cannot access response document");
                    e = SERVER_ABORT;
                }
                if (e === CLIENT_TIMEOUT_ABORT && xhr) {
                    xhr.abort("timeout");
                    deferred.reject(xhr, "timeout");
                    return;
                } else if (e == SERVER_ABORT && xhr) {
                    xhr.abort("server abort");
                    deferred.reject(xhr, "error", "server abort");
                    return;
                }
                if (!doc || doc.location.href == s.iframeSrc) {
                    if (!timedOut) {
                        return;
                    }
                }
                if (io.detachEvent) {
                    io.detachEvent("onload", cb);
                } else {
                    io.removeEventListener("load", cb, false);
                }
                var status = "success", errMsg;
                try {
                    if (timedOut) {
                        throw "timeout";
                    }
                    var isXml = s.dataType == "xml" || doc.XMLDocument || $.isXMLDoc(doc);
                    log("isXml=" + isXml);
                    if (!isXml && window.opera && (doc.body === null || !doc.body.innerHTML)) {
                        if (--domCheckCount) {
                            log("requeing onLoad callback, DOM not available");
                            setTimeout(cb, 250);
                            return;
                        }
                    }
                    var docRoot = doc.body ? doc.body : doc.documentElement;
                    xhr.responseText = docRoot ? docRoot.innerHTML : null;
                    xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
                    if (isXml) {
                        s.dataType = "xml";
                    }
                    xhr.getResponseHeader = function(header) {
                        var headers = {
                            "content-type": s.dataType
                        };
                        return headers[header.toLowerCase()];
                    };
                    if (docRoot) {
                        xhr.status = Number(docRoot.getAttribute("status")) || xhr.status;
                        xhr.statusText = docRoot.getAttribute("statusText") || xhr.statusText;
                    }
                    var dt = (s.dataType || "").toLowerCase();
                    var scr = /(json|script|text)/.test(dt);
                    if (scr || s.textarea) {
                        var ta = doc.getElementsByTagName("textarea")[0];
                        if (ta) {
                            xhr.responseText = ta.value;
                            xhr.status = Number(ta.getAttribute("status")) || xhr.status;
                            xhr.statusText = ta.getAttribute("statusText") || xhr.statusText;
                        } else if (scr) {
                            var pre = doc.getElementsByTagName("pre")[0];
                            var b = doc.getElementsByTagName("body")[0];
                            if (pre) {
                                xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;
                            } else if (b) {
                                xhr.responseText = b.textContent ? b.textContent : b.innerText;
                            }
                        }
                    } else if (dt == "xml" && !xhr.responseXML && xhr.responseText) {
                        xhr.responseXML = toXml(xhr.responseText);
                    }
                    try {
                        data = httpData(xhr, dt, s);
                    } catch (err) {
                        status = "parsererror";
                        xhr.error = errMsg = err || status;
                    }
                } catch (err) {
                    log("error caught: ", err);
                    status = "error";
                    xhr.error = errMsg = err || status;
                }
                if (xhr.aborted) {
                    log("upload aborted");
                    status = null;
                }
                if (xhr.status) {
                    status = xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 ? "success" : "error";
                }
                if (status === "success") {
                    if (s.success) {
                        s.success.call(s.context, data, "success", xhr);
                    }
                    deferred.resolve(xhr.responseText, "success", xhr);
                    if (g) {
                        $.event.trigger("ajaxSuccess", [ xhr, s ]);
                    }
                } else if (status) {
                    if (errMsg === undefined) {
                        errMsg = xhr.statusText;
                    }
                    if (s.error) {
                        s.error.call(s.context, xhr, status, errMsg);
                    }
                    deferred.reject(xhr, "error", errMsg);
                    if (g) {
                        $.event.trigger("ajaxError", [ xhr, s, errMsg ]);
                    }
                }
                if (g) {
                    $.event.trigger("ajaxComplete", [ xhr, s ]);
                }
                if (g && !--$.active) {
                    $.event.trigger("ajaxStop");
                }
                if (s.complete) {
                    s.complete.call(s.context, xhr, status);
                }
                callbackProcessed = true;
                if (s.timeout) {
                    clearTimeout(timeoutHandle);
                }
                setTimeout(function() {
                    if (!s.iframeTarget) {
                        $io.remove();
                    } else {
                        $io.attr("src", s.iframeSrc);
                    }
                    xhr.responseXML = null;
                }, 100);
            }
            var toXml = $.parseXML || function(s, doc) {
                if (window.ActiveXObject) {
                    doc = new ActiveXObject("Microsoft.XMLDOM");
                    doc.async = "false";
                    doc.loadXML(s);
                } else {
                    doc = new DOMParser().parseFromString(s, "text/xml");
                }
                return doc && doc.documentElement && doc.documentElement.nodeName != "parsererror" ? doc : null;
            };
            var parseJSON = $.parseJSON || function(s) {
                return window["eval"]("(" + s + ")");
            };
            var httpData = function(xhr, type, s) {
                var ct = xhr.getResponseHeader("content-type") || "", xml = type === "xml" || !type && ct.indexOf("xml") >= 0, data = xml ? xhr.responseXML : xhr.responseText;
                if (xml && data.documentElement.nodeName === "parsererror") {
                    if ($.error) {
                        $.error("parsererror");
                    }
                }
                if (s && s.dataFilter) {
                    data = s.dataFilter(data, type);
                }
                if (typeof data === "string") {
                    if (type === "json" || !type && ct.indexOf("json") >= 0) {
                        data = parseJSON(data);
                    } else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
                        $.globalEval(data);
                    }
                }
                return data;
            };
            return deferred;
        }
    };
    $.fn.ajaxForm = function(options) {
        options = options || {};
        options.delegation = options.delegation && $.isFunction($.fn.on);
        if (!options.delegation && this.length === 0) {
            var o = {
                s: this.selector,
                c: this.context
            };
            if (!$.isReady && o.s) {
                log("DOM not ready, queuing ajaxForm");
                $(function() {
                    $(o.s, o.c).ajaxForm(options);
                });
                return this;
            }
            log("terminating; zero elements found by selector" + ($.isReady ? "" : " (DOM not ready)"));
            return this;
        }
        if (options.delegation) {
            $(document).off("submit.form-plugin", this.selector, doAjaxSubmit).off("click.form-plugin", this.selector, captureSubmittingElement).on("submit.form-plugin", this.selector, options, doAjaxSubmit).on("click.form-plugin", this.selector, options, captureSubmittingElement);
            return this;
        }
        return this.ajaxFormUnbind().bind("submit.form-plugin", options, doAjaxSubmit).bind("click.form-plugin", options, captureSubmittingElement);
    };
    function doAjaxSubmit(e) {
        var options = e.data;
        if (!e.isDefaultPrevented()) {
            e.preventDefault();
            $(e.target).ajaxSubmit(options);
        }
    }
    function captureSubmittingElement(e) {
        var target = e.target;
        var $el = $(target);
        if (!$el.is("[type=submit],[type=image]")) {
            var t = $el.closest("[type=submit]");
            if (t.length === 0) {
                return;
            }
            target = t[0];
        }
        var form = this;
        form.clk = target;
        if (target.type == "image") {
            if (e.offsetX !== undefined) {
                form.clk_x = e.offsetX;
                form.clk_y = e.offsetY;
            } else if (typeof $.fn.offset == "function") {
                var offset = $el.offset();
                form.clk_x = e.pageX - offset.left;
                form.clk_y = e.pageY - offset.top;
            } else {
                form.clk_x = e.pageX - target.offsetLeft;
                form.clk_y = e.pageY - target.offsetTop;
            }
        }
        setTimeout(function() {
            form.clk = form.clk_x = form.clk_y = null;
        }, 100);
    }
    $.fn.ajaxFormUnbind = function() {
        return this.unbind("submit.form-plugin click.form-plugin");
    };
    $.fn.formToArray = function(semantic, elements) {
        var a = [];
        if (this.length === 0) {
            return a;
        }
        var form = this[0];
        var formId = this.attr("id");
        var els = semantic ? form.getElementsByTagName("*") : form.elements;
        var els2;
        if (els && !/MSIE [678]/.test(navigator.userAgent)) {
            els = $(els).get();
        }
        if (formId) {
            els2 = $(':input[form="' + formId + '"]').get();
            if (els2.length) {
                els = (els || []).concat(els2);
            }
        }
        if (!els || !els.length) {
            return a;
        }
        var i, j, n, v, el, max, jmax;
        for (i = 0, max = els.length; i < max; i++) {
            el = els[i];
            n = el.name;
            if (!n || el.disabled) {
                continue;
            }
            if (semantic && form.clk && el.type == "image") {
                if (form.clk == el) {
                    a.push({
                        name: n,
                        value: $(el).val(),
                        type: el.type
                    });
                    a.push({
                        name: n + ".x",
                        value: form.clk_x
                    }, {
                        name: n + ".y",
                        value: form.clk_y
                    });
                }
                continue;
            }
            v = $.fieldValue(el, true);
            if (v && v.constructor == Array) {
                if (elements) {
                    elements.push(el);
                }
                for (j = 0, jmax = v.length; j < jmax; j++) {
                    a.push({
                        name: n,
                        value: v[j]
                    });
                }
            } else if (feature.fileapi && el.type == "file") {
                if (elements) {
                    elements.push(el);
                }
                var files = el.files;
                if (files.length) {
                    for (j = 0; j < files.length; j++) {
                        a.push({
                            name: n,
                            value: files[j],
                            type: el.type
                        });
                    }
                } else {
                    a.push({
                        name: n,
                        value: "",
                        type: el.type
                    });
                }
            } else if (v !== null && typeof v != "undefined") {
                if (elements) {
                    elements.push(el);
                }
                a.push({
                    name: n,
                    value: v,
                    type: el.type,
                    required: el.required
                });
            }
        }
        if (!semantic && form.clk) {
            var $input = $(form.clk), input = $input[0];
            n = input.name;
            if (n && !input.disabled && input.type == "image") {
                a.push({
                    name: n,
                    value: $input.val()
                });
                a.push({
                    name: n + ".x",
                    value: form.clk_x
                }, {
                    name: n + ".y",
                    value: form.clk_y
                });
            }
        }
        return a;
    };
    $.fn.formSerialize = function(semantic) {
        return $.param(this.formToArray(semantic));
    };
    $.fn.fieldSerialize = function(successful) {
        var a = [];
        this.each(function() {
            var n = this.name;
            if (!n) {
                return;
            }
            var v = $.fieldValue(this, successful);
            if (v && v.constructor == Array) {
                for (var i = 0, max = v.length; i < max; i++) {
                    a.push({
                        name: n,
                        value: v[i]
                    });
                }
            } else if (v !== null && typeof v != "undefined") {
                a.push({
                    name: this.name,
                    value: v
                });
            }
        });
        return $.param(a);
    };
    $.fn.fieldValue = function(successful) {
        for (var val = [], i = 0, max = this.length; i < max; i++) {
            var el = this[i];
            var v = $.fieldValue(el, successful);
            if (v === null || typeof v == "undefined" || v.constructor == Array && !v.length) {
                continue;
            }
            if (v.constructor == Array) {
                $.merge(val, v);
            } else {
                val.push(v);
            }
        }
        return val;
    };
    $.fieldValue = function(el, successful) {
        var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
        if (successful === undefined) {
            successful = true;
        }
        if (successful && (!n || el.disabled || t == "reset" || t == "button" || (t == "checkbox" || t == "radio") && !el.checked || (t == "submit" || t == "image") && el.form && el.form.clk != el || tag == "select" && el.selectedIndex == -1)) {
            return null;
        }
        if (tag == "select") {
            var index = el.selectedIndex;
            if (index < 0) {
                return null;
            }
            var a = [], ops = el.options;
            var one = t == "select-one";
            var max = one ? index + 1 : ops.length;
            for (var i = one ? index : 0; i < max; i++) {
                var op = ops[i];
                if (op.selected) {
                    var v = op.value;
                    if (!v) {
                        v = op.attributes && op.attributes.value && !op.attributes.value.specified ? op.text : op.value;
                    }
                    if (one) {
                        return v;
                    }
                    a.push(v);
                }
            }
            return a;
        }
        return $(el).val();
    };
    $.fn.clearForm = function(includeHidden) {
        return this.each(function() {
            $("input,select,textarea", this).clearFields(includeHidden);
        });
    };
    $.fn.clearFields = $.fn.clearInputs = function(includeHidden) {
        var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i;
        return this.each(function() {
            var t = this.type, tag = this.tagName.toLowerCase();
            if (re.test(t) || tag == "textarea") {
                this.value = "";
            } else if (t == "checkbox" || t == "radio") {
                this.checked = false;
            } else if (tag == "select") {
                this.selectedIndex = -1;
            } else if (t == "file") {
                if (/MSIE/.test(navigator.userAgent)) {
                    $(this).replaceWith($(this).clone(true));
                } else {
                    $(this).val("");
                }
            } else if (includeHidden) {
                if (includeHidden === true && /hidden/.test(t) || typeof includeHidden == "string" && $(this).is(includeHidden)) {
                    this.value = "";
                }
            }
        });
    };
    $.fn.resetForm = function() {
        return this.each(function() {
            if (typeof this.reset == "function" || typeof this.reset == "object" && !this.reset.nodeType) {
                this.reset();
            }
        });
    };
    $.fn.enable = function(b) {
        if (b === undefined) {
            b = true;
        }
        return this.each(function() {
            this.disabled = !b;
        });
    };
    $.fn.selected = function(select) {
        if (select === undefined) {
            select = true;
        }
        return this.each(function() {
            var t = this.type;
            if (t == "checkbox" || t == "radio") {
                this.checked = select;
            } else if (this.tagName.toLowerCase() == "option") {
                var $sel = $(this).parent("select");
                if (select && $sel[0] && $sel[0].type == "select-one") {
                    $sel.find("option").selected(false);
                }
                this.selected = select;
            }
        });
    };
    $.fn.ajaxSubmit.debug = false;
    function log() {
        if (!$.fn.ajaxSubmit.debug) {
            return;
        }
        var msg = "[jquery.form] " + Array.prototype.join.call(arguments, "");
        if (window.console && window.console.log) {
            window.console.log(msg);
        } else if (window.opera && window.opera.postError) {
            window.opera.postError(msg);
        }
    }
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(window.jQuery || window.Zepto);
    }
})(function($) {
    "use strict";
    var Mask = function(el, mask, options) {
        var jMask = this, old_value, regexMask;
        el = $(el);
        mask = typeof mask === "function" ? mask(el.val(), undefined, el, options) : mask;
        var p = {
            getCaret: function() {
                try {
                    var sel, pos = 0, ctrl = el.get(0), dSel = document.selection, cSelStart = ctrl.selectionStart;
                    if (dSel && !~navigator.appVersion.indexOf("MSIE 10")) {
                        sel = dSel.createRange();
                        sel.moveStart("character", el.is("input") ? -el.val().length : -el.text().length);
                        pos = sel.text.length;
                    } else if (cSelStart || cSelStart === "0") {
                        pos = cSelStart;
                    }
                    return pos;
                } catch (e) {}
            },
            setCaret: function(pos) {
                try {
                    if (el.is(":focus")) {
                        var range, ctrl = el.get(0);
                        if (ctrl.setSelectionRange) {
                            ctrl.setSelectionRange(pos, pos);
                        } else if (ctrl.createTextRange) {
                            range = ctrl.createTextRange();
                            range.collapse(true);
                            range.moveEnd("character", pos);
                            range.moveStart("character", pos);
                            range.select();
                        }
                    }
                } catch (e) {}
            },
            events: function() {
                el.on("keydown.mask", function() {
                    old_value = p.val();
                }).on("keyup.mask", p.behaviour).on("paste.mask drop.mask", function() {
                    setTimeout(function() {
                        el.keydown().keyup();
                    }, 100);
                }).on("change.mask", function() {
                    el.data("changed", true);
                }).on("blur.mask", function() {
                    if (old_value !== el.val() && !el.data("changed")) {
                        el.trigger("change");
                    }
                    el.data("changed", false);
                }).on("focusout.mask", function() {
                    if (options.clearIfNotMatch && !regexMask.test(p.val())) {
                        p.val("");
                    }
                });
            },
            getRegexMask: function() {
                var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;
                for (var i = 0; i < mask.length; i++) {
                    translation = jMask.translation[mask[i]];
                    if (translation) {
                        pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, "");
                        optional = translation.optional;
                        recursive = translation.recursive;
                        if (recursive) {
                            maskChunks.push(mask[i]);
                            oRecursive = {
                                digit: mask[i],
                                pattern: pattern
                            };
                        } else {
                            maskChunks.push(!optional && !recursive ? pattern : pattern + "?");
                        }
                    } else {
                        maskChunks.push(mask[i].replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
                    }
                }
                r = maskChunks.join("");
                if (oRecursive) {
                    r = r.replace(new RegExp("(" + oRecursive.digit + "(.*" + oRecursive.digit + ")?)"), "($1)?").replace(new RegExp(oRecursive.digit, "g"), oRecursive.pattern);
                }
                return new RegExp(r);
            },
            destroyEvents: function() {
                el.off([ "keydown", "keyup", "paste", "drop", "change", "blur", "focusout", "DOMNodeInserted", "" ].join(".mask ")).removeData("changeCalled");
            },
            val: function(v) {
                var isInput = el.is("input");
                return arguments.length > 0 ? isInput ? el.val(v) : el.text(v) : isInput ? el.val() : el.text();
            },
            getMCharsBeforeCount: function(index, onCleanVal) {
                for (var count = 0, i = 0, maskL = mask.length; i < maskL && i < index; i++) {
                    if (!jMask.translation[mask.charAt(i)]) {
                        index = onCleanVal ? index + 1 : index;
                        count++;
                    }
                }
                return count;
            },
            caretPos: function(originalCaretPos, oldLength, newLength, maskDif) {
                var translation = jMask.translation[mask.charAt(Math.min(originalCaretPos - 1, mask.length - 1))];
                return !translation ? p.caretPos(originalCaretPos + 1, oldLength, newLength, maskDif) : Math.min(originalCaretPos + newLength - oldLength - maskDif, newLength);
            },
            behaviour: function(e) {
                e = e || window.event;
                var keyCode = e.keyCode || e.which;
                if ($.inArray(keyCode, jMask.byPassKeys) === -1) {
                    var caretPos = p.getCaret(), currVal = p.val(), currValL = currVal.length, changeCaret = caretPos < currValL, newVal = p.getMasked(), newValL = newVal.length, maskDif = p.getMCharsBeforeCount(newValL - 1) - p.getMCharsBeforeCount(currValL - 1);
                    if (newVal !== currVal) {
                        p.val(newVal);
                    }
                    if (changeCaret && !(keyCode === 65 && e.ctrlKey)) {
                        if (!(keyCode === 8 || keyCode === 46)) {
                            caretPos = p.caretPos(caretPos, currValL, newValL, maskDif);
                        }
                        p.setCaret(caretPos);
                    }
                    return p.callbacks(e);
                }
            },
            getMasked: function(skipMaskChars) {
                var buf = [], value = p.val(), m = 0, maskLen = mask.length, v = 0, valLen = value.length, offset = 1, addMethod = "push", resetPos = -1, lastMaskChar, check;
                if (options.reverse) {
                    addMethod = "unshift";
                    offset = -1;
                    lastMaskChar = 0;
                    m = maskLen - 1;
                    v = valLen - 1;
                    check = function() {
                        return m > -1 && v > -1;
                    };
                } else {
                    lastMaskChar = maskLen - 1;
                    check = function() {
                        return m < maskLen && v < valLen;
                    };
                }
                while (check()) {
                    var maskDigit = mask.charAt(m), valDigit = value.charAt(v), translation = jMask.translation[maskDigit];
                    if (translation) {
                        if (valDigit.match(translation.pattern)) {
                            buf[addMethod](valDigit);
                            if (translation.recursive) {
                                if (resetPos === -1) {
                                    resetPos = m;
                                } else if (m === lastMaskChar) {
                                    m = resetPos - offset;
                                }
                                if (lastMaskChar === resetPos) {
                                    m -= offset;
                                }
                            }
                            m += offset;
                        } else if (translation.optional) {
                            m += offset;
                            v -= offset;
                        }
                        v += offset;
                    } else {
                        if (!skipMaskChars) {
                            buf[addMethod](maskDigit);
                        }
                        if (valDigit === maskDigit) {
                            v += offset;
                        }
                        m += offset;
                    }
                }
                var lastMaskCharDigit = mask.charAt(lastMaskChar);
                if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {
                    buf.push(lastMaskCharDigit);
                }
                return buf.join("");
            },
            callbacks: function(e) {
                var val = p.val(), changed = val !== old_value;
                if (changed === true) {
                    if (typeof options.onChange === "function") {
                        options.onChange(val, e, el, options);
                    }
                }
                if (changed === true && typeof options.onKeyPress === "function") {
                    options.onKeyPress(val, e, el, options);
                }
                if (typeof options.onComplete === "function" && val.length === mask.length) {
                    options.onComplete(val, e, el, options);
                }
            }
        };
        jMask.mask = mask;
        jMask.options = options;
        jMask.remove = function() {
            var caret;
            p.destroyEvents();
            p.val(jMask.getCleanVal()).removeAttr("maxlength");
            caret = p.getCaret();
            p.setCaret(caret - p.getMCharsBeforeCount(caret));
            return el;
        };
        jMask.getCleanVal = function() {
            return p.getMasked(true);
        };
        jMask.init = function() {
            options = options || {};
            jMask.byPassKeys = [ 9, 16, 17, 18, 36, 37, 38, 39, 40, 91 ];
            jMask.translation = {
                "0": {
                    pattern: /\d/
                },
                "9": {
                    pattern: /\d/,
                    optional: true
                },
                "#": {
                    pattern: /\d/,
                    recursive: true
                },
                A: {
                    pattern: /[a-zA-Z0-9]/
                },
                S: {
                    pattern: /[a-zA-Z]/
                }
            };
            jMask.translation = $.extend({}, jMask.translation, options.translation);
            jMask = $.extend(true, {}, jMask, options);
            regexMask = p.getRegexMask();
            if (options.maxlength !== false) {
                el.attr("maxlength", mask.length);
            }
            if (options.placeholder) {
                el.attr("placeholder", options.placeholder);
            }
            el.attr("autocomplete", "off");
            p.destroyEvents();
            p.events();
            var caret = p.getCaret();
            p.val(p.getMasked());
            p.setCaret(caret + p.getMCharsBeforeCount(caret, true));
        }();
    };
    var watchers = {}, live = "DOMNodeInserted.mask", HTMLAttributes = function() {
        var input = $(this), options = {}, prefix = "data-mask-";
        if (input.attr(prefix + "reverse")) {
            options.reverse = true;
        }
        if (input.attr(prefix + "maxlength") === "false") {
            options.maxlength = false;
        }
        if (input.attr(prefix + "clearifnotmatch")) {
            options.clearIfNotMatch = true;
        }
        input.mask(input.attr("data-mask"), options);
    };
    $.fn.mask = function(mask, options) {
        var selector = this.selector, maskFunction = function() {
            var maskObject = $(this).data("mask"), stringify = JSON.stringify;
            if (typeof maskObject !== "object" || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask) {
                return $(this).data("mask", new Mask(this, mask, options));
            }
        };
        this.each(maskFunction);
        if (selector && !watchers[selector]) {
            watchers[selector] = true;
            setTimeout(function() {
                $(document).on(live, selector, maskFunction);
            }, 500);
        }
    };
    $.fn.unmask = function() {
        try {
            return this.each(function() {
                $(this).data("mask").remove().removeData("mask");
            });
        } catch (e) {}
    };
    $.fn.cleanVal = function() {
        return this.data("mask").getCleanVal();
    };
    $("*[data-mask]").each(HTMLAttributes);
    $(document).on(live, "*[data-mask]", HTMLAttributes);
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define(factory);
    } else {
        window.purl = factory();
    }
})(function() {
    var tag2attr = {
        a: "href",
        img: "src",
        form: "action",
        base: "href",
        script: "src",
        iframe: "src",
        link: "href",
        embed: "src",
        object: "data"
    }, key = [ "source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "fragment" ], aliases = {
        anchor: "fragment"
    }, parser = {
        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }, isint = /^[0-9]+$/;
    function parseUri(url, strictMode) {
        var str = decodeURI(url), res = parser[strictMode || false ? "strict" : "loose"].exec(str), uri = {
            attr: {},
            param: {},
            seg: {}
        }, i = 14;
        while (i--) {
            uri.attr[key[i]] = res[i] || "";
        }
        uri.param["query"] = parseString(uri.attr["query"]);
        uri.param["fragment"] = parseString(uri.attr["fragment"]);
        uri.seg["path"] = uri.attr.path.replace(/^\/+|\/+$/g, "").split("/");
        uri.seg["fragment"] = uri.attr.fragment.replace(/^\/+|\/+$/g, "").split("/");
        uri.attr["base"] = uri.attr.host ? (uri.attr.protocol ? uri.attr.protocol + "://" + uri.attr.host : uri.attr.host) + (uri.attr.port ? ":" + uri.attr.port : "") : "";
        return uri;
    }
    function getAttrName(elm) {
        var tn = elm.tagName;
        if (typeof tn !== "undefined") return tag2attr[tn.toLowerCase()];
        return tn;
    }
    function promote(parent, key) {
        if (parent[key].length === 0) return parent[key] = {};
        var t = {};
        for (var i in parent[key]) t[i] = parent[key][i];
        parent[key] = t;
        return t;
    }
    function parse(parts, parent, key, val) {
        var part = parts.shift();
        if (!part) {
            if (isArray(parent[key])) {
                parent[key].push(val);
            } else if ("object" == typeof parent[key]) {
                parent[key] = val;
            } else if ("undefined" == typeof parent[key]) {
                parent[key] = val;
            } else {
                parent[key] = [ parent[key], val ];
            }
        } else {
            var obj = parent[key] = parent[key] || [];
            if ("]" == part) {
                if (isArray(obj)) {
                    if ("" !== val) obj.push(val);
                } else if ("object" == typeof obj) {
                    obj[keys(obj).length] = val;
                } else {
                    obj = parent[key] = [ parent[key], val ];
                }
            } else if (~part.indexOf("]")) {
                part = part.substr(0, part.length - 1);
                if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
                parse(parts, obj, part, val);
            } else {
                if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
                parse(parts, obj, part, val);
            }
        }
    }
    function merge(parent, key, val) {
        if (~key.indexOf("]")) {
            var parts = key.split("[");
            parse(parts, parent, "base", val);
        } else {
            if (!isint.test(key) && isArray(parent.base)) {
                var t = {};
                for (var k in parent.base) t[k] = parent.base[k];
                parent.base = t;
            }
            if (key !== "") {
                set(parent.base, key, val);
            }
        }
        return parent;
    }
    function parseString(str) {
        return reduce(String(str).split(/&|;/), function(ret, pair) {
            try {
                pair = decodeURIComponent(pair.replace(/\+/g, " "));
            } catch (e) {}
            var eql = pair.indexOf("="), brace = lastBraceInKey(pair), key = pair.substr(0, brace || eql), val = pair.substr(brace || eql, pair.length);
            val = val.substr(val.indexOf("=") + 1, val.length);
            if (key === "") {
                key = pair;
                val = "";
            }
            return merge(ret, key, val);
        }, {
            base: {}
        }).base;
    }
    function set(obj, key, val) {
        var v = obj[key];
        if (typeof v === "undefined") {
            obj[key] = val;
        } else if (isArray(v)) {
            v.push(val);
        } else {
            obj[key] = [ v, val ];
        }
    }
    function lastBraceInKey(str) {
        var len = str.length, brace, c;
        for (var i = 0; i < len; ++i) {
            c = str[i];
            if ("]" == c) brace = false;
            if ("[" == c) brace = true;
            if ("=" == c && !brace) return i;
        }
    }
    function reduce(obj, accumulator) {
        var i = 0, l = obj.length >> 0, curr = arguments[2];
        while (i < l) {
            if (i in obj) curr = accumulator.call(undefined, curr, obj[i], i, obj);
            ++i;
        }
        return curr;
    }
    function isArray(vArg) {
        return Object.prototype.toString.call(vArg) === "[object Array]";
    }
    function keys(obj) {
        var key_array = [];
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) key_array.push(prop);
        }
        return key_array;
    }
    function purl(url, strictMode) {
        if (arguments.length === 1 && url === true) {
            strictMode = true;
            url = undefined;
        }
        strictMode = strictMode || false;
        url = url || window.location.toString();
        return {
            data: parseUri(url, strictMode),
            attr: function(attr) {
                attr = aliases[attr] || attr;
                return typeof attr !== "undefined" ? this.data.attr[attr] : this.data.attr;
            },
            param: function(param) {
                return typeof param !== "undefined" ? this.data.param.query[param] : this.data.param.query;
            },
            fparam: function(param) {
                return typeof param !== "undefined" ? this.data.param.fragment[param] : this.data.param.fragment;
            },
            segment: function(seg) {
                if (typeof seg === "undefined") {
                    return this.data.seg.path;
                } else {
                    seg = seg < 0 ? this.data.seg.path.length + seg : seg - 1;
                    return this.data.seg.path[seg];
                }
            },
            fsegment: function(seg) {
                if (typeof seg === "undefined") {
                    return this.data.seg.fragment;
                } else {
                    seg = seg < 0 ? this.data.seg.fragment.length + seg : seg - 1;
                    return this.data.seg.fragment[seg];
                }
            }
        };
    }
    purl.jQuery = function($) {
        if ($ != null) {
            $.fn.url = function(strictMode) {
                var url = "";
                if (this.length) {
                    url = $(this).attr(getAttrName(this[0])) || "";
                }
                return purl(url, strictMode);
            };
            $.url = purl;
        }
    };
    purl.jQuery(window.jQuery);
    return purl;
});

(function($) {
    if (typeof $.fn.each2 == "undefined") {
        $.extend($.fn, {
            each2: function(c) {
                var j = $([ 0 ]), i = -1, l = this.length;
                while (++i < l && (j.context = j[0] = this[i]) && c.call(j[0], i, j) !== false) ;
                return this;
            }
        });
    }
})(jQuery);

(function($, undefined) {
    "use strict";
    if (window.Select2 !== undefined) {
        return;
    }
    var KEY, AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer, lastMousePosition = {
        x: 0,
        y: 0
    }, $document, scrollBarDimensions, KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        isArrow: function(k) {
            k = k.which ? k.which : k;
            switch (k) {
              case KEY.LEFT:
              case KEY.RIGHT:
              case KEY.UP:
              case KEY.DOWN:
                return true;
            }
            return false;
        },
        isControl: function(e) {
            var k = e.which;
            switch (k) {
              case KEY.SHIFT:
              case KEY.CTRL:
              case KEY.ALT:
                return true;
            }
            if (e.metaKey) return true;
            return false;
        },
        isFunctionKey: function(k) {
            k = k.which ? k.which : k;
            return k >= 112 && k <= 123;
        }
    }, MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>", DIACRITICS = {
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "AA",
        "": "AE",
        "": "AE",
        "": "AE",
        "": "AO",
        "": "AU",
        "": "AV",
        "": "AV",
        "": "AY",
        "": "B",
        "": "B",
        "": "B",
        "": "B",
        "": "B",
        "": "B",
        "": "B",
        "": "B",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "D",
        "": "DZ",
        "": "DZ",
        "": "Dz",
        "": "Dz",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "F",
        "": "F",
        "": "F",
        "": "F",
        "": "F",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "H",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "J",
        "": "J",
        "": "J",
        "": "J",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "K",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "LJ",
        "": "Lj",
        "": "M",
        "": "M",
        "": "M",
        "": "M",
        "": "M",
        "": "M",
        "": "M",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "NJ",
        "": "Nj",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "OI",
        "": "OO",
        "": "OU",
        "": "P",
        "": "P",
        "": "P",
        "": "P",
        "": "P",
        "": "P",
        "": "P",
        "": "P",
        "": "P",
        "": "Q",
        "": "Q",
        "": "Q",
        "": "Q",
        "": "Q",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "R",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "T",
        "": "TZ",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "V",
        "": "V",
        "": "V",
        "": "V",
        "": "V",
        "": "V",
        "": "V",
        "": "VY",
        "": "W",
        "": "W",
        "": "W",
        "": "W",
        "": "W",
        "": "W",
        "": "W",
        "": "W",
        "": "W",
        "": "X",
        "": "X",
        "": "X",
        "": "X",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "aa",
        "": "ae",
        "": "ae",
        "": "ae",
        "": "ao",
        "": "au",
        "": "av",
        "": "av",
        "": "ay",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "dz",
        "": "dz",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "f",
        "": "f",
        "": "f",
        "": "f",
        "": "f",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "hv",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "j",
        "": "j",
        "": "j",
        "": "j",
        "": "j",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "lj",
        "": "m",
        "": "m",
        "": "m",
        "": "m",
        "": "m",
        "": "m",
        "": "m",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "nj",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "oi",
        "": "ou",
        "": "oo",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "q",
        "": "q",
        "": "q",
        "": "q",
        "": "q",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "tz",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "v",
        "": "v",
        "": "v",
        "": "v",
        "": "v",
        "": "v",
        "": "v",
        "": "vy",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "x",
        "": "x",
        "": "x",
        "": "x",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": ""
    };
    $document = $(document);
    nextUid = function() {
        var counter = 1;
        return function() {
            return counter++;
        };
    }();
    function reinsertElement(element) {
        var placeholder = $(document.createTextNode(""));
        element.before(placeholder);
        placeholder.before(element);
        placeholder.remove();
    }
    function stripDiacritics(str) {
        function match(a) {
            return DIACRITICS[a] || a;
        }
        return str.replace(/[^\u0000-\u007E]/g, match);
    }
    function indexOf(value, array) {
        var i = 0, l = array.length;
        for (;i < l; i = i + 1) {
            if (equal(value, array[i])) return i;
        }
        return -1;
    }
    function measureScrollbar() {
        var $template = $(MEASURE_SCROLLBAR_TEMPLATE);
        $template.appendTo("body");
        var dim = {
            width: $template.width() - $template[0].clientWidth,
            height: $template.height() - $template[0].clientHeight
        };
        $template.remove();
        return dim;
    }
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        if (a.constructor === String) return a + "" === b + "";
        if (b.constructor === String) return b + "" === a + "";
        return false;
    }
    function splitVal(string, separator) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = $.trim(val[i]);
        return val;
    }
    function getSideBorderPadding(element) {
        return element.outerWidth(false) - element.width();
    }
    function installKeyUpChangeEvent(element) {
        var key = "keyup-change-value";
        element.on("keydown", function() {
            if ($.data(element, key) === undefined) {
                $.data(element, key, element.val());
            }
        });
        element.on("keyup", function() {
            var val = $.data(element, key);
            if (val !== undefined && element.val() !== val) {
                $.removeData(element, key);
                element.trigger("keyup-change");
            }
        });
    }
    function installFilteredMouseMove(element) {
        element.on("mousemove", function(e) {
            var lastpos = lastMousePosition;
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }
    function debounce(quietMillis, fn, ctx) {
        ctx = ctx || undefined;
        var timeout;
        return function() {
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                fn.apply(ctx, args);
            }, quietMillis);
        };
    }
    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function(e) {
            element.trigger("scroll-debounced", e);
        });
        element.on("scroll", function(e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }
    function focus($el) {
        if ($el[0] === document.activeElement) return;
        window.setTimeout(function() {
            var el = $el[0], pos = $el.val().length, range;
            $el.focus();
            var isVisible = el.offsetWidth > 0 || el.offsetHeight > 0;
            if (isVisible && el === document.activeElement) {
                if (el.setSelectionRange) {
                    el.setSelectionRange(pos, pos);
                } else if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                }
            }
        }, 0);
    }
    function getCursorInfo(el) {
        el = $(el)[0];
        var offset = 0;
        var length = 0;
        if ("selectionStart" in el) {
            offset = el.selectionStart;
            length = el.selectionEnd - offset;
        } else if ("selection" in document) {
            el.focus();
            var sel = document.selection.createRange();
            length = document.selection.createRange().text.length;
            sel.moveStart("character", -el.value.length);
            offset = sel.text.length - length;
        }
        return {
            offset: offset,
            length: length
        };
    }
    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function killEventImmediately(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
    }
    function measureTextWidth(e) {
        if (!sizer) {
            var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
            sizer = $(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                letterSpacing: style.letterSpacing,
                textTransform: style.textTransform,
                whiteSpace: "nowrap"
            });
            sizer.attr("class", "select2-sizer");
            $("body").append(sizer);
        }
        sizer.text(e.val());
        return sizer.width();
    }
    function syncCssClasses(dest, src, adapter) {
        var classes, replacements = [], adapted;
        classes = $.trim(dest.attr("class"));
        if (classes) {
            classes = "" + classes;
            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") === 0) {
                    replacements.push(this);
                }
            });
        }
        classes = $.trim(src.attr("class"));
        if (classes) {
            classes = "" + classes;
            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") !== 0) {
                    adapted = adapter(this);
                    if (adapted) {
                        replacements.push(adapted);
                    }
                }
            });
        }
        dest.attr("class", replacements.join(" "));
    }
    function markMatch(text, term, markup, escapeMarkup) {
        var match = stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())), tl = term.length;
        if (match < 0) {
            markup.push(escapeMarkup(text));
            return;
        }
        markup.push(escapeMarkup(text.substring(0, match)));
        markup.push("<span class='select2-match'>");
        markup.push(escapeMarkup(text.substring(match, match + tl)));
        markup.push("</span>");
        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
    }
    function defaultEscapeMarkup(markup) {
        var replace_map = {
            "\\": "&#92;",
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
            "/": "&#47;"
        };
        return String(markup).replace(/[&<>"'\/\\]/g, function(match) {
            return replace_map[match];
        });
    }
    function ajax(options) {
        var timeout, handler = null, quietMillis = options.quietMillis || 100, ajaxUrl = options.url, self = this;
        return function(query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                var data = options.data, url = ajaxUrl, transport = options.transport || $.fn.select2.ajaxDefaults.transport, deprecated = {
                    type: options.type || "GET",
                    cache: options.cache || false,
                    jsonpCallback: options.jsonpCallback || undefined,
                    dataType: options.dataType || "json"
                }, params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);
                data = data ? data.call(self, query.term, query.page, query.context) : null;
                url = typeof url === "function" ? url.call(self, query.term, query.page, query.context) : url;
                if (handler && typeof handler.abort === "function") {
                    handler.abort();
                }
                if (options.params) {
                    if ($.isFunction(options.params)) {
                        $.extend(params, options.params.call(self));
                    } else {
                        $.extend(params, options.params);
                    }
                }
                $.extend(params, {
                    url: url,
                    dataType: options.dataType,
                    data: data,
                    success: function(data) {
                        var results = options.results(data, query.page, query);
                        query.callback(results);
                    }
                });
                handler = transport.call(self, params);
            }, quietMillis);
        };
    }
    function local(options) {
        var data = options, dataText, tmp, text = function(item) {
            return "" + item.text;
        };
        if ($.isArray(data)) {
            tmp = data;
            data = {
                results: tmp
            };
        }
        if ($.isFunction(data) === false) {
            tmp = data;
            data = function() {
                return tmp;
            };
        }
        var dataItem = data();
        if (dataItem.text) {
            text = dataItem.text;
            if (!$.isFunction(text)) {
                dataText = dataItem.text;
                text = function(item) {
                    return item[dataText];
                };
            }
        }
        return function(query) {
            var t = query.term, filtered = {
                results: []
            }, process;
            if (t === "") {
                query.callback(data());
                return;
            }
            process = function(datum, collection) {
                var group, attr;
                datum = datum[0];
                if (datum.children) {
                    group = {};
                    for (attr in datum) {
                        if (datum.hasOwnProperty(attr)) group[attr] = datum[attr];
                    }
                    group.children = [];
                    $(datum.children).each2(function(i, childDatum) {
                        process(childDatum, group.children);
                    });
                    if (group.children.length || query.matcher(t, text(group), datum)) {
                        collection.push(group);
                    }
                } else {
                    if (query.matcher(t, text(datum), datum)) {
                        collection.push(datum);
                    }
                }
            };
            $(data().results).each2(function(i, datum) {
                process(datum, filtered.results);
            });
            query.callback(filtered);
        };
    }
    function tags(data) {
        var isFunc = $.isFunction(data);
        return function(query) {
            var t = query.term, filtered = {
                results: []
            };
            var result = isFunc ? data(query) : data;
            if ($.isArray(result)) {
                $(result).each(function() {
                    var isObject = this.text !== undefined, text = isObject ? this.text : this;
                    if (t === "" || query.matcher(t, text)) {
                        filtered.results.push(isObject ? this : {
                            id: this,
                            text: this
                        });
                    }
                });
                query.callback(filtered);
            }
        };
    }
    function checkFormatter(formatter, formatterName) {
        if ($.isFunction(formatter)) return true;
        if (!formatter) return false;
        if (typeof formatter === "string") return true;
        throw new Error(formatterName + " must be a string, function, or falsy value");
    }
    function evaluate(val, context) {
        if ($.isFunction(val)) {
            var args = Array.prototype.slice.call(arguments, 2);
            return val.apply(context, args);
        }
        return val;
    }
    function countResults(results) {
        var count = 0;
        $.each(results, function(i, item) {
            if (item.children) {
                count += countResults(item.children);
            } else {
                count++;
            }
        });
        return count;
    }
    function defaultTokenizer(input, selection, selectCallback, opts) {
        var original = input, dupe = false, token, index, i, l, separator;
        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;
        while (true) {
            index = -1;
            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                separator = opts.tokenSeparators[i];
                index = input.indexOf(separator);
                if (index >= 0) break;
            }
            if (index < 0) break;
            token = input.substring(0, index);
            input = input.substring(index + separator.length);
            if (token.length > 0) {
                token = opts.createSearchChoice.call(this, token, selection);
                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                    dupe = false;
                    for (i = 0, l = selection.length; i < l; i++) {
                        if (equal(opts.id(token), opts.id(selection[i]))) {
                            dupe = true;
                            break;
                        }
                    }
                    if (!dupe) selectCallback(token);
                }
            }
        }
        if (original !== input) return input;
    }
    function cleanupJQueryElements() {
        var self = this;
        $.each(arguments, function(i, element) {
            self[element].remove();
            self[element] = null;
        });
    }
    function clazz(SuperClass, methods) {
        var constructor = function() {};
        constructor.prototype = new SuperClass();
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }
    AbstractSelect2 = clazz(Object, {
        bind: function(func) {
            var self = this;
            return function() {
                func.apply(self, arguments);
            };
        },
        init: function(opts) {
            var results, search, resultsSelector = ".select2-results";
            this.opts = opts = this.prepareOpts(opts);
            this.id = opts.id;
            if (opts.element.data("select2") !== undefined && opts.element.data("select2") !== null) {
                opts.element.data("select2").destroy();
            }
            this.container = this.createContainer();
            this.liveRegion = $("<span>", {
                role: "status",
                "aria-live": "polite"
            }).addClass("select2-hidden-accessible").appendTo(document.body);
            this.containerId = "s2id_" + (opts.element.attr("id") || "autogen" + nextUid());
            this.containerEventName = this.containerId.replace(/([.])/g, "_").replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, "\\$1");
            this.container.attr("id", this.containerId);
            this.container.attr("title", opts.element.attr("title"));
            this.body = $("body");
            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
            this.container.attr("style", opts.element.attr("style"));
            this.container.css(evaluate(opts.containerCss, this.opts.element));
            this.container.addClass(evaluate(opts.containerCssClass, this.opts.element));
            this.elementTabIndex = this.opts.element.attr("tabindex");
            this.opts.element.data("select2", this).attr("tabindex", "-1").before(this.container).on("click.select2", killEvent);
            this.container.data("select2", this);
            this.dropdown = this.container.find(".select2-drop");
            syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
            this.dropdown.addClass(evaluate(opts.dropdownCssClass, this.opts.element));
            this.dropdown.data("select2", this);
            this.dropdown.on("click", killEvent);
            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input.select2-input");
            this.queryCount = 0;
            this.resultsPage = 0;
            this.context = null;
            this.initContainer();
            this.container.on("click", killEvent);
            installFilteredMouseMove(this.results);
            this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
            this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function(event) {
                this._touchEvent = true;
                this.highlightUnderEvent(event);
            }));
            this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
            this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));
            this.dropdown.on("click", this.bind(function(event) {
                if (this._touchEvent) {
                    this._touchEvent = false;
                    this.selectHighlighted();
                }
            }));
            installDebouncedScroll(80, this.results);
            this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));
            $(this.container).on("change", ".select2-input", function(e) {
                e.stopPropagation();
            });
            $(this.dropdown).on("change", ".select2-input", function(e) {
                e.stopPropagation();
            });
            if ($.fn.mousewheel) {
                results.mousewheel(function(e, delta, deltaX, deltaY) {
                    var top = results.scrollTop();
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }
            installKeyUpChangeEvent(search);
            search.on("keyup-change input paste", this.bind(this.updateResults));
            search.on("focus", function() {
                search.addClass("select2-focused");
            });
            search.on("blur", function() {
                search.removeClass("select2-focused");
            });
            this.dropdown.on("mouseup", resultsSelector, this.bind(function(e) {
                if ($(e.target).closest(".select2-result-selectable").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                }
            }));
            this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function(e) {
                e.stopPropagation();
            });
            this.nextSearchTerm = undefined;
            if ($.isFunction(this.opts.initSelection)) {
                this.initSelection();
                this.monitorSource();
            }
            if (opts.maximumInputLength !== null) {
                this.search.attr("maxlength", opts.maximumInputLength);
            }
            var disabled = opts.element.prop("disabled");
            if (disabled === undefined) disabled = false;
            this.enable(!disabled);
            var readonly = opts.element.prop("readonly");
            if (readonly === undefined) readonly = false;
            this.readonly(readonly);
            scrollBarDimensions = scrollBarDimensions || measureScrollbar();
            this.autofocus = opts.element.prop("autofocus");
            opts.element.prop("autofocus", false);
            if (this.autofocus) this.focus();
            this.search.attr("placeholder", opts.searchInputPlaceholder);
        },
        destroy: function() {
            var element = this.opts.element, select2 = element.data("select2");
            this.close();
            if (element.length && element[0].detachEvent) {
                element.each(function() {
                    this.detachEvent("onpropertychange", this._sync);
                });
            }
            if (this.propertyObserver) {
                this.propertyObserver.disconnect();
                this.propertyObserver = null;
            }
            this._sync = null;
            if (select2 !== undefined) {
                select2.container.remove();
                select2.liveRegion.remove();
                select2.dropdown.remove();
                element.removeClass("select2-offscreen").removeData("select2").off(".select2").prop("autofocus", this.autofocus || false);
                if (this.elementTabIndex) {
                    element.attr({
                        tabindex: this.elementTabIndex
                    });
                } else {
                    element.removeAttr("tabindex");
                }
                element.show();
            }
            cleanupJQueryElements.call(this, "container", "liveRegion", "dropdown", "results", "search");
        },
        optionToData: function(element) {
            if (element.is("option")) {
                return {
                    id: element.prop("value"),
                    text: element.text(),
                    element: element.get(),
                    css: element.attr("class"),
                    disabled: element.prop("disabled"),
                    locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                };
            } else if (element.is("optgroup")) {
                return {
                    text: element.attr("label"),
                    children: [],
                    element: element.get(),
                    css: element.attr("class")
                };
            }
        },
        prepareOpts: function(opts) {
            var element, select, idKey, ajaxUrl, self = this;
            element = opts.element;
            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }
            if (select) {
                $.each([ "id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags" ], function() {
                    if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
            }
            opts = $.extend({}, {
                populateResults: function(container, results, query) {
                    var populate, id = this.opts.id, liveRegion = this.liveRegion;
                    populate = function(results, container, depth) {
                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;
                        results = opts.sortResults(results, container, query);
                        var nodes = [];
                        for (i = 0, l = results.length; i < l; i = i + 1) {
                            result = results[i];
                            disabled = result.disabled === true;
                            selectable = !disabled && id(result) !== undefined;
                            compound = result.children && result.children.length > 0;
                            node = $("<li></li>");
                            node.addClass("select2-results-dept-" + depth);
                            node.addClass("select2-result");
                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                            if (disabled) {
                                node.addClass("select2-disabled");
                            }
                            if (compound) {
                                node.addClass("select2-result-with-children");
                            }
                            node.addClass(self.opts.formatResultCssClass(result));
                            node.attr("role", "presentation");
                            label = $(document.createElement("div"));
                            label.addClass("select2-result-label");
                            label.attr("id", "select2-result-label-" + nextUid());
                            label.attr("role", "option");
                            formatted = opts.formatResult(result, label, query, self.opts.escapeMarkup);
                            if (formatted !== undefined) {
                                label.html(formatted);
                                node.append(label);
                            }
                            if (compound) {
                                innerContainer = $("<ul></ul>");
                                innerContainer.addClass("select2-result-sub");
                                populate(result.children, innerContainer, depth + 1);
                                node.append(innerContainer);
                            }
                            node.data("select2-data", result);
                            nodes.push(node[0]);
                        }
                        container.append(nodes);
                        liveRegion.text(opts.formatMatches(results.length));
                    };
                    populate(results, container, 0);
                }
            }, $.fn.select2.defaults, opts);
            if (typeof opts.id !== "function") {
                idKey = opts.id;
                opts.id = function(e) {
                    return e[idKey];
                };
            }
            if ($.isArray(opts.element.data("select2Tags"))) {
                if ("tags" in opts) {
                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                }
                opts.tags = opts.element.data("select2Tags");
            }
            if (select) {
                opts.query = this.bind(function(query) {
                    var data = {
                        results: [],
                        more: false
                    }, term = query.term, children, placeholderOption, process;
                    process = function(element, collection) {
                        var group;
                        if (element.is("option")) {
                            if (query.matcher(term, element.text(), element)) {
                                collection.push(self.optionToData(element));
                            }
                        } else if (element.is("optgroup")) {
                            group = self.optionToData(element);
                            element.children().each2(function(i, elm) {
                                process(elm, group.children);
                            });
                            if (group.children.length > 0) {
                                collection.push(group);
                            }
                        }
                    };
                    children = element.children();
                    if (this.getPlaceholder() !== undefined && children.length > 0) {
                        placeholderOption = this.getPlaceholderOption();
                        if (placeholderOption) {
                            children = children.not(placeholderOption);
                        }
                    }
                    children.each2(function(i, elm) {
                        process(elm, data.results);
                    });
                    query.callback(data);
                });
                opts.id = function(e) {
                    return e.id;
                };
            } else {
                if (!("query" in opts)) {
                    if ("ajax" in opts) {
                        ajaxUrl = opts.element.data("ajax-url");
                        if (ajaxUrl && ajaxUrl.length > 0) {
                            opts.ajax.url = ajaxUrl;
                        }
                        opts.query = ajax.call(opts.element, opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        if (opts.createSearchChoice === undefined) {
                            opts.createSearchChoice = function(term) {
                                return {
                                    id: $.trim(term),
                                    text: $.trim(term)
                                };
                            };
                        }
                        if (opts.initSelection === undefined) {
                            opts.initSelection = function(element, callback) {
                                var data = [];
                                $(splitVal(element.val(), opts.separator)).each(function() {
                                    var obj = {
                                        id: this,
                                        text: this
                                    }, tags = opts.tags;
                                    if ($.isFunction(tags)) tags = tags();
                                    $(tags).each(function() {
                                        if (equal(this.id, obj.id)) {
                                            obj = this;
                                            return false;
                                        }
                                    });
                                    data.push(obj);
                                });
                                callback(data);
                            };
                        }
                    }
                }
            }
            if (typeof opts.query !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }
            if (opts.createSearchChoicePosition === "top") {
                opts.createSearchChoicePosition = function(list, item) {
                    list.unshift(item);
                };
            } else if (opts.createSearchChoicePosition === "bottom") {
                opts.createSearchChoicePosition = function(list, item) {
                    list.push(item);
                };
            } else if (typeof opts.createSearchChoicePosition !== "function") {
                throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
            }
            return opts;
        },
        monitorSource: function() {
            var el = this.opts.element, observer, self = this;
            el.on("change.select2", this.bind(function(e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));
            this._sync = this.bind(function() {
                var disabled = el.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);
                var readonly = el.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);
                syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                this.container.addClass(evaluate(this.opts.containerCssClass, this.opts.element));
                syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                this.dropdown.addClass(evaluate(this.opts.dropdownCssClass, this.opts.element));
            });
            if (el.length && el[0].attachEvent) {
                el.each(function() {
                    this.attachEvent("onpropertychange", self._sync);
                });
            }
            observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
            if (observer !== undefined) {
                if (this.propertyObserver) {
                    delete this.propertyObserver;
                    this.propertyObserver = null;
                }
                this.propertyObserver = new observer(function(mutations) {
                    $.each(mutations, self._sync);
                });
                this.propertyObserver.observe(el.get(0), {
                    attributes: true,
                    subtree: false
                });
            }
        },
        triggerSelect: function(data) {
            var evt = $.Event("select2-selecting", {
                val: this.id(data),
                object: data,
                choice: data
            });
            this.opts.element.trigger(evt);
            return !evt.isDefaultPrevented();
        },
        triggerChange: function(details) {
            details = details || {};
            details = $.extend({}, details, {
                type: "change",
                val: this.val()
            });
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger(details);
            this.opts.element.data("select2-change-triggered", false);
            this.opts.element.click();
            if (this.opts.blurOnChange) this.opts.element.blur();
        },
        isInterfaceEnabled: function() {
            return this.enabledInterface === true;
        },
        enableInterface: function() {
            var enabled = this._enabled && !this._readonly, disabled = !enabled;
            if (enabled === this.enabledInterface) return false;
            this.container.toggleClass("select2-container-disabled", disabled);
            this.close();
            this.enabledInterface = enabled;
            return true;
        },
        enable: function(enabled) {
            if (enabled === undefined) enabled = true;
            if (this._enabled === enabled) return;
            this._enabled = enabled;
            this.opts.element.prop("disabled", !enabled);
            this.enableInterface();
        },
        disable: function() {
            this.enable(false);
        },
        readonly: function(enabled) {
            if (enabled === undefined) enabled = false;
            if (this._readonly === enabled) return;
            this._readonly = enabled;
            this.opts.element.prop("readonly", enabled);
            this.enableInterface();
        },
        opened: function() {
            return this.container ? this.container.hasClass("select2-dropdown-open") : false;
        },
        positionDropdown: function() {
            var $dropdown = this.dropdown, offset = this.container.offset(), height = this.container.outerHeight(false), width = this.container.outerWidth(false), dropHeight = $dropdown.outerHeight(false), $window = $(window), windowWidth = $window.width(), windowHeight = $window.height(), viewPortRight = $window.scrollLeft() + windowWidth, viewportBottom = $window.scrollTop() + windowHeight, dropTop = offset.top + height, dropLeft = offset.left, enoughRoomBelow = dropTop + dropHeight <= viewportBottom, enoughRoomAbove = offset.top - dropHeight >= $window.scrollTop(), dropWidth = $dropdown.outerWidth(false), enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight, aboveNow = $dropdown.hasClass("select2-drop-above"), bodyOffset, above, changeDirection, css, resultsListNode;
            if (aboveNow) {
                above = true;
                if (!enoughRoomAbove && enoughRoomBelow) {
                    changeDirection = true;
                    above = false;
                }
            } else {
                above = false;
                if (!enoughRoomBelow && enoughRoomAbove) {
                    changeDirection = true;
                    above = true;
                }
            }
            if (changeDirection) {
                $dropdown.hide();
                offset = this.container.offset();
                height = this.container.outerHeight(false);
                width = this.container.outerWidth(false);
                dropHeight = $dropdown.outerHeight(false);
                viewPortRight = $window.scrollLeft() + windowWidth;
                viewportBottom = $window.scrollTop() + windowHeight;
                dropTop = offset.top + height;
                dropLeft = offset.left;
                dropWidth = $dropdown.outerWidth(false);
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
                $dropdown.show();
                this.focusSearch();
            }
            if (this.opts.dropdownAutoWidth) {
                resultsListNode = $(".select2-results", $dropdown)[0];
                $dropdown.addClass("select2-drop-auto-width");
                $dropdown.css("width", "");
                dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                dropWidth > width ? width = dropWidth : dropWidth = width;
                dropHeight = $dropdown.outerHeight(false);
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
            } else {
                this.container.removeClass("select2-drop-auto-width");
            }
            if (this.body.css("position") !== "static") {
                bodyOffset = this.body.offset();
                dropTop -= bodyOffset.top;
                dropLeft -= bodyOffset.left;
            }
            if (!enoughRoomOnRight) {
                dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
            }
            css = {
                left: dropLeft,
                width: width
            };
            if (above) {
                css.top = offset.top - dropHeight;
                css.bottom = "auto";
                this.container.addClass("select2-drop-above");
                $dropdown.addClass("select2-drop-above");
            } else {
                css.top = dropTop;
                css.bottom = "auto";
                this.container.removeClass("select2-drop-above");
                $dropdown.removeClass("select2-drop-above");
            }
            css = $.extend(css, evaluate(this.opts.dropdownCss, this.opts.element));
            $dropdown.css(css);
        },
        shouldOpen: function() {
            var event;
            if (this.opened()) return false;
            if (this._enabled === false || this._readonly === true) return false;
            event = $.Event("select2-opening");
            this.opts.element.trigger(event);
            return !event.isDefaultPrevented();
        },
        clearDropdownAlignmentPreference: function() {
            this.container.removeClass("select2-drop-above");
            this.dropdown.removeClass("select2-drop-above");
        },
        open: function() {
            if (!this.shouldOpen()) return false;
            this.opening();
            $document.on("mousemove.select2Event", function(e) {
                lastMousePosition.x = e.pageX;
                lastMousePosition.y = e.pageY;
            });
            return true;
        },
        opening: function() {
            var cid = this.containerEventName, scroll = "scroll." + cid, resize = "resize." + cid, orient = "orientationchange." + cid, mask;
            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");
            this.clearDropdownAlignmentPreference();
            if (this.dropdown[0] !== this.body.children().last()[0]) {
                this.dropdown.detach().appendTo(this.body);
            }
            mask = $("#select2-drop-mask");
            if (mask.length == 0) {
                mask = $(document.createElement("div"));
                mask.attr("id", "select2-drop-mask").attr("class", "select2-drop-mask");
                mask.hide();
                mask.appendTo(this.body);
                mask.on("mousedown touchstart click", function(e) {
                    reinsertElement(mask);
                    var dropdown = $("#select2-drop"), self;
                    if (dropdown.length > 0) {
                        self = dropdown.data("select2");
                        if (self.opts.selectOnBlur) {
                            self.selectHighlighted({
                                noFocus: true
                            });
                        }
                        self.close();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }
            if (this.dropdown.prev()[0] !== mask[0]) {
                this.dropdown.before(mask);
            }
            $("#select2-drop").removeAttr("id");
            this.dropdown.attr("id", "select2-drop");
            mask.show();
            this.positionDropdown();
            this.dropdown.show();
            this.positionDropdown();
            this.dropdown.addClass("select2-drop-active");
            var that = this;
            this.container.parents().add(window).each(function() {
                $(this).on(resize + " " + scroll + " " + orient, function(e) {
                    if (that.opened()) that.positionDropdown();
                });
            });
        },
        close: function() {
            if (!this.opened()) return;
            var cid = this.containerEventName, scroll = "scroll." + cid, resize = "resize." + cid, orient = "orientationchange." + cid;
            this.container.parents().add(window).each(function() {
                $(this).off(scroll).off(resize).off(orient);
            });
            this.clearDropdownAlignmentPreference();
            $("#select2-drop-mask").hide();
            this.dropdown.removeAttr("id");
            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
            this.results.empty();
            $document.off("mousemove.select2Event");
            this.clearSearch();
            this.search.removeClass("select2-active");
            this.opts.element.trigger($.Event("select2-close"));
        },
        externalSearch: function(term) {
            this.open();
            this.search.val(term);
            this.updateResults(false);
        },
        clearSearch: function() {},
        getMaximumSelectionSize: function() {
            return evaluate(this.opts.maximumSelectionSize, this.opts.element);
        },
        ensureHighlightVisible: function() {
            var results = this.results, children, index, child, hb, rb, y, more, topOffset;
            index = this.highlight();
            if (index < 0) return;
            if (index == 0) {
                results.scrollTop(0);
                return;
            }
            children = this.findHighlightableChoices().find(".select2-result-label");
            child = $(children[index]);
            topOffset = (child.offset() || {}).top || 0;
            hb = topOffset + child.outerHeight(true);
            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight(true);
                }
            }
            rb = results.offset().top + results.outerHeight(true);
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = topOffset - results.offset().top;
            if (y < 0 && child.css("display") != "none") {
                results.scrollTop(results.scrollTop() + y);
            }
        },
        findHighlightableChoices: function() {
            return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
        },
        moveHighlight: function(delta) {
            var choices = this.findHighlightableChoices(), index = this.highlight();
            while (index > -1 && index < choices.length) {
                index += delta;
                var choice = $(choices[index]);
                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                    this.highlight(index);
                    break;
                }
            }
        },
        highlight: function(index) {
            var choices = this.findHighlightableChoices(), choice, data;
            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }
            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;
            this.removeHighlight();
            choice = $(choices[index]);
            choice.addClass("select2-highlighted");
            this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));
            this.ensureHighlightVisible();
            this.liveRegion.text(choice.text());
            data = choice.data("select2-data");
            if (data) {
                this.opts.element.trigger({
                    type: "select2-highlight",
                    val: this.id(data),
                    choice: data
                });
            }
        },
        removeHighlight: function() {
            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
        },
        touchMoved: function() {
            this._touchMoved = true;
        },
        clearTouchMoved: function() {
            this._touchMoved = false;
        },
        countSelectableResults: function() {
            return this.findHighlightableChoices().length;
        },
        highlightUnderEvent: function(event) {
            var el = $(event.target).closest(".select2-result-selectable");
            if (el.length > 0 && !el.is(".select2-highlighted")) {
                var choices = this.findHighlightableChoices();
                this.highlight(choices.index(el));
            } else if (el.length == 0) {
                this.removeHighlight();
            }
        },
        loadMoreIfNeeded: function() {
            var results = this.results, more = results.find("li.select2-more-results"), below, page = this.resultsPage + 1, self = this, term = this.search.val(), context = this.context;
            if (more.length === 0) return;
            below = more.offset().top - results.offset().top - results.height();
            if (below <= this.opts.loadMorePadding) {
                more.addClass("select2-active");
                this.opts.query({
                    element: this.opts.element,
                    term: term,
                    page: page,
                    context: context,
                    matcher: this.opts.matcher,
                    callback: this.bind(function(data) {
                        if (!self.opened()) return;
                        self.opts.populateResults.call(this, results, data.results, {
                            term: term,
                            page: page,
                            context: context
                        });
                        self.postprocessResults(data, false, false);
                        if (data.more === true) {
                            more.detach().appendTo(results).text(evaluate(self.opts.formatLoadMore, self.opts.element, page + 1));
                            window.setTimeout(function() {
                                self.loadMoreIfNeeded();
                            }, 10);
                        } else {
                            more.remove();
                        }
                        self.positionDropdown();
                        self.resultsPage = page;
                        self.context = data.context;
                        this.opts.element.trigger({
                            type: "select2-loaded",
                            items: data
                        });
                    })
                });
            }
        },
        tokenize: function() {},
        updateResults: function(initial) {
            var search = this.search, results = this.results, opts = this.opts, data, self = this, input, term = search.val(), lastTerm = $.data(this.container, "select2-last-term"), queryNumber;
            if (initial !== true && lastTerm && equal(term, lastTerm)) return;
            $.data(this.container, "select2-last-term", term);
            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                return;
            }
            function postRender() {
                search.removeClass("select2-active");
                self.positionDropdown();
                if (results.find(".select2-no-results,.select2-selection-limit,.select2-searching").length) {
                    self.liveRegion.text(results.text());
                } else {
                    self.liveRegion.text(self.opts.formatMatches(results.find(".select2-result-selectable").length));
                }
            }
            function render(html) {
                results.html(html);
                postRender();
            }
            queryNumber = ++this.queryCount;
            var maxSelSize = this.getMaximumSelectionSize();
            if (maxSelSize >= 1) {
                data = this.data();
                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                    render("<li class='select2-selection-limit'>" + evaluate(opts.formatSelectionTooBig, opts.element, maxSelSize) + "</li>");
                    return;
                }
            }
            if (search.val().length < opts.minimumInputLength) {
                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooShort, opts.element, search.val(), opts.minimumInputLength) + "</li>");
                } else {
                    render("");
                }
                if (initial && this.showSearch) this.showSearch(true);
                return;
            }
            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooLong, opts.element, search.val(), opts.maximumInputLength) + "</li>");
                } else {
                    render("");
                }
                return;
            }
            if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                render("<li class='select2-searching'>" + evaluate(opts.formatSearching, opts.element) + "</li>");
            }
            search.addClass("select2-active");
            this.removeHighlight();
            input = this.tokenize();
            if (input != undefined && input != null) {
                search.val(input);
            }
            this.resultsPage = 1;
            opts.query({
                element: opts.element,
                term: search.val(),
                page: this.resultsPage,
                context: null,
                matcher: opts.matcher,
                callback: this.bind(function(data) {
                    var def;
                    if (queryNumber != this.queryCount) {
                        return;
                    }
                    if (!this.opened()) {
                        this.search.removeClass("select2-active");
                        return;
                    }
                    this.context = data.context === undefined ? null : data.context;
                    if (this.opts.createSearchChoice && search.val() !== "") {
                        def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                        if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                            if ($(data.results).filter(function() {
                                return equal(self.id(this), self.id(def));
                            }).length === 0) {
                                this.opts.createSearchChoicePosition(data.results, def);
                            }
                        }
                    }
                    if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                        render("<li class='select2-no-results'>" + evaluate(opts.formatNoMatches, opts.element, search.val()) + "</li>");
                        return;
                    }
                    results.empty();
                    self.opts.populateResults.call(this, results, data.results, {
                        term: search.val(),
                        page: this.resultsPage,
                        context: null
                    });
                    if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                        results.append("<li class='select2-more-results'>" + opts.escapeMarkup(evaluate(opts.formatLoadMore, opts.element, this.resultsPage)) + "</li>");
                        window.setTimeout(function() {
                            self.loadMoreIfNeeded();
                        }, 10);
                    }
                    this.postprocessResults(data, initial);
                    postRender();
                    this.opts.element.trigger({
                        type: "select2-loaded",
                        items: data
                    });
                })
            });
        },
        cancel: function() {
            this.close();
        },
        blur: function() {
            if (this.opts.selectOnBlur) this.selectHighlighted({
                noFocus: true
            });
            this.close();
            this.container.removeClass("select2-container-active");
            if (this.search[0] === document.activeElement) {
                this.search.blur();
            }
            this.clearSearch();
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
        },
        focusSearch: function() {
            focus(this.search);
        },
        selectHighlighted: function(options) {
            if (this._touchMoved) {
                this.clearTouchMoved();
                return;
            }
            var index = this.highlight(), highlighted = this.results.find(".select2-highlighted"), data = highlighted.closest(".select2-result").data("select2-data");
            if (data) {
                this.highlight(index);
                this.onSelect(data, options);
            } else if (options && options.noFocus) {
                this.close();
            }
        },
        getPlaceholder: function() {
            var placeholderOption;
            return this.opts.element.attr("placeholder") || this.opts.element.attr("data-placeholder") || this.opts.element.data("placeholder") || this.opts.placeholder || ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
        },
        getPlaceholderOption: function() {
            if (this.select) {
                var firstOption = this.select.children("option").first();
                if (this.opts.placeholderOption !== undefined) {
                    return this.opts.placeholderOption === "first" && firstOption || typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select);
                } else if ($.trim(firstOption.text()) === "" && firstOption.val() === "") {
                    return firstOption;
                }
            }
        },
        initContainerWidth: function() {
            function resolveContainerWidth() {
                var style, attrs, matches, i, l, attr;
                if (this.opts.width === "off") {
                    return null;
                } else if (this.opts.width === "element") {
                    return this.opts.element.outerWidth(false) === 0 ? "auto" : this.opts.element.outerWidth(false) + "px";
                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                    style = this.opts.element.attr("style");
                    if (style !== undefined) {
                        attrs = style.split(";");
                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
                            attr = attrs[i].replace(/\s/g, "");
                            matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                            if (matches !== null && matches.length >= 1) return matches[1];
                        }
                    }
                    if (this.opts.width === "resolve") {
                        style = this.opts.element.css("width");
                        if (style.indexOf("%") > 0) return style;
                        return this.opts.element.outerWidth(false) === 0 ? "auto" : this.opts.element.outerWidth(false) + "px";
                    }
                    return null;
                } else if ($.isFunction(this.opts.width)) {
                    return this.opts.width();
                } else {
                    return this.opts.width;
                }
            }
            var width = resolveContainerWidth.call(this);
            if (width !== null) {
                this.container.css("width", width);
            }
        }
    });
    SingleSelect2 = clazz(AbstractSelect2, {
        createContainer: function() {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container"
            }).html([ "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>", "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>", "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>", "</a>", "<label for='' class='select2-offscreen'></label>", "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />", "<div class='select2-drop select2-display-none'>", "   <div class='select2-search'>", "       <label for='' class='select2-offscreen'></label>", "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'", "       aria-autocomplete='list' />", "   </div>", "   <ul class='select2-results' role='listbox'>", "   </ul>", "</div>" ].join(""));
            return container;
        },
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.focusser.prop("disabled", !this.isInterfaceEnabled());
            }
        },
        opening: function() {
            var el, range, len;
            if (this.opts.minimumResultsForSearch >= 0) {
                this.showSearch(true);
            }
            this.parent.opening.apply(this, arguments);
            if (this.showSearchInput !== false) {
                this.search.val(this.focusser.val());
            }
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
                el = this.search.get(0);
                if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                } else if (el.setSelectionRange) {
                    len = this.search.val().length;
                    el.setSelectionRange(len, len);
                }
            }
            if (this.search.val() === "") {
                if (this.nextSearchTerm != undefined) {
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }
            this.focusser.prop("disabled", true).val("");
            this.updateResults(true);
            this.opts.element.trigger($.Event("select2-open"));
        },
        close: function() {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
            this.focusser.prop("disabled", false);
            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },
        focus: function() {
            if (this.opened()) {
                this.close();
            } else {
                this.focusser.prop("disabled", false);
                if (this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }
            }
        },
        isFocused: function() {
            return this.container.hasClass("select2-container-active");
        },
        cancel: function() {
            this.parent.cancel.apply(this, arguments);
            this.focusser.prop("disabled", false);
            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },
        destroy: function() {
            $("label[for='" + this.focusser.attr("id") + "']").attr("for", this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);
            cleanupJQueryElements.call(this, "selection", "focusser");
        },
        initContainer: function() {
            var selection, container = this.container, dropdown = this.dropdown, idSuffix = nextUid(), elementLabel;
            if (this.opts.minimumResultsForSearch < 0) {
                this.showSearch(false);
            } else {
                this.showSearch(true);
            }
            this.selection = selection = container.find(".select2-choice");
            this.focusser = container.find(".select2-focusser");
            selection.find(".select2-chosen").attr("id", "select2-chosen-" + idSuffix);
            this.focusser.attr("aria-labelledby", "select2-chosen-" + idSuffix);
            this.results.attr("id", "select2-results-" + idSuffix);
            this.search.attr("aria-owns", "select2-results-" + idSuffix);
            this.focusser.attr("id", "s2id_autogen" + idSuffix);
            elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
            this.focusser.prev().text(elementLabel.text()).attr("for", this.focusser.attr("id"));
            var originalTitle = this.opts.element.attr("title");
            this.opts.element.attr("title", originalTitle || elementLabel.text());
            this.focusser.attr("tabindex", this.elementTabIndex);
            this.search.attr("id", this.focusser.attr("id") + "_search");
            this.search.prev().text($("label[for='" + this.focusser.attr("id") + "']").text()).attr("for", this.search.attr("id"));
            this.search.on("keydown", this.bind(function(e) {
                if (!this.isInterfaceEnabled()) return;
                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    killEvent(e);
                    return;
                }
                switch (e.which) {
                  case KEY.UP:
                  case KEY.DOWN:
                    this.moveHighlight(e.which === KEY.UP ? -1 : 1);
                    killEvent(e);
                    return;

                  case KEY.ENTER:
                    this.selectHighlighted();
                    killEvent(e);
                    return;

                  case KEY.TAB:
                    this.selectHighlighted({
                        noFocus: true
                    });
                    return;

                  case KEY.ESC:
                    this.cancel(e);
                    killEvent(e);
                    return;
                }
            }));
            this.search.on("blur", this.bind(function(e) {
                if (document.activeElement === this.body.get(0)) {
                    window.setTimeout(this.bind(function() {
                        if (this.opened()) {
                            this.search.focus();
                        }
                    }), 0);
                }
            }));
            this.focusser.on("keydown", this.bind(function(e) {
                if (!this.isInterfaceEnabled()) return;
                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }
                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                    killEvent(e);
                    return;
                }
                if (e.which == KEY.DOWN || e.which == KEY.UP || e.which == KEY.ENTER && this.opts.openOnEnter) {
                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;
                    this.open();
                    killEvent(e);
                    return;
                }
                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                    if (this.opts.allowClear) {
                        this.clear();
                    }
                    killEvent(e);
                    return;
                }
            }));
            installKeyUpChangeEvent(this.focusser);
            this.focusser.on("keyup-change input", this.bind(function(e) {
                if (this.opts.minimumResultsForSearch >= 0) {
                    e.stopPropagation();
                    if (this.opened()) return;
                    this.open();
                }
            }));
            selection.on("mousedown touchstart", "abbr", this.bind(function(e) {
                if (!this.isInterfaceEnabled()) return;
                this.clear();
                killEventImmediately(e);
                this.close();
                this.selection.focus();
            }));
            selection.on("mousedown touchstart", this.bind(function(e) {
                reinsertElement(selection);
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                if (this.opened()) {
                    this.close();
                } else if (this.isInterfaceEnabled()) {
                    this.open();
                }
                killEvent(e);
            }));
            dropdown.on("mousedown touchstart", this.bind(function() {
                if (this.opts.shouldFocusInput(this)) {
                    this.search.focus();
                }
            }));
            selection.on("focus", this.bind(function(e) {
                killEvent(e);
            }));
            this.focusser.on("focus", this.bind(function() {
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            })).on("blur", this.bind(function() {
                if (!this.opened()) {
                    this.container.removeClass("select2-container-active");
                    this.opts.element.trigger($.Event("select2-blur"));
                }
            }));
            this.search.on("focus", this.bind(function() {
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            }));
            this.initContainerWidth();
            this.opts.element.addClass("select2-offscreen");
            this.setPlaceholder();
        },
        clear: function(triggerChange) {
            var data = this.selection.data("select2-data");
            if (data) {
                var evt = $.Event("select2-clearing");
                this.opts.element.trigger(evt);
                if (evt.isDefaultPrevented()) {
                    return;
                }
                var placeholderOption = this.getPlaceholderOption();
                this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                this.selection.find(".select2-chosen").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder();
                if (triggerChange !== false) {
                    this.opts.element.trigger({
                        type: "select2-removed",
                        val: this.id(data),
                        choice: data
                    });
                    this.triggerChange({
                        removed: data
                    });
                }
            }
        },
        initSelection: function() {
            var selected;
            if (this.isPlaceholderOptionSelected()) {
                this.updateSelection(null);
                this.close();
                this.setPlaceholder();
            } else {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(selected) {
                    if (selected !== undefined && selected !== null) {
                        self.updateSelection(selected);
                        self.close();
                        self.setPlaceholder();
                        self.nextSearchTerm = self.opts.nextSearchTerm(selected, self.search.val());
                    }
                });
            }
        },
        isPlaceholderOptionSelected: function() {
            var placeholderOption;
            if (this.getPlaceholder() === undefined) return false;
            return (placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected") || this.opts.element.val() === "" || this.opts.element.val() === undefined || this.opts.element.val() === null;
        },
        prepareOpts: function() {
            var opts = this.parent.prepareOpts.apply(this, arguments), self = this;
            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                opts.initSelection = function(element, callback) {
                    var selected = element.find("option").filter(function() {
                        return this.selected && !this.disabled;
                    });
                    callback(self.optionToData(selected));
                };
            } else if ("data" in opts) {
                opts.initSelection = opts.initSelection || function(element, callback) {
                    var id = element.val();
                    var match = null;
                    opts.query({
                        matcher: function(term, text, el) {
                            var is_match = equal(id, opts.id(el));
                            if (is_match) {
                                match = el;
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            callback(match);
                        }
                    });
                };
            }
            return opts;
        },
        getPlaceholder: function() {
            if (this.select) {
                if (this.getPlaceholderOption() === undefined) {
                    return undefined;
                }
            }
            return this.parent.getPlaceholder.apply(this, arguments);
        },
        setPlaceholder: function() {
            var placeholder = this.getPlaceholder();
            if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {
                if (this.select && this.getPlaceholderOption() === undefined) return;
                this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));
                this.selection.addClass("select2-default");
                this.container.removeClass("select2-allowclear");
            }
        },
        postprocessResults: function(data, initial, noHighlightUpdate) {
            var selected = 0, self = this, showSearchInput = true;
            this.findHighlightableChoices().each2(function(i, elm) {
                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });
            if (noHighlightUpdate !== false) {
                if (initial === true && selected >= 0) {
                    this.highlight(selected);
                } else {
                    this.highlight(0);
                }
            }
            if (initial === true) {
                var min = this.opts.minimumResultsForSearch;
                if (min >= 0) {
                    this.showSearch(countResults(data.results) >= min);
                }
            }
        },
        showSearch: function(showSearchInput) {
            if (this.showSearchInput === showSearchInput) return;
            this.showSearchInput = showSearchInput;
            this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
            this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
            $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
        },
        onSelect: function(data, options) {
            if (!this.triggerSelect(data)) {
                return;
            }
            var old = this.opts.element.val(), oldData = this.data();
            this.opts.element.val(this.id(data));
            this.updateSelection(data);
            this.opts.element.trigger({
                type: "select2-selected",
                val: this.id(data),
                choice: data
            });
            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
            this.close();
            if ((!options || !options.noFocus) && this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
            if (!equal(old, this.id(data))) {
                this.triggerChange({
                    added: data,
                    removed: oldData
                });
            }
        },
        updateSelection: function(data) {
            var container = this.selection.find(".select2-chosen"), formatted, cssClass;
            this.selection.data("select2-data", data);
            container.empty();
            if (data !== null) {
                formatted = this.opts.formatSelection(data, container, this.opts.escapeMarkup);
            }
            if (formatted !== undefined) {
                container.append(formatted);
            }
            cssClass = this.opts.formatSelectionCssClass(data, container);
            if (cssClass !== undefined) {
                container.addClass(cssClass);
            }
            this.selection.removeClass("select2-default");
            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.container.addClass("select2-allowclear");
            }
        },
        val: function() {
            var val, triggerChange = false, data = null, self = this, oldData = this.data();
            if (arguments.length === 0) {
                return this.opts.element.val();
            }
            val = arguments[0];
            if (arguments.length > 1) {
                triggerChange = arguments[1];
            }
            if (this.select) {
                this.select.val(val).find("option").filter(function() {
                    return this.selected;
                }).each2(function(i, elm) {
                    data = self.optionToData(elm);
                    return false;
                });
                this.updateSelection(data);
                this.setPlaceholder();
                if (triggerChange) {
                    this.triggerChange({
                        added: data,
                        removed: oldData
                    });
                }
            } else {
                if (!val && val !== 0) {
                    this.clear(triggerChange);
                    return;
                }
                if (this.opts.initSelection === undefined) {
                    throw new Error("cannot call val() if initSelection() is not defined");
                }
                this.opts.element.val(val);
                this.opts.initSelection(this.opts.element, function(data) {
                    self.opts.element.val(!data ? "" : self.id(data));
                    self.updateSelection(data);
                    self.setPlaceholder();
                    if (triggerChange) {
                        self.triggerChange({
                            added: data,
                            removed: oldData
                        });
                    }
                });
            }
        },
        clearSearch: function() {
            this.search.val("");
            this.focusser.val("");
        },
        data: function(value) {
            var data, triggerChange = false;
            if (arguments.length === 0) {
                data = this.selection.data("select2-data");
                if (data == undefined) data = null;
                return data;
            } else {
                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }
                if (!value) {
                    this.clear(triggerChange);
                } else {
                    data = this.data();
                    this.opts.element.val(!value ? "" : this.id(value));
                    this.updateSelection(value);
                    if (triggerChange) {
                        this.triggerChange({
                            added: value,
                            removed: data
                        });
                    }
                }
            }
        }
    });
    MultiSelect2 = clazz(AbstractSelect2, {
        createContainer: function() {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container select2-container-multi"
            }).html([ "<ul class='select2-choices'>", "  <li class='select2-search-field'>", "    <label for='' class='select2-offscreen'></label>", "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>", "  </li>", "</ul>", "<div class='select2-drop select2-drop-multi select2-display-none'>", "   <ul class='select2-results'>", "   </ul>", "</div>" ].join(""));
            return container;
        },
        prepareOpts: function() {
            var opts = this.parent.prepareOpts.apply(this, arguments), self = this;
            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                opts.initSelection = function(element, callback) {
                    var data = [];
                    element.find("option").filter(function() {
                        return this.selected && !this.disabled;
                    }).each2(function(i, elm) {
                        data.push(self.optionToData(elm));
                    });
                    callback(data);
                };
            } else if ("data" in opts) {
                opts.initSelection = opts.initSelection || function(element, callback) {
                    var ids = splitVal(element.val(), opts.separator);
                    var matches = [];
                    opts.query({
                        matcher: function(term, text, el) {
                            var is_match = $.grep(ids, function(id) {
                                return equal(id, opts.id(el));
                            }).length;
                            if (is_match) {
                                matches.push(el);
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            var ordered = [];
                            for (var i = 0; i < ids.length; i++) {
                                var id = ids[i];
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    if (equal(id, opts.id(match))) {
                                        ordered.push(match);
                                        matches.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                            callback(ordered);
                        }
                    });
                };
            }
            return opts;
        },
        selectChoice: function(choice) {
            var selected = this.container.find(".select2-search-choice-focus");
            if (selected.length && choice && choice[0] == selected[0]) {} else {
                if (selected.length) {
                    this.opts.element.trigger("choice-deselected", selected);
                }
                selected.removeClass("select2-search-choice-focus");
                if (choice && choice.length) {
                    this.close();
                    choice.addClass("select2-search-choice-focus");
                    this.opts.element.trigger("choice-selected", choice);
                }
            }
        },
        destroy: function() {
            $("label[for='" + this.search.attr("id") + "']").attr("for", this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);
            cleanupJQueryElements.call(this, "searchContainer", "selection");
        },
        initContainer: function() {
            var selector = ".select2-choices", selection;
            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);
            var _this = this;
            this.selection.on("click", ".select2-search-choice:not(.select2-locked)", function(e) {
                _this.search[0].focus();
                _this.selectChoice($(this));
            });
            this.search.attr("id", "s2id_autogen" + nextUid());
            this.search.prev().text($("label[for='" + this.opts.element.attr("id") + "']").text()).attr("for", this.search.attr("id"));
            this.search.on("input paste", this.bind(function() {
                if (this.search.attr("placeholder") && this.search.val().length == 0) return;
                if (!this.isInterfaceEnabled()) return;
                if (!this.opened()) {
                    this.open();
                }
            }));
            this.search.attr("tabindex", this.elementTabIndex);
            this.keydowns = 0;
            this.search.on("keydown", this.bind(function(e) {
                if (!this.isInterfaceEnabled()) return;
                ++this.keydowns;
                var selected = selection.find(".select2-search-choice-focus");
                var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                var next = selected.next(".select2-search-choice:not(.select2-locked)");
                var pos = getCursorInfo(this.search);
                if (selected.length && (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                    var selectedChoice = selected;
                    if (e.which == KEY.LEFT && prev.length) {
                        selectedChoice = prev;
                    } else if (e.which == KEY.RIGHT) {
                        selectedChoice = next.length ? next : null;
                    } else if (e.which === KEY.BACKSPACE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = prev.length ? prev : next;
                        }
                    } else if (e.which == KEY.DELETE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = next.length ? next : null;
                        }
                    } else if (e.which == KEY.ENTER) {
                        selectedChoice = null;
                    }
                    this.selectChoice(selectedChoice);
                    killEvent(e);
                    if (!selectedChoice || !selectedChoice.length) {
                        this.open();
                    }
                    return;
                } else if ((e.which === KEY.BACKSPACE && this.keydowns == 1 || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {
                    this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                    killEvent(e);
                    return;
                } else {
                    this.selectChoice(null);
                }
                if (this.opened()) {
                    switch (e.which) {
                      case KEY.UP:
                      case KEY.DOWN:
                        this.moveHighlight(e.which === KEY.UP ? -1 : 1);
                        killEvent(e);
                        return;

                      case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;

                      case KEY.TAB:
                        this.selectHighlighted({
                            noFocus: true
                        });
                        this.close();
                        return;

                      case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                    }
                }
                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }
                if (e.which === KEY.ENTER) {
                    if (this.opts.openOnEnter === false) {
                        return;
                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                }
                this.open();
                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    killEvent(e);
                }
                if (e.which === KEY.ENTER) {
                    killEvent(e);
                }
            }));
            this.search.on("keyup", this.bind(function(e) {
                this.keydowns = 0;
                this.resizeSearch();
            }));
            this.search.on("blur", this.bind(function(e) {
                this.container.removeClass("select2-container-active");
                this.search.removeClass("select2-focused");
                this.selectChoice(null);
                if (!this.opened()) this.clearSearch();
                e.stopImmediatePropagation();
                this.opts.element.trigger($.Event("select2-blur"));
            }));
            this.container.on("click", selector, this.bind(function(e) {
                if (!this.isInterfaceEnabled()) return;
                if ($(e.target).closest(".select2-search-choice").length > 0) {
                    return;
                }
                this.selectChoice(null);
                this.clearPlaceholder();
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));
            this.container.on("focus", selector, this.bind(function() {
                if (!this.isInterfaceEnabled()) return;
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
                this.dropdown.addClass("select2-drop-active");
                this.clearPlaceholder();
            }));
            this.initContainerWidth();
            this.opts.element.addClass("select2-offscreen");
            this.clearSearch();
        },
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.search.prop("disabled", !this.isInterfaceEnabled());
            }
        },
        initSelection: function() {
            var data;
            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                this.updateSelection([]);
                this.close();
                this.clearSearch();
            }
            if (this.select || this.opts.element.val() !== "") {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(data) {
                    if (data !== undefined && data !== null) {
                        self.updateSelection(data);
                        self.close();
                        self.clearSearch();
                    }
                });
            }
        },
        clearSearch: function() {
            var placeholder = this.getPlaceholder(), maxWidth = this.getMaxSearchWidth();
            if (placeholder !== undefined && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                this.search.val(placeholder).addClass("select2-default");
                this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
            } else {
                this.search.val("").width(10);
            }
        },
        clearPlaceholder: function() {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },
        opening: function() {
            this.clearPlaceholder();
            this.resizeSearch();
            this.parent.opening.apply(this, arguments);
            this.focusSearch();
            if (this.search.val() === "") {
                if (this.nextSearchTerm != undefined) {
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }
            this.updateResults(true);
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
            }
            this.opts.element.trigger($.Event("select2-open"));
        },
        close: function() {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },
        focus: function() {
            this.close();
            this.search.focus();
        },
        isFocused: function() {
            return this.search.hasClass("select2-focused");
        },
        updateSelection: function(data) {
            var ids = [], filtered = [], self = this;
            $(data).each(function() {
                if (indexOf(self.id(this), ids) < 0) {
                    ids.push(self.id(this));
                    filtered.push(this);
                }
            });
            data = filtered;
            this.selection.find(".select2-search-choice").remove();
            $(data).each(function() {
                self.addSelectedChoice(this);
            });
            self.postprocessResults();
        },
        tokenize: function() {
            var input = this.search.val();
            input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
            if (input != null && input != undefined) {
                this.search.val(input);
                if (input.length > 0) {
                    this.open();
                }
            }
        },
        onSelect: function(data, options) {
            if (!this.triggerSelect(data)) {
                return;
            }
            this.addSelectedChoice(data);
            this.opts.element.trigger({
                type: "selected",
                val: this.id(data),
                choice: data
            });
            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
            this.clearSearch();
            this.updateResults();
            if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect === true);
            if (this.opts.closeOnSelect) {
                this.close();
                this.search.width(10);
            } else {
                if (this.countSelectableResults() > 0) {
                    this.search.width(10);
                    this.resizeSearch();
                    if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                        this.updateResults(true);
                    } else {
                        if (this.nextSearchTerm != undefined) {
                            this.search.val(this.nextSearchTerm);
                            this.updateResults();
                            this.search.select();
                        }
                    }
                    this.positionDropdown();
                } else {
                    this.close();
                    this.search.width(10);
                }
            }
            this.triggerChange({
                added: data
            });
            if (!options || !options.noFocus) this.focusSearch();
        },
        cancel: function() {
            this.close();
            this.focusSearch();
        },
        addSelectedChoice: function(data) {
            var enableChoice = !data.locked, enabledItem = $("<li class='select2-search-choice'>" + "    <div></div>" + "    <a href='#' class='select2-search-choice-close' tabindex='-1'></a>" + "</li>"), disabledItem = $("<li class='select2-search-choice select2-locked'>" + "<div></div>" + "</li>");
            var choice = enableChoice ? enabledItem : disabledItem, id = this.id(data), val = this.getVal(), formatted, cssClass;
            formatted = this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
            if (formatted != undefined) {
                choice.find("div").replaceWith("<div>" + formatted + "</div>");
            }
            cssClass = this.opts.formatSelectionCssClass(data, choice.find("div"));
            if (cssClass != undefined) {
                choice.addClass(cssClass);
            }
            if (enableChoice) {
                choice.find(".select2-search-choice-close").on("mousedown", killEvent).on("click dblclick", this.bind(function(e) {
                    if (!this.isInterfaceEnabled()) return;
                    this.unselect($(e.target));
                    this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                    killEvent(e);
                    this.close();
                    this.focusSearch();
                })).on("focus", this.bind(function() {
                    if (!this.isInterfaceEnabled()) return;
                    this.container.addClass("select2-container-active");
                    this.dropdown.addClass("select2-drop-active");
                }));
            }
            choice.data("select2-data", data);
            choice.insertBefore(this.searchContainer);
            val.push(id);
            this.setVal(val);
        },
        unselect: function(selected) {
            var val = this.getVal(), data, index;
            selected = selected.closest(".select2-search-choice");
            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }
            data = selected.data("select2-data");
            if (!data) {
                return;
            }
            var evt = $.Event("select2-removing");
            evt.val = this.id(data);
            evt.choice = data;
            this.opts.element.trigger(evt);
            if (evt.isDefaultPrevented()) {
                return false;
            }
            while ((index = indexOf(this.id(data), val)) >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }
            selected.remove();
            this.opts.element.trigger({
                type: "select2-removed",
                val: this.id(data),
                choice: data
            });
            this.triggerChange({
                removed: data
            });
            return true;
        },
        postprocessResults: function(data, initial, noHighlightUpdate) {
            var val = this.getVal(), choices = this.results.find(".select2-result"), compound = this.results.find(".select2-result-with-children"), self = this;
            choices.each2(function(i, choice) {
                var id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-selected");
                    choice.find(".select2-result-selectable").addClass("select2-selected");
                }
            });
            compound.each2(function(i, choice) {
                if (!choice.is(".select2-result-selectable") && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                    choice.addClass("select2-selected");
                }
            });
            if (this.highlight() == -1 && noHighlightUpdate !== false) {
                self.highlight(0);
            }
            if (!this.opts.createSearchChoice && !choices.filter(".select2-result:not(.select2-selected)").length > 0) {
                if (!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                    if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                        this.results.append("<li class='select2-no-results'>" + evaluate(self.opts.formatNoMatches, self.opts.element, self.search.val()) + "</li>");
                    }
                }
            }
        },
        getMaxSearchWidth: function() {
            return this.selection.width() - getSideBorderPadding(this.search);
        },
        resizeSearch: function() {
            var minimumWidth, left, maxWidth, containerLeft, searchWidth, sideBorderPadding = getSideBorderPadding(this.search);
            minimumWidth = measureTextWidth(this.search) + 10;
            left = this.search.offset().left;
            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;
            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;
            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - sideBorderPadding;
            }
            if (searchWidth < 40) {
                searchWidth = maxWidth - sideBorderPadding;
            }
            if (searchWidth <= 0) {
                searchWidth = minimumWidth;
            }
            this.search.width(Math.floor(searchWidth));
        },
        getVal: function() {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, this.opts.separator);
            }
        },
        setVal: function(val) {
            var unique;
            if (this.select) {
                this.select.val(val);
            } else {
                unique = [];
                $(val).each(function() {
                    if (indexOf(this, unique) < 0) unique.push(this);
                });
                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
            }
        },
        buildChangeDetails: function(old, current) {
            var current = current.slice(0), old = old.slice(0);
            for (var i = 0; i < current.length; i++) {
                for (var j = 0; j < old.length; j++) {
                    if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                        current.splice(i, 1);
                        if (i > 0) {
                            i--;
                        }
                        old.splice(j, 1);
                        j--;
                    }
                }
            }
            return {
                added: current,
                removed: old
            };
        },
        val: function(val, triggerChange) {
            var oldData, self = this;
            if (arguments.length === 0) {
                return this.getVal();
            }
            oldData = this.data();
            if (!oldData.length) oldData = [];
            if (!val && val !== 0) {
                this.opts.element.val("");
                this.updateSelection([]);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange({
                        added: this.data(),
                        removed: oldData
                    });
                }
                return;
            }
            this.setVal(val);
            if (this.select) {
                this.opts.initSelection(this.select, this.bind(this.updateSelection));
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                }
            } else {
                if (this.opts.initSelection === undefined) {
                    throw new Error("val() cannot be called if initSelection() is not defined");
                }
                this.opts.initSelection(this.opts.element, function(data) {
                    var ids = $.map(data, self.id);
                    self.setVal(ids);
                    self.updateSelection(data);
                    self.clearSearch();
                    if (triggerChange) {
                        self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                    }
                });
            }
            this.clearSearch();
        },
        onSortStart: function() {
            if (this.select) {
                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
            }
            this.search.width(0);
            this.searchContainer.hide();
        },
        onSortEnd: function() {
            var val = [], self = this;
            this.searchContainer.show();
            this.searchContainer.appendTo(this.searchContainer.parent());
            this.resizeSearch();
            this.selection.find(".select2-search-choice").each(function() {
                val.push(self.opts.id($(this).data("select2-data")));
            });
            this.setVal(val);
            this.triggerChange();
        },
        data: function(values, triggerChange) {
            var self = this, ids, old;
            if (arguments.length === 0) {
                return this.selection.children(".select2-search-choice").map(function() {
                    return $(this).data("select2-data");
                }).get();
            } else {
                old = this.data();
                if (!values) {
                    values = [];
                }
                ids = $.map(values, function(e) {
                    return self.opts.id(e);
                });
                this.setVal(ids);
                this.updateSelection(values);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(old, this.data()));
                }
            }
        }
    });
    $.fn.select2 = function() {
        var args = Array.prototype.slice.call(arguments, 0), opts, select2, method, value, multiple, allowedMethods = [ "val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search" ], valueMethods = [ "opened", "isFocused", "container", "dropdown" ], propertyMethods = [ "val", "data" ], methodsMap = {
            search: "externalSearch"
        };
        this.each(function() {
            if (args.length === 0 || typeof args[0] === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);
                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.prop("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) {
                        opts.multiple = multiple = true;
                    }
                }
                select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
                select2.init(opts);
            } else if (typeof args[0] === "string") {
                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }
                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;
                method = args[0];
                if (method === "container") {
                    value = select2.container;
                } else if (method === "dropdown") {
                    value = select2.dropdown;
                } else {
                    if (methodsMap[method]) method = methodsMap[method];
                    value = select2[method].apply(select2, args.slice(1));
                }
                if (indexOf(args[0], valueMethods) >= 0 || indexOf(args[0], propertyMethods) >= 0 && args.length == 1) {
                    return false;
                }
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return value === undefined ? this : value;
    };
    $.fn.select2.defaults = {
        width: "copy",
        loadMorePadding: 0,
        closeOnSelect: true,
        openOnEnter: true,
        containerCss: {},
        dropdownCss: {},
        containerCssClass: "",
        dropdownCssClass: "",
        formatResult: function(result, container, query, escapeMarkup) {
            var markup = [];
            markMatch(result.text, query.term, markup, escapeMarkup);
            return markup.join("");
        },
        formatSelection: function(data, container, escapeMarkup) {
            return data ? escapeMarkup(data.text) : undefined;
        },
        sortResults: function(results, container, query) {
            return results;
        },
        formatResultCssClass: function(data) {
            return data.css;
        },
        formatSelectionCssClass: function(data, container) {
            return undefined;
        },
        formatMatches: function(matches) {
            if (matches === 1) {
                return "One result is available, press enter to select it.";
            }
            return matches + " results are available, use up and down arrow keys to navigate.";
        },
        formatNoMatches: function() {
            return "No matches found";
        },
        formatInputTooShort: function(input, min) {
            var n = min - input.length;
            return "Please enter " + n + " or more character" + (n == 1 ? "" : "s");
        },
        formatInputTooLong: function(input, max) {
            var n = input.length - max;
            return "Please delete " + n + " character" + (n == 1 ? "" : "s");
        },
        formatSelectionTooBig: function(limit) {
            return "You can only select " + limit + " item" + (limit == 1 ? "" : "s");
        },
        formatLoadMore: function(pageNumber) {
            return "Loading more results";
        },
        formatSearching: function() {
            return "Searching";
        },
        minimumResultsForSearch: 0,
        minimumInputLength: 0,
        maximumInputLength: null,
        maximumSelectionSize: 0,
        id: function(e) {
            return e == undefined ? null : e.id;
        },
        matcher: function(term, text) {
            return stripDiacritics("" + text).toUpperCase().indexOf(stripDiacritics("" + term).toUpperCase()) >= 0;
        },
        separator: ",",
        tokenSeparators: [],
        tokenizer: defaultTokenizer,
        escapeMarkup: defaultEscapeMarkup,
        blurOnChange: false,
        selectOnBlur: false,
        adaptContainerCssClass: function(c) {
            return c;
        },
        adaptDropdownCssClass: function(c) {
            return null;
        },
        nextSearchTerm: function(selectedObject, currentSearchTerm) {
            return undefined;
        },
        searchInputPlaceholder: "",
        createSearchChoicePosition: "top",
        shouldFocusInput: function(instance) {
            var supportsTouchEvents = "ontouchstart" in window || navigator.msMaxTouchPoints > 0;
            if (!supportsTouchEvents) {
                return true;
            }
            if (instance.opts.minimumResultsForSearch < 0) {
                return false;
            }
            return true;
        }
    };
    $.fn.select2.ajaxDefaults = {
        transport: $.ajax,
        params: {
            type: "GET",
            cache: false,
            dataType: "json"
        }
    };
    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        },
        util: {
            debounce: debounce,
            markMatch: markMatch,
            escapeMarkup: defaultEscapeMarkup,
            stripDiacritics: stripDiacritics
        },
        "class": {
            "abstract": AbstractSelect2,
            single: SingleSelect2,
            multi: MultiSelect2
        }
    };
})(jQuery);

(function($) {
    "use strict";
    $.extend($.fn.select2.defaults, {
        formatNoMatches: function() {
            return "Nenhum resultado encontrado";
        },
        formatInputTooShort: function(input, min) {
            var n = min - input.length;
            return "Informe ao menos mais " + n + " caractere" + (n == 1 ? "" : "s");
        },
        formatInputTooLong: function(input, max) {
            var n = input.length - max;
            return "Apague " + n + " caractere" + (n == 1 ? "" : "s");
        },
        formatSelectionTooBig: function(limit) {
            return "S  possvel selecionar " + limit + " elemento" + (limit == 1 ? "" : "s");
        },
        formatLoadMore: function(pageNumber) {
            return "Carregando mais resultados...";
        },
        formatSearching: function() {
            return "Buscando...";
        }
    });
})(jQuery);

(function($) {
    var tips = [], reBgImage = /^url\(["']?([^"'\)]*)["']?\);?$/i, rePNG = /\.png$/i, ie6 = !!window.createPopup && document.documentElement.currentStyle.minWidth == "undefined";
    function handleWindowResize() {
        $.each(tips, function() {
            this.refresh(true);
        });
    }
    $(window).resize(handleWindowResize);
    $.Poshytip = function(elm, options) {
        this.$elm = $(elm);
        this.opts = $.extend({}, $.fn.poshytip.defaults, options);
        this.$tip = $([ '<div class="', this.opts.className, '">', '<div class="tip-inner tip-bg-image"></div>', '<div class="tip-arrow tip-arrow-top tip-arrow-right tip-arrow-bottom tip-arrow-left"></div>', "</div>" ].join("")).appendTo(document.body);
        this.$arrow = this.$tip.find("div.tip-arrow");
        this.$inner = this.$tip.find("div.tip-inner");
        this.disabled = false;
        this.content = null;
        this.init();
    };
    $.Poshytip.prototype = {
        init: function() {
            tips.push(this);
            var title = this.$elm.attr("title");
            this.$elm.data("title.poshytip", title !== undefined ? title : null).data("poshytip", this);
            if (this.opts.showOn != "none") {
                this.$elm.bind({
                    "mouseenter.poshytip": $.proxy(this.mouseenter, this),
                    "mouseleave.poshytip": $.proxy(this.mouseleave, this)
                });
                switch (this.opts.showOn) {
                  case "hover":
                    if (this.opts.alignTo == "cursor") this.$elm.bind("mousemove.poshytip", $.proxy(this.mousemove, this));
                    if (this.opts.allowTipHover) this.$tip.hover($.proxy(this.clearTimeouts, this), $.proxy(this.mouseleave, this));
                    break;

                  case "focus":
                    this.$elm.bind({
                        "focus.poshytip": $.proxy(this.show, this),
                        "blur.poshytip": $.proxy(this.hide, this)
                    });
                    break;
                }
            }
        },
        mouseenter: function(e) {
            if (this.disabled) return true;
            this.$elm.attr("title", "");
            if (this.opts.showOn == "focus") return true;
            this.clearTimeouts();
            this.showTimeout = setTimeout($.proxy(this.show, this), this.opts.showTimeout);
        },
        mouseleave: function(e) {
            if (this.disabled || this.asyncAnimating && (this.$tip[0] === e.relatedTarget || jQuery.contains(this.$tip[0], e.relatedTarget))) return true;
            var title = this.$elm.data("title.poshytip");
            if (title !== null) this.$elm.attr("title", title);
            if (this.opts.showOn == "focus") return true;
            this.clearTimeouts();
            this.hideTimeout = setTimeout($.proxy(this.hide, this), this.opts.hideTimeout);
        },
        mousemove: function(e) {
            if (this.disabled) return true;
            this.eventX = e.pageX;
            this.eventY = e.pageY;
            if (this.opts.followCursor && this.$tip.data("active")) {
                this.calcPos();
                this.$tip.css({
                    left: this.pos.l,
                    top: this.pos.t
                });
                if (this.pos.arrow) this.$arrow[0].className = "tip-arrow tip-arrow-" + this.pos.arrow;
            }
        },
        show: function() {
            if (this.disabled || this.$tip.data("active")) return;
            this.reset();
            this.update();
            this.display();
            if (this.opts.timeOnScreen) {
                this.clearTimeouts();
                this.hideTimeout = setTimeout($.proxy(this.hide, this), this.opts.timeOnScreen);
            }
        },
        hide: function() {
            if (this.disabled || !this.$tip.data("active")) return;
            this.display(true);
        },
        reset: function() {
            this.$tip.queue([]).detach().css("visibility", "hidden").data("active", false);
            this.$inner.find("*").poshytip("hide");
            if (this.opts.fade) this.$tip.css("opacity", this.opacity);
            this.$arrow[0].className = "tip-arrow tip-arrow-top tip-arrow-right tip-arrow-bottom tip-arrow-left";
            this.asyncAnimating = false;
        },
        update: function(content, dontOverwriteOption) {
            if (this.disabled) return;
            var async = content !== undefined;
            if (async) {
                if (!dontOverwriteOption) this.opts.content = content;
                if (!this.$tip.data("active")) return;
            } else {
                content = this.opts.content;
            }
            var self = this, newContent = typeof content == "function" ? content.call(this.$elm[0], function(newContent) {
                self.update(newContent);
            }) : content == "[title]" ? this.$elm.data("title.poshytip") : content;
            if (this.content !== newContent) {
                this.$inner.empty().append(newContent);
                this.content = newContent;
            }
            this.refresh(async);
        },
        refresh: function(async) {
            if (this.disabled) return;
            if (async) {
                if (!this.$tip.data("active")) return;
                var currPos = {
                    left: this.$tip.css("left"),
                    top: this.$tip.css("top")
                };
            }
            this.$tip.css({
                left: 0,
                top: 0
            }).appendTo(document.body);
            if (this.opacity === undefined) this.opacity = this.$tip.css("opacity");
            var bgImage = this.$tip.css("background-image").match(reBgImage), arrow = this.$arrow.css("background-image").match(reBgImage);
            if (bgImage) {
                var bgImagePNG = rePNG.test(bgImage[1]);
                if (ie6 && bgImagePNG) {
                    this.$tip.css("background-image", "none");
                    this.$inner.css({
                        margin: 0,
                        border: 0,
                        padding: 0
                    });
                    bgImage = bgImagePNG = false;
                } else {
                    this.$tip.prepend('<table class="tip-table" border="0" cellpadding="0" cellspacing="0"><tr><td class="tip-top tip-bg-image" colspan="2"><span></span></td><td class="tip-right tip-bg-image" rowspan="2"><span></span></td></tr><tr><td class="tip-left tip-bg-image" rowspan="2"><span></span></td><td></td></tr><tr><td class="tip-bottom tip-bg-image" colspan="2"><span></span></td></tr></table>').css({
                        border: 0,
                        padding: 0,
                        "background-image": "none",
                        "background-color": "transparent"
                    }).find(".tip-bg-image").css("background-image", 'url("' + bgImage[1] + '")').end().find("td").eq(3).append(this.$inner);
                }
                if (bgImagePNG && !$.support.opacity) this.opts.fade = false;
            }
            if (arrow && !$.support.opacity) {
                if (ie6 && rePNG.test(arrow[1])) {
                    arrow = false;
                    this.$arrow.css("background-image", "none");
                }
                this.opts.fade = false;
            }
            var $table = this.$tip.find("> table.tip-table");
            if (ie6) {
                this.$tip[0].style.width = "";
                $table.width("auto").find("td").eq(3).width("auto");
                var tipW = this.$tip.width(), minW = parseInt(this.$tip.css("min-width")), maxW = parseInt(this.$tip.css("max-width"));
                if (!isNaN(minW) && tipW < minW) tipW = minW; else if (!isNaN(maxW) && tipW > maxW) tipW = maxW;
                this.$tip.add($table).width(tipW).eq(0).find("td").eq(3).width("100%");
            } else if ($table[0]) {
                $table.width("auto").find("td").eq(3).width("auto").end().end().width(document.defaultView && document.defaultView.getComputedStyle && parseFloat(document.defaultView.getComputedStyle(this.$tip[0], null).width) || this.$tip.width()).find("td").eq(3).width("100%");
            }
            this.tipOuterW = this.$tip.outerWidth();
            this.tipOuterH = this.$tip.outerHeight();
            this.calcPos();
            if (arrow && this.pos.arrow) {
                this.$arrow[0].className = "tip-arrow tip-arrow-" + this.pos.arrow;
                this.$arrow.css("visibility", "inherit");
            }
            if (async && this.opts.refreshAniDuration) {
                this.asyncAnimating = true;
                var self = this;
                this.$tip.css(currPos).animate({
                    left: this.pos.l,
                    top: this.pos.t
                }, this.opts.refreshAniDuration, function() {
                    self.asyncAnimating = false;
                });
            } else {
                this.$tip.css({
                    left: this.pos.l,
                    top: this.pos.t
                });
            }
        },
        display: function(hide) {
            var active = this.$tip.data("active");
            if (active && !hide || !active && hide) return;
            this.$tip.stop();
            if ((this.opts.slide && this.pos.arrow || this.opts.fade) && (hide && this.opts.hideAniDuration || !hide && this.opts.showAniDuration)) {
                var from = {}, to = {};
                if (this.opts.slide && this.pos.arrow) {
                    var prop, arr;
                    if (this.pos.arrow == "bottom" || this.pos.arrow == "top") {
                        prop = "top";
                        arr = "bottom";
                    } else {
                        prop = "left";
                        arr = "right";
                    }
                    var val = parseInt(this.$tip.css(prop));
                    from[prop] = val + (hide ? 0 : this.pos.arrow == arr ? -this.opts.slideOffset : this.opts.slideOffset);
                    to[prop] = val + (hide ? this.pos.arrow == arr ? this.opts.slideOffset : -this.opts.slideOffset : 0) + "px";
                }
                if (this.opts.fade) {
                    from.opacity = hide ? this.$tip.css("opacity") : 0;
                    to.opacity = hide ? 0 : this.opacity;
                }
                this.$tip.css(from).animate(to, this.opts[hide ? "hideAniDuration" : "showAniDuration"]);
            }
            hide ? this.$tip.queue($.proxy(this.reset, this)) : this.$tip.css("visibility", "inherit");
            this.$tip.data("active", !active);
        },
        disable: function() {
            this.reset();
            this.disabled = true;
        },
        enable: function() {
            this.disabled = false;
        },
        destroy: function() {
            this.reset();
            this.$tip.remove();
            delete this.$tip;
            this.content = null;
            this.$elm.unbind(".poshytip").removeData("title.poshytip").removeData("poshytip");
            tips.splice($.inArray(this, tips), 1);
        },
        clearTimeouts: function() {
            if (this.showTimeout) {
                clearTimeout(this.showTimeout);
                this.showTimeout = 0;
            }
            if (this.hideTimeout) {
                clearTimeout(this.hideTimeout);
                this.hideTimeout = 0;
            }
        },
        calcPos: function() {
            var pos = {
                l: 0,
                t: 0,
                arrow: ""
            }, $win = $(window), win = {
                l: $win.scrollLeft(),
                t: $win.scrollTop(),
                w: $win.width(),
                h: $win.height()
            }, xL, xC, xR, yT, yC, yB;
            if (this.opts.alignTo == "cursor") {
                xL = xC = xR = this.eventX;
                yT = yC = yB = this.eventY;
            } else {
                var elmOffset = this.$elm.offset(), elm = {
                    l: elmOffset.left,
                    t: elmOffset.top,
                    w: this.$elm.outerWidth(),
                    h: this.$elm.outerHeight()
                };
                xL = elm.l + (this.opts.alignX != "inner-right" ? 0 : elm.w);
                xC = xL + Math.floor(elm.w / 2);
                xR = xL + (this.opts.alignX != "inner-left" ? elm.w : 0);
                yT = elm.t + (this.opts.alignY != "inner-bottom" ? 0 : elm.h);
                yC = yT + Math.floor(elm.h / 2);
                yB = yT + (this.opts.alignY != "inner-top" ? elm.h : 0);
            }
            switch (this.opts.alignX) {
              case "right":
              case "inner-left":
                pos.l = xR + this.opts.offsetX;
                if (pos.l + this.tipOuterW > win.l + win.w) pos.l = win.l + win.w - this.tipOuterW;
                if (this.opts.alignX == "right" || this.opts.alignY == "center") pos.arrow = "left";
                break;

              case "center":
                pos.l = xC - Math.floor(this.tipOuterW / 2);
                if (pos.l + this.tipOuterW > win.l + win.w) pos.l = win.l + win.w - this.tipOuterW; else if (pos.l < win.l) pos.l = win.l;
                break;

              default:
                pos.l = xL - this.tipOuterW - this.opts.offsetX;
                if (pos.l < win.l) pos.l = win.l;
                if (this.opts.alignX == "left" || this.opts.alignY == "center") pos.arrow = "right";
            }
            switch (this.opts.alignY) {
              case "bottom":
              case "inner-top":
                pos.t = yB + this.opts.offsetY;
                if (!pos.arrow || this.opts.alignTo == "cursor") pos.arrow = "top";
                if (pos.t + this.tipOuterH > win.t + win.h) {
                    pos.t = yT - this.tipOuterH - this.opts.offsetY;
                    if (pos.arrow == "top") pos.arrow = "bottom";
                }
                break;

              case "center":
                pos.t = yC - Math.floor(this.tipOuterH / 2);
                if (pos.t + this.tipOuterH > win.t + win.h) pos.t = win.t + win.h - this.tipOuterH; else if (pos.t < win.t) pos.t = win.t;
                break;

              default:
                pos.t = yT - this.tipOuterH - this.opts.offsetY;
                if (!pos.arrow || this.opts.alignTo == "cursor") pos.arrow = "bottom";
                if (pos.t < win.t) {
                    pos.t = yB + this.opts.offsetY;
                    if (pos.arrow == "bottom") pos.arrow = "top";
                }
            }
            this.pos = pos;
        }
    };
    $.fn.poshytip = function(options) {
        if (typeof options == "string") {
            var args = arguments, method = options;
            Array.prototype.shift.call(args);
            if (method == "destroy") {
                this.die ? this.die("mouseenter.poshytip").die("focus.poshytip") : $(document).undelegate(this.selector, "mouseenter.poshytip").undelegate(this.selector, "focus.poshytip");
            }
            return this.each(function() {
                var poshytip = $(this).data("poshytip");
                if (poshytip && poshytip[method]) poshytip[method].apply(poshytip, args);
            });
        }
        var opts = $.extend({}, $.fn.poshytip.defaults, options);
        if (!$("#poshytip-css-" + opts.className)[0]) $([ '<style id="poshytip-css-', opts.className, '" type="text/css">', "div.", opts.className, "{visibility:hidden;position:absolute;top:0;left:0;}", "div.", opts.className, " table.tip-table, div.", opts.className, " table.tip-table td{margin:0;font-family:inherit;font-size:inherit;font-weight:inherit;font-style:inherit;font-variant:inherit;}", "div.", opts.className, " td.tip-bg-image span{display:block;font:1px/1px sans-serif;height:", opts.bgImageFrameSize, "px;width:", opts.bgImageFrameSize, "px;overflow:hidden;}", "div.", opts.className, " td.tip-right{background-position:100% 0;}", "div.", opts.className, " td.tip-bottom{background-position:100% 100%;}", "div.", opts.className, " td.tip-left{background-position:0 100%;}", "div.", opts.className, " div.tip-inner{background-position:-", opts.bgImageFrameSize, "px -", opts.bgImageFrameSize, "px;}", "div.", opts.className, " div.tip-arrow{visibility:hidden;position:absolute;overflow:hidden;font:1px/1px sans-serif;}", "</style>" ].join("")).appendTo("head");
        if (opts.liveEvents && opts.showOn != "none") {
            var handler, deadOpts = $.extend({}, opts, {
                liveEvents: false
            });
            switch (opts.showOn) {
              case "hover":
                handler = function() {
                    var $this = $(this);
                    if (!$this.data("poshytip")) $this.poshytip(deadOpts).poshytip("mouseenter");
                };
                this.live ? this.live("mouseenter.poshytip", handler) : $(document).delegate(this.selector, "mouseenter.poshytip", handler);
                break;

              case "focus":
                handler = function() {
                    var $this = $(this);
                    if (!$this.data("poshytip")) $this.poshytip(deadOpts).poshytip("show");
                };
                this.live ? this.live("focus.poshytip", handler) : $(document).delegate(this.selector, "focus.poshytip", handler);
                break;
            }
            return this;
        }
        return this.each(function() {
            new $.Poshytip(this, opts);
        });
    };
    $.fn.poshytip.defaults = {
        content: "[title]",
        className: "tip-yellow",
        bgImageFrameSize: 10,
        showTimeout: 500,
        hideTimeout: 100,
        timeOnScreen: 0,
        showOn: "hover",
        liveEvents: false,
        alignTo: "cursor",
        alignX: "right",
        alignY: "top",
        offsetX: -22,
        offsetY: 18,
        allowTipHover: true,
        followCursor: false,
        fade: true,
        slide: true,
        slideOffset: 8,
        showAniDuration: 300,
        hideAniDuration: 300,
        refreshAniDuration: 200
    };
})(jQuery);

(function($) {
    "use strict";
    var EditableForm = function(div, options) {
        this.options = $.extend({}, $.fn.editableform.defaults, options);
        this.$div = $(div);
        if (!this.options.scope) {
            this.options.scope = this;
        }
    };
    EditableForm.prototype = {
        constructor: EditableForm,
        initInput: function() {
            this.input = this.options.input;
            this.value = this.input.str2value(this.options.value);
            this.input.prerender();
        },
        initTemplate: function() {
            this.$form = $($.fn.editableform.template);
        },
        initButtons: function() {
            var $btn = this.$form.find(".editable-buttons");
            $btn.append($.fn.editableform.buttons);
            if (this.options.showbuttons === "bottom") {
                $btn.addClass("editable-buttons-bottom");
            }
        },
        render: function() {
            this.$loading = $($.fn.editableform.loading);
            this.$div.empty().append(this.$loading);
            this.initTemplate();
            if (this.options.showbuttons) {
                this.initButtons();
            } else {
                this.$form.find(".editable-buttons").remove();
            }
            this.showLoading();
            this.isSaving = false;
            this.$div.triggerHandler("rendering");
            this.initInput();
            this.$form.find("div.editable-input").append(this.input.$tpl);
            this.$div.append(this.$form);
            $.when(this.input.render()).then($.proxy(function() {
                if (!this.options.showbuttons) {
                    this.input.autosubmit();
                }
                this.$form.find(".editable-cancel").click($.proxy(this.cancel, this));
                if (this.input.error) {
                    this.error(this.input.error);
                    this.$form.find(".editable-submit").attr("disabled", true);
                    this.input.$input.attr("disabled", true);
                    this.$form.submit(function(e) {
                        e.preventDefault();
                    });
                } else {
                    this.error(false);
                    this.input.$input.removeAttr("disabled");
                    this.$form.find(".editable-submit").removeAttr("disabled");
                    var value = this.value === null || this.value === undefined || this.value === "" ? this.options.defaultValue : this.value;
                    this.input.value2input(value);
                    this.$form.submit($.proxy(this.submit, this));
                }
                this.$div.triggerHandler("rendered");
                this.showForm();
                if (this.input.postrender) {
                    this.input.postrender();
                }
            }, this));
        },
        cancel: function() {
            this.$div.triggerHandler("cancel");
        },
        showLoading: function() {
            var w, h;
            if (this.$form) {
                w = this.$form.outerWidth();
                h = this.$form.outerHeight();
                if (w) {
                    this.$loading.width(w);
                }
                if (h) {
                    this.$loading.height(h);
                }
                this.$form.hide();
            } else {
                w = this.$loading.parent().width();
                if (w) {
                    this.$loading.width(w);
                }
            }
            this.$loading.show();
        },
        showForm: function(activate) {
            this.$loading.hide();
            this.$form.show();
            if (activate !== false) {
                this.input.activate();
            }
            this.$div.triggerHandler("show");
        },
        error: function(msg) {
            var $group = this.$form.find(".control-group"), $block = this.$form.find(".editable-error-block"), lines;
            if (msg === false) {
                $group.removeClass($.fn.editableform.errorGroupClass);
                $block.removeClass($.fn.editableform.errorBlockClass).empty().hide();
            } else {
                if (msg) {
                    lines = ("" + msg).split("\n");
                    for (var i = 0; i < lines.length; i++) {
                        lines[i] = $("<div>").text(lines[i]).html();
                    }
                    msg = lines.join("<br>");
                }
                $group.addClass($.fn.editableform.errorGroupClass);
                $block.addClass($.fn.editableform.errorBlockClass).html(msg).show();
            }
        },
        submit: function(e) {
            e.stopPropagation();
            e.preventDefault();
            var newValue = this.input.input2value();
            var error = this.validate(newValue);
            if ($.type(error) === "object" && error.newValue !== undefined) {
                newValue = error.newValue;
                this.input.value2input(newValue);
                if (typeof error.msg === "string") {
                    this.error(error.msg);
                    this.showForm();
                    return;
                }
            } else if (error) {
                this.error(error);
                this.showForm();
                return;
            }
            if (!this.options.savenochange && this.input.value2str(newValue) == this.input.value2str(this.value)) {
                this.$div.triggerHandler("nochange");
                return;
            }
            var submitValue = this.input.value2submit(newValue);
            this.isSaving = true;
            $.when(this.save(submitValue)).done($.proxy(function(response) {
                this.isSaving = false;
                var res = typeof this.options.success === "function" ? this.options.success.call(this.options.scope, response, newValue) : null;
                if (res === false) {
                    this.error(false);
                    this.showForm(false);
                    return;
                }
                if (typeof res === "string") {
                    this.error(res);
                    this.showForm();
                    return;
                }
                if (res && typeof res === "object" && res.hasOwnProperty("newValue")) {
                    newValue = res.newValue;
                }
                this.error(false);
                this.value = newValue;
                this.$div.triggerHandler("save", {
                    newValue: newValue,
                    submitValue: submitValue,
                    response: response
                });
            }, this)).fail($.proxy(function(xhr) {
                this.isSaving = false;
                var msg;
                if (typeof this.options.error === "function") {
                    msg = this.options.error.call(this.options.scope, xhr, newValue);
                } else {
                    msg = typeof xhr === "string" ? xhr : xhr.responseText || xhr.statusText || "Unknown error!";
                }
                this.error(msg);
                this.showForm();
            }, this));
        },
        save: function(submitValue) {
            this.options.pk = $.fn.editableutils.tryParseJson(this.options.pk, true);
            var pk = typeof this.options.pk === "function" ? this.options.pk.call(this.options.scope) : this.options.pk, send = !!(typeof this.options.url === "function" || this.options.url && (this.options.send === "always" || this.options.send === "auto" && pk !== null && pk !== undefined)), params;
            if (send) {
                this.showLoading();
                params = {
                    name: this.options.name || "",
                    value: submitValue,
                    pk: pk
                };
                if (typeof this.options.params === "function") {
                    params = this.options.params.call(this.options.scope, params);
                } else {
                    this.options.params = $.fn.editableutils.tryParseJson(this.options.params, true);
                    $.extend(params, this.options.params);
                }
                if (typeof this.options.url === "function") {
                    return this.options.url.call(this.options.scope, params);
                } else {
                    return $.ajax($.extend({
                        url: this.options.url,
                        data: params,
                        type: "POST"
                    }, this.options.ajaxOptions));
                }
            }
        },
        validate: function(value) {
            if (value === undefined) {
                value = this.value;
            }
            if (typeof this.options.validate === "function") {
                return this.options.validate.call(this.options.scope, value);
            }
        },
        option: function(key, value) {
            if (key in this.options) {
                this.options[key] = value;
            }
            if (key === "value") {
                this.setValue(value);
            }
        },
        setValue: function(value, convertStr) {
            if (convertStr) {
                this.value = this.input.str2value(value);
            } else {
                this.value = value;
            }
            if (this.$form && this.$form.is(":visible")) {
                this.input.value2input(this.value);
            }
        }
    };
    $.fn.editableform = function(option) {
        var args = arguments;
        return this.each(function() {
            var $this = $(this), data = $this.data("editableform"), options = typeof option === "object" && option;
            if (!data) {
                $this.data("editableform", data = new EditableForm(this, options));
            }
            if (typeof option === "string") {
                data[option].apply(data, Array.prototype.slice.call(args, 1));
            }
        });
    };
    $.fn.editableform.Constructor = EditableForm;
    $.fn.editableform.defaults = {
        type: "text",
        url: null,
        params: null,
        name: null,
        pk: null,
        value: null,
        defaultValue: null,
        send: "auto",
        validate: null,
        success: null,
        error: null,
        ajaxOptions: null,
        showbuttons: true,
        scope: null,
        savenochange: false
    };
    $.fn.editableform.template = '<form class="form-inline editableform">' + '<div class="control-group">' + '<div><div class="editable-input"></div><div class="editable-buttons"></div></div>' + '<div class="editable-error-block"></div>' + "</div>" + "</form>";
    $.fn.editableform.loading = '<div class="editableform-loading"></div>';
    $.fn.editableform.buttons = '<button type="submit" class="editable-submit">ok</button>' + '<button type="button" class="editable-cancel">cancel</button>';
    $.fn.editableform.errorGroupClass = null;
    $.fn.editableform.errorBlockClass = "editable-error";
    $.fn.editableform.engine = "jquery";
})(window.jQuery);

(function($) {
    "use strict";
    $.fn.editableutils = {
        inherit: function(Child, Parent) {
            var F = function() {};
            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.prototype.constructor = Child;
            Child.superclass = Parent.prototype;
        },
        setCursorPosition: function(elem, pos) {
            if (elem.setSelectionRange) {
                elem.setSelectionRange(pos, pos);
            } else if (elem.createTextRange) {
                var range = elem.createTextRange();
                range.collapse(true);
                range.moveEnd("character", pos);
                range.moveStart("character", pos);
                range.select();
            }
        },
        tryParseJson: function(s, safe) {
            if (typeof s === "string" && s.length && s.match(/^[\{\[].*[\}\]]$/)) {
                if (safe) {
                    try {
                        s = new Function("return " + s)();
                    } catch (e) {} finally {
                        return s;
                    }
                } else {
                    s = new Function("return " + s)();
                }
            }
            return s;
        },
        sliceObj: function(obj, keys, caseSensitive) {
            var key, keyLower, newObj = {};
            if (!$.isArray(keys) || !keys.length) {
                return newObj;
            }
            for (var i = 0; i < keys.length; i++) {
                key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    newObj[key] = obj[key];
                }
                if (caseSensitive === true) {
                    continue;
                }
                keyLower = key.toLowerCase();
                if (obj.hasOwnProperty(keyLower)) {
                    newObj[key] = obj[keyLower];
                }
            }
            return newObj;
        },
        getConfigData: function($element) {
            var data = {};
            $.each($element.data(), function(k, v) {
                if (typeof v !== "object" || v && typeof v === "object" && (v.constructor === Object || v.constructor === Array)) {
                    data[k] = v;
                }
            });
            return data;
        },
        objectKeys: function(o) {
            if (Object.keys) {
                return Object.keys(o);
            } else {
                if (o !== Object(o)) {
                    throw new TypeError("Object.keys called on a non-object");
                }
                var k = [], p;
                for (p in o) {
                    if (Object.prototype.hasOwnProperty.call(o, p)) {
                        k.push(p);
                    }
                }
                return k;
            }
        },
        escape: function(str) {
            return $("<div>").text(str).html();
        },
        itemsByValue: function(value, sourceData, valueProp) {
            if (!sourceData || value === null) {
                return [];
            }
            if (typeof valueProp !== "function") {
                var idKey = valueProp || "value";
                valueProp = function(e) {
                    return e[idKey];
                };
            }
            var isValArray = $.isArray(value), result = [], that = this;
            $.each(sourceData, function(i, o) {
                if (o.children) {
                    result = result.concat(that.itemsByValue(value, o.children, valueProp));
                } else {
                    if (isValArray) {
                        if ($.grep(value, function(v) {
                            return v == (o && typeof o === "object" ? valueProp(o) : o);
                        }).length) {
                            result.push(o);
                        }
                    } else {
                        var itemValue = o && typeof o === "object" ? valueProp(o) : o;
                        if (value == itemValue) {
                            result.push(o);
                        }
                    }
                }
            });
            return result;
        },
        createInput: function(options) {
            var TypeConstructor, typeOptions, input, type = options.type;
            if (type === "date") {
                if (options.mode === "inline") {
                    if ($.fn.editabletypes.datefield) {
                        type = "datefield";
                    } else if ($.fn.editabletypes.dateuifield) {
                        type = "dateuifield";
                    }
                } else {
                    if ($.fn.editabletypes.date) {
                        type = "date";
                    } else if ($.fn.editabletypes.dateui) {
                        type = "dateui";
                    }
                }
                if (type === "date" && !$.fn.editabletypes.date) {
                    type = "combodate";
                }
            }
            if (type === "datetime" && options.mode === "inline") {
                type = "datetimefield";
            }
            if (type === "wysihtml5" && !$.fn.editabletypes[type]) {
                type = "textarea";
            }
            if (typeof $.fn.editabletypes[type] === "function") {
                TypeConstructor = $.fn.editabletypes[type];
                typeOptions = this.sliceObj(options, this.objectKeys(TypeConstructor.defaults));
                input = new TypeConstructor(typeOptions);
                return input;
            } else {
                $.error("Unknown type: " + type);
                return false;
            }
        },
        supportsTransitions: function() {
            var b = document.body || document.documentElement, s = b.style, p = "transition", v = [ "Moz", "Webkit", "Khtml", "O", "ms" ];
            if (typeof s[p] === "string") {
                return true;
            }
            p = p.charAt(0).toUpperCase() + p.substr(1);
            for (var i = 0; i < v.length; i++) {
                if (typeof s[v[i] + p] === "string") {
                    return true;
                }
            }
            return false;
        }
    };
})(window.jQuery);

(function($) {
    "use strict";
    var Popup = function(element, options) {
        this.init(element, options);
    };
    var Inline = function(element, options) {
        this.init(element, options);
    };
    Popup.prototype = {
        containerName: null,
        containerDataName: null,
        innerCss: null,
        containerClass: "editable-container editable-popup",
        defaults: {},
        init: function(element, options) {
            this.$element = $(element);
            this.options = $.extend({}, $.fn.editableContainer.defaults, options);
            this.splitOptions();
            this.formOptions.scope = this.$element[0];
            this.initContainer();
            this.delayedHide = false;
            this.$element.on("destroyed", $.proxy(function() {
                this.destroy();
            }, this));
            if (!$(document).data("editable-handlers-attached")) {
                $(document).on("keyup.editable", function(e) {
                    if (e.which === 27) {
                        $(".editable-open").editableContainer("hide");
                    }
                });
                $(document).on("click.editable", function(e) {
                    var $target = $(e.target), i, exclude_classes = [ ".editable-container", ".ui-datepicker-header", ".datepicker", ".modal-backdrop", ".bootstrap-wysihtml5-insert-image-modal", ".bootstrap-wysihtml5-insert-link-modal" ];
                    if ($(".select2-drop-mask").is(":visible")) {
                        return;
                    }
                    if (!$.contains(document.documentElement, e.target)) {
                        return;
                    }
                    if ($target.is(document)) {
                        return;
                    }
                    for (i = 0; i < exclude_classes.length; i++) {
                        if ($target.is(exclude_classes[i]) || $target.parents(exclude_classes[i]).length) {
                            return;
                        }
                    }
                    Popup.prototype.closeOthers(e.target);
                });
                $(document).data("editable-handlers-attached", true);
            }
        },
        splitOptions: function() {
            this.containerOptions = {};
            this.formOptions = {};
            if (!$.fn[this.containerName]) {
                throw new Error(this.containerName + " not found. Have you included corresponding js file?");
            }
            for (var k in this.options) {
                if (k in this.defaults) {
                    this.containerOptions[k] = this.options[k];
                } else {
                    this.formOptions[k] = this.options[k];
                }
            }
        },
        tip: function() {
            return this.container() ? this.container().$tip : null;
        },
        container: function() {
            var container;
            if (this.containerDataName) {
                if (container = this.$element.data(this.containerDataName)) {
                    return container;
                }
            }
            container = this.$element.data(this.containerName);
            return container;
        },
        call: function() {
            this.$element[this.containerName].apply(this.$element, arguments);
        },
        initContainer: function() {
            this.call(this.containerOptions);
        },
        renderForm: function() {
            this.$form.editableform(this.formOptions).on({
                save: $.proxy(this.save, this),
                nochange: $.proxy(function() {
                    this.hide("nochange");
                }, this),
                cancel: $.proxy(function() {
                    this.hide("cancel");
                }, this),
                show: $.proxy(function() {
                    if (this.delayedHide) {
                        this.hide(this.delayedHide.reason);
                        this.delayedHide = false;
                    } else {
                        this.setPosition();
                    }
                }, this),
                rendering: $.proxy(this.setPosition, this),
                resize: $.proxy(this.setPosition, this),
                rendered: $.proxy(function() {
                    this.$element.triggerHandler("shown", $(this.options.scope).data("editable"));
                }, this)
            }).editableform("render");
        },
        show: function(closeAll) {
            this.$element.addClass("editable-open");
            if (closeAll !== false) {
                this.closeOthers(this.$element[0]);
            }
            this.innerShow();
            this.tip().addClass(this.containerClass);
            if (this.$form) {}
            this.$form = $("<div>");
            if (this.tip().is(this.innerCss)) {
                this.tip().append(this.$form);
            } else {
                this.tip().find(this.innerCss).append(this.$form);
            }
            this.renderForm();
        },
        hide: function(reason) {
            if (!this.tip() || !this.tip().is(":visible") || !this.$element.hasClass("editable-open")) {
                return;
            }
            if (this.$form.data("editableform").isSaving) {
                this.delayedHide = {
                    reason: reason
                };
                return;
            } else {
                this.delayedHide = false;
            }
            this.$element.removeClass("editable-open");
            this.innerHide();
            this.$element.triggerHandler("hidden", reason || "manual");
        },
        innerShow: function() {},
        innerHide: function() {},
        toggle: function(closeAll) {
            if (this.container() && this.tip() && this.tip().is(":visible")) {
                this.hide();
            } else {
                this.show(closeAll);
            }
        },
        setPosition: function() {},
        save: function(e, params) {
            this.$element.triggerHandler("save", params);
            this.hide("save");
        },
        option: function(key, value) {
            this.options[key] = value;
            if (key in this.containerOptions) {
                this.containerOptions[key] = value;
                this.setContainerOption(key, value);
            } else {
                this.formOptions[key] = value;
                if (this.$form) {
                    this.$form.editableform("option", key, value);
                }
            }
        },
        setContainerOption: function(key, value) {
            this.call("option", key, value);
        },
        destroy: function() {
            this.hide();
            this.innerDestroy();
            this.$element.off("destroyed");
            this.$element.removeData("editableContainer");
        },
        innerDestroy: function() {},
        closeOthers: function(element) {
            $(".editable-open").each(function(i, el) {
                if (el === element || $(el).find(element).length) {
                    return;
                }
                var $el = $(el), ec = $el.data("editableContainer");
                if (!ec) {
                    return;
                }
                if (ec.options.onblur === "cancel") {
                    $el.data("editableContainer").hide("onblur");
                } else if (ec.options.onblur === "submit") {
                    $el.data("editableContainer").tip().find("form").submit();
                }
            });
        },
        activate: function() {
            if (this.tip && this.tip().is(":visible") && this.$form) {
                this.$form.data("editableform").input.activate();
            }
        }
    };
    $.fn.editableContainer = function(option) {
        var args = arguments;
        return this.each(function() {
            var $this = $(this), dataKey = "editableContainer", data = $this.data(dataKey), options = typeof option === "object" && option, Constructor = options.mode === "inline" ? Inline : Popup;
            if (!data) {
                $this.data(dataKey, data = new Constructor(this, options));
            }
            if (typeof option === "string") {
                data[option].apply(data, Array.prototype.slice.call(args, 1));
            }
        });
    };
    $.fn.editableContainer.Popup = Popup;
    $.fn.editableContainer.Inline = Inline;
    $.fn.editableContainer.defaults = {
        value: null,
        placement: "top",
        autohide: true,
        onblur: "cancel",
        anim: false,
        mode: "popup"
    };
    jQuery.event.special.destroyed = {
        remove: function(o) {
            if (o.handler) {
                o.handler();
            }
        }
    };
})(window.jQuery);

(function($) {
    "use strict";
    $.extend($.fn.editableContainer.Inline.prototype, $.fn.editableContainer.Popup.prototype, {
        containerName: "editableform",
        innerCss: ".editable-inline",
        containerClass: "editable-container editable-inline",
        initContainer: function() {
            this.$tip = $("<span></span>");
            if (!this.options.anim) {
                this.options.anim = 0;
            }
        },
        splitOptions: function() {
            this.containerOptions = {};
            this.formOptions = this.options;
        },
        tip: function() {
            return this.$tip;
        },
        innerShow: function() {
            this.$element.hide();
            this.tip().insertAfter(this.$element).show();
        },
        innerHide: function() {
            this.$tip.hide(this.options.anim, $.proxy(function() {
                this.$element.show();
                this.innerDestroy();
            }, this));
        },
        innerDestroy: function() {
            if (this.tip()) {
                this.tip().empty().remove();
            }
        }
    });
})(window.jQuery);

(function($) {
    "use strict";
    var Editable = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, $.fn.editable.defaults, options, $.fn.editableutils.getConfigData(this.$element));
        if (this.options.selector) {
            this.initLive();
        } else {
            this.init();
        }
        if (this.options.highlight && !$.fn.editableutils.supportsTransitions()) {
            this.options.highlight = false;
        }
    };
    Editable.prototype = {
        constructor: Editable,
        init: function() {
            var isValueByText = false, doAutotext, finalize;
            this.options.name = this.options.name || this.$element.attr("id");
            this.options.scope = this.$element[0];
            this.input = $.fn.editableutils.createInput(this.options);
            if (!this.input) {
                return;
            }
            if (this.options.value === undefined || this.options.value === null) {
                this.value = this.input.html2value($.trim(this.$element.html()));
                isValueByText = true;
            } else {
                this.options.value = $.fn.editableutils.tryParseJson(this.options.value, true);
                if (typeof this.options.value === "string") {
                    this.value = this.input.str2value(this.options.value);
                } else {
                    this.value = this.options.value;
                }
            }
            this.$element.addClass("editable");
            if (this.input.type === "textarea") {
                this.$element.addClass("editable-pre-wrapped");
            }
            if (this.options.toggle !== "manual") {
                this.$element.addClass("editable-click");
                this.$element.on(this.options.toggle + ".editable", $.proxy(function(e) {
                    if (!this.options.disabled) {
                        e.preventDefault();
                    }
                    if (this.options.toggle === "mouseenter") {
                        this.show();
                    } else {
                        var closeAll = this.options.toggle !== "click";
                        this.toggle(closeAll);
                    }
                }, this));
            } else {
                this.$element.attr("tabindex", -1);
            }
            if (typeof this.options.display === "function") {
                this.options.autotext = "always";
            }
            switch (this.options.autotext) {
              case "always":
                doAutotext = true;
                break;

              case "auto":
                doAutotext = !$.trim(this.$element.text()).length && this.value !== null && this.value !== undefined && !isValueByText;
                break;

              default:
                doAutotext = false;
            }
            $.when(doAutotext ? this.render() : true).then($.proxy(function() {
                if (this.options.disabled) {
                    this.disable();
                } else {
                    this.enable();
                }
                this.$element.triggerHandler("init", this);
            }, this));
        },
        initLive: function() {
            var selector = this.options.selector;
            this.options.selector = false;
            this.options.autotext = "never";
            this.$element.on(this.options.toggle + ".editable", selector, $.proxy(function(e) {
                var $target = $(e.target);
                if (!$target.data("editable")) {
                    if ($target.hasClass(this.options.emptyclass)) {
                        $target.empty();
                    }
                    $target.editable(this.options).trigger(e);
                }
            }, this));
        },
        render: function(response) {
            if (this.options.display === false) {
                return;
            }
            if (this.input.value2htmlFinal) {
                return this.input.value2html(this.value, this.$element[0], this.options.display, response);
            } else if (typeof this.options.display === "function") {
                return this.options.display.call(this.$element[0], this.value, response);
            } else {
                return this.input.value2html(this.value, this.$element[0]);
            }
        },
        enable: function() {
            this.options.disabled = false;
            this.$element.removeClass("editable-disabled");
            this.handleEmpty(this.isEmpty);
            if (this.options.toggle !== "manual") {
                if (this.$element.attr("tabindex") === "-1") {
                    this.$element.removeAttr("tabindex");
                }
            }
        },
        disable: function() {
            this.options.disabled = true;
            this.hide();
            this.$element.addClass("editable-disabled");
            this.handleEmpty(this.isEmpty);
            this.$element.attr("tabindex", -1);
        },
        toggleDisabled: function() {
            if (this.options.disabled) {
                this.enable();
            } else {
                this.disable();
            }
        },
        option: function(key, value) {
            if (key && typeof key === "object") {
                $.each(key, $.proxy(function(k, v) {
                    this.option($.trim(k), v);
                }, this));
                return;
            }
            this.options[key] = value;
            if (key === "disabled") {
                return value ? this.disable() : this.enable();
            }
            if (key === "value") {
                this.setValue(value);
            }
            if (this.container) {
                this.container.option(key, value);
            }
            if (this.input.option) {
                this.input.option(key, value);
            }
        },
        handleEmpty: function(isEmpty) {
            if (this.options.display === false) {
                return;
            }
            if (isEmpty !== undefined) {
                this.isEmpty = isEmpty;
            } else {
                if (typeof this.input.isEmpty === "function") {
                    this.isEmpty = this.input.isEmpty(this.$element);
                } else {
                    this.isEmpty = $.trim(this.$element.html()) === "";
                }
            }
            if (!this.options.disabled) {
                if (this.isEmpty) {
                    this.$element.html(this.options.emptytext);
                    if (this.options.emptyclass) {
                        this.$element.addClass(this.options.emptyclass);
                    }
                } else if (this.options.emptyclass) {
                    this.$element.removeClass(this.options.emptyclass);
                }
            } else {
                if (this.isEmpty) {
                    this.$element.empty();
                    if (this.options.emptyclass) {
                        this.$element.removeClass(this.options.emptyclass);
                    }
                }
            }
        },
        show: function(closeAll) {
            if (this.options.disabled) {
                return;
            }
            if (!this.container) {
                var containerOptions = $.extend({}, this.options, {
                    value: this.value,
                    input: this.input
                });
                this.$element.editableContainer(containerOptions);
                this.$element.on("save.internal", $.proxy(this.save, this));
                this.container = this.$element.data("editableContainer");
            } else if (this.container.tip().is(":visible")) {
                return;
            }
            this.container.show(closeAll);
        },
        hide: function() {
            if (this.container) {
                this.container.hide();
            }
        },
        toggle: function(closeAll) {
            if (this.container && this.container.tip().is(":visible")) {
                this.hide();
            } else {
                this.show(closeAll);
            }
        },
        save: function(e, params) {
            if (this.options.unsavedclass) {
                var sent = false;
                sent = sent || typeof this.options.url === "function";
                sent = sent || this.options.display === false;
                sent = sent || params.response !== undefined;
                sent = sent || this.options.savenochange && this.input.value2str(this.value) !== this.input.value2str(params.newValue);
                if (sent) {
                    this.$element.removeClass(this.options.unsavedclass);
                } else {
                    this.$element.addClass(this.options.unsavedclass);
                }
            }
            if (this.options.highlight) {
                var $e = this.$element, bgColor = $e.css("background-color");
                $e.css("background-color", this.options.highlight);
                setTimeout(function() {
                    if (bgColor === "transparent") {
                        bgColor = "";
                    }
                    $e.css("background-color", bgColor);
                    $e.addClass("editable-bg-transition");
                    setTimeout(function() {
                        $e.removeClass("editable-bg-transition");
                    }, 1700);
                }, 10);
            }
            this.setValue(params.newValue, false, params.response);
        },
        validate: function() {
            if (typeof this.options.validate === "function") {
                return this.options.validate.call(this, this.value);
            }
        },
        setValue: function(value, convertStr, response) {
            if (convertStr) {
                this.value = this.input.str2value(value);
            } else {
                this.value = value;
            }
            if (this.container) {
                this.container.option("value", this.value);
            }
            $.when(this.render(response)).then($.proxy(function() {
                this.handleEmpty();
            }, this));
        },
        activate: function() {
            if (this.container) {
                this.container.activate();
            }
        },
        destroy: function() {
            this.disable();
            if (this.container) {
                this.container.destroy();
            }
            this.input.destroy();
            if (this.options.toggle !== "manual") {
                this.$element.removeClass("editable-click");
                this.$element.off(this.options.toggle + ".editable");
            }
            this.$element.off("save.internal");
            this.$element.removeClass("editable editable-open editable-disabled");
            this.$element.removeData("editable");
        }
    };
    $.fn.editable = function(option) {
        var result = {}, args = arguments, datakey = "editable";
        switch (option) {
          case "validate":
            this.each(function() {
                var $this = $(this), data = $this.data(datakey), error;
                if (data && (error = data.validate())) {
                    result[data.options.name] = error;
                }
            });
            return result;

          case "getValue":
            if (arguments.length === 2 && arguments[1] === true) {
                result = this.eq(0).data(datakey).value;
            } else {
                this.each(function() {
                    var $this = $(this), data = $this.data(datakey);
                    if (data && data.value !== undefined && data.value !== null) {
                        result[data.options.name] = data.input.value2submit(data.value);
                    }
                });
            }
            return result;

          case "submit":
            var config = arguments[1] || {}, $elems = this, errors = this.editable("validate");
            if ($.isEmptyObject(errors)) {
                var ajaxOptions = {};
                if ($elems.length === 1) {
                    var editable = $elems.data("editable");
                    var params = {
                        name: editable.options.name || "",
                        value: editable.input.value2submit(editable.value),
                        pk: typeof editable.options.pk === "function" ? editable.options.pk.call(editable.options.scope) : editable.options.pk
                    };
                    if (typeof editable.options.params === "function") {
                        params = editable.options.params.call(editable.options.scope, params);
                    } else {
                        editable.options.params = $.fn.editableutils.tryParseJson(editable.options.params, true);
                        $.extend(params, editable.options.params);
                    }
                    ajaxOptions = {
                        url: editable.options.url,
                        data: params,
                        type: "POST"
                    };
                    config.success = config.success || editable.options.success;
                    config.error = config.error || editable.options.error;
                } else {
                    var values = this.editable("getValue");
                    ajaxOptions = {
                        url: config.url,
                        data: values,
                        type: "POST"
                    };
                }
                ajaxOptions.success = typeof config.success === "function" ? function(response) {
                    config.success.call($elems, response, config);
                } : $.noop;
                ajaxOptions.error = typeof config.error === "function" ? function() {
                    config.error.apply($elems, arguments);
                } : $.noop;
                if (config.ajaxOptions) {
                    $.extend(ajaxOptions, config.ajaxOptions);
                }
                if (config.data) {
                    $.extend(ajaxOptions.data, config.data);
                }
                $.ajax(ajaxOptions);
            } else {
                if (typeof config.error === "function") {
                    config.error.call($elems, errors);
                }
            }
            return this;
        }
        return this.each(function() {
            var $this = $(this), data = $this.data(datakey), options = typeof option === "object" && option;
            if (options && options.selector) {
                data = new Editable(this, options);
                return;
            }
            if (!data) {
                $this.data(datakey, data = new Editable(this, options));
            }
            if (typeof option === "string") {
                data[option].apply(data, Array.prototype.slice.call(args, 1));
            }
        });
    };
    $.fn.editable.defaults = {
        type: "text",
        disabled: false,
        toggle: "click",
        emptytext: "Empty",
        autotext: "auto",
        value: null,
        display: null,
        emptyclass: "editable-empty",
        unsavedclass: "editable-unsaved",
        selector: null,
        highlight: "#FFFF80"
    };
})(window.jQuery);

(function($) {
    "use strict";
    $.fn.editabletypes = {};
    var AbstractInput = function() {};
    AbstractInput.prototype = {
        init: function(type, options, defaults) {
            this.type = type;
            this.options = $.extend({}, defaults, options);
        },
        prerender: function() {
            this.$tpl = $(this.options.tpl);
            this.$input = this.$tpl;
            this.$clear = null;
            this.error = null;
        },
        render: function() {},
        value2html: function(value, element) {
            $(element)[this.options.escape ? "text" : "html"]($.trim(value));
        },
        html2value: function(html) {
            return $("<div>").html(html).text();
        },
        value2str: function(value) {
            return value;
        },
        str2value: function(str) {
            return str;
        },
        value2submit: function(value) {
            return value;
        },
        value2input: function(value) {
            this.$input.val(value);
        },
        input2value: function() {
            return this.$input.val();
        },
        activate: function() {
            if (this.$input.is(":visible")) {
                this.$input.focus();
            }
        },
        clear: function() {
            this.$input.val(null);
        },
        escape: function(str) {
            return $("<div>").text(str).html();
        },
        autosubmit: function() {},
        destroy: function() {},
        setClass: function() {
            if (this.options.inputclass) {
                this.$input.addClass(this.options.inputclass);
            }
        },
        setAttr: function(attr) {
            if (this.options[attr] !== undefined && this.options[attr] !== null) {
                this.$input.attr(attr, this.options[attr]);
            }
        },
        option: function(key, value) {
            this.options[key] = value;
        }
    };
    AbstractInput.defaults = {
        tpl: "",
        inputclass: null,
        escape: true,
        scope: null,
        showbuttons: true
    };
    $.extend($.fn.editabletypes, {
        abstractinput: AbstractInput
    });
})(window.jQuery);

(function($) {
    "use strict";
    var List = function(options) {};
    $.fn.editableutils.inherit(List, $.fn.editabletypes.abstractinput);
    $.extend(List.prototype, {
        render: function() {
            var deferred = $.Deferred();
            this.error = null;
            this.onSourceReady(function() {
                this.renderList();
                deferred.resolve();
            }, function() {
                this.error = this.options.sourceError;
                deferred.resolve();
            });
            return deferred.promise();
        },
        html2value: function(html) {
            return null;
        },
        value2html: function(value, element, display, response) {
            var deferred = $.Deferred(), success = function() {
                if (typeof display === "function") {
                    display.call(element, value, this.sourceData, response);
                } else {
                    this.value2htmlFinal(value, element);
                }
                deferred.resolve();
            };
            if (value === null) {
                success.call(this);
            } else {
                this.onSourceReady(success, function() {
                    deferred.resolve();
                });
            }
            return deferred.promise();
        },
        onSourceReady: function(success, error) {
            var source;
            if ($.isFunction(this.options.source)) {
                source = this.options.source.call(this.options.scope);
                this.sourceData = null;
            } else {
                source = this.options.source;
            }
            if (this.options.sourceCache && $.isArray(this.sourceData)) {
                success.call(this);
                return;
            }
            try {
                source = $.fn.editableutils.tryParseJson(source, false);
            } catch (e) {
                error.call(this);
                return;
            }
            if (typeof source === "string") {
                if (this.options.sourceCache) {
                    var cacheID = source, cache;
                    if (!$(document).data(cacheID)) {
                        $(document).data(cacheID, {});
                    }
                    cache = $(document).data(cacheID);
                    if (cache.loading === false && cache.sourceData) {
                        this.sourceData = cache.sourceData;
                        this.doPrepend();
                        success.call(this);
                        return;
                    } else if (cache.loading === true) {
                        cache.callbacks.push($.proxy(function() {
                            this.sourceData = cache.sourceData;
                            this.doPrepend();
                            success.call(this);
                        }, this));
                        cache.err_callbacks.push($.proxy(error, this));
                        return;
                    } else {
                        cache.loading = true;
                        cache.callbacks = [];
                        cache.err_callbacks = [];
                    }
                }
                var ajaxOptions = $.extend({
                    url: source,
                    type: "get",
                    cache: false,
                    dataType: "json",
                    success: $.proxy(function(data) {
                        if (cache) {
                            cache.loading = false;
                        }
                        this.sourceData = this.makeArray(data);
                        if ($.isArray(this.sourceData)) {
                            if (cache) {
                                cache.sourceData = this.sourceData;
                                $.each(cache.callbacks, function() {
                                    this.call();
                                });
                            }
                            this.doPrepend();
                            success.call(this);
                        } else {
                            error.call(this);
                            if (cache) {
                                $.each(cache.err_callbacks, function() {
                                    this.call();
                                });
                            }
                        }
                    }, this),
                    error: $.proxy(function() {
                        error.call(this);
                        if (cache) {
                            cache.loading = false;
                            $.each(cache.err_callbacks, function() {
                                this.call();
                            });
                        }
                    }, this)
                }, this.options.sourceOptions);
                $.ajax(ajaxOptions);
            } else {
                this.sourceData = this.makeArray(source);
                if ($.isArray(this.sourceData)) {
                    this.doPrepend();
                    success.call(this);
                } else {
                    error.call(this);
                }
            }
        },
        doPrepend: function() {
            if (this.options.prepend === null || this.options.prepend === undefined) {
                return;
            }
            if (!$.isArray(this.prependData)) {
                if ($.isFunction(this.options.prepend)) {
                    this.options.prepend = this.options.prepend.call(this.options.scope);
                }
                this.options.prepend = $.fn.editableutils.tryParseJson(this.options.prepend, true);
                if (typeof this.options.prepend === "string") {
                    this.options.prepend = {
                        "": this.options.prepend
                    };
                }
                this.prependData = this.makeArray(this.options.prepend);
            }
            if ($.isArray(this.prependData) && $.isArray(this.sourceData)) {
                this.sourceData = this.prependData.concat(this.sourceData);
            }
        },
        renderList: function() {},
        value2htmlFinal: function(value, element) {},
        makeArray: function(data) {
            var count, obj, result = [], item, iterateItem;
            if (!data || typeof data === "string") {
                return null;
            }
            if ($.isArray(data)) {
                iterateItem = function(k, v) {
                    obj = {
                        value: k,
                        text: v
                    };
                    if (count++ >= 2) {
                        return false;
                    }
                };
                for (var i = 0; i < data.length; i++) {
                    item = data[i];
                    if (typeof item === "object") {
                        count = 0;
                        $.each(item, iterateItem);
                        if (count === 1) {
                            result.push(obj);
                        } else if (count > 1) {
                            if (item.children) {
                                item.children = this.makeArray(item.children);
                            }
                            result.push(item);
                        }
                    } else {
                        result.push({
                            value: item,
                            text: item
                        });
                    }
                }
            } else {
                $.each(data, function(k, v) {
                    result.push({
                        value: k,
                        text: v
                    });
                });
            }
            return result;
        },
        option: function(key, value) {
            this.options[key] = value;
            if (key === "source") {
                this.sourceData = null;
            }
            if (key === "prepend") {
                this.prependData = null;
            }
        }
    });
    List.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
        source: null,
        prepend: false,
        sourceError: "Error when loading list",
        sourceCache: true,
        sourceOptions: null
    });
    $.fn.editabletypes.list = List;
})(window.jQuery);

(function($) {
    "use strict";
    var Text = function(options) {
        this.init("text", options, Text.defaults);
    };
    $.fn.editableutils.inherit(Text, $.fn.editabletypes.abstractinput);
    $.extend(Text.prototype, {
        render: function() {
            this.renderClear();
            this.setClass();
            this.setAttr("placeholder");
        },
        activate: function() {
            if (this.$input.is(":visible")) {
                this.$input.focus();
                $.fn.editableutils.setCursorPosition(this.$input.get(0), this.$input.val().length);
                if (this.toggleClear) {
                    this.toggleClear();
                }
            }
        },
        renderClear: function() {
            if (this.options.clear) {
                this.$clear = $('<span class="editable-clear-x"></span>');
                this.$input.after(this.$clear).css("padding-right", 24).keyup($.proxy(function(e) {
                    if (~$.inArray(e.keyCode, [ 40, 38, 9, 13, 27 ])) {
                        return;
                    }
                    clearTimeout(this.t);
                    var that = this;
                    this.t = setTimeout(function() {
                        that.toggleClear(e);
                    }, 100);
                }, this)).parent().css("position", "relative");
                this.$clear.click($.proxy(this.clear, this));
            }
        },
        postrender: function() {},
        toggleClear: function(e) {
            if (!this.$clear) {
                return;
            }
            var len = this.$input.val().length, visible = this.$clear.is(":visible");
            if (len && !visible) {
                this.$clear.show();
            }
            if (!len && visible) {
                this.$clear.hide();
            }
        },
        clear: function() {
            this.$clear.hide();
            this.$input.val("").focus();
        }
    });
    Text.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
        tpl: '<input type="text">',
        placeholder: null,
        clear: true
    });
    $.fn.editabletypes.text = Text;
})(window.jQuery);

(function($) {
    "use strict";
    var Textarea = function(options) {
        this.init("textarea", options, Textarea.defaults);
    };
    $.fn.editableutils.inherit(Textarea, $.fn.editabletypes.abstractinput);
    $.extend(Textarea.prototype, {
        render: function() {
            this.setClass();
            this.setAttr("placeholder");
            this.setAttr("rows");
            this.$input.keydown(function(e) {
                if (e.ctrlKey && e.which === 13) {
                    $(this).closest("form").submit();
                }
            });
        },
        activate: function() {
            $.fn.editabletypes.text.prototype.activate.call(this);
        }
    });
    Textarea.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
        tpl: "<textarea></textarea>",
        inputclass: "input-large",
        placeholder: null,
        rows: 7
    });
    $.fn.editabletypes.textarea = Textarea;
})(window.jQuery);

(function($) {
    "use strict";
    var Select = function(options) {
        this.init("select", options, Select.defaults);
    };
    $.fn.editableutils.inherit(Select, $.fn.editabletypes.list);
    $.extend(Select.prototype, {
        renderList: function() {
            this.$input.empty();
            var escape = this.options.escape;
            var fillItems = function($el, data) {
                var attr;
                if ($.isArray(data)) {
                    for (var i = 0; i < data.length; i++) {
                        attr = {};
                        if (data[i].children) {
                            attr.label = data[i].text;
                            $el.append(fillItems($("<optgroup>", attr), data[i].children));
                        } else {
                            attr.value = data[i].value;
                            if (data[i].disabled) {
                                attr.disabled = true;
                            }
                            var $option = $("<option>", attr);
                            $option[escape ? "text" : "html"](data[i].text);
                            $el.append($option);
                        }
                    }
                }
                return $el;
            };
            fillItems(this.$input, this.sourceData);
            this.setClass();
            this.$input.on("keydown.editable", function(e) {
                if (e.which === 13) {
                    $(this).closest("form").submit();
                }
            });
        },
        value2htmlFinal: function(value, element) {
            var text = "", items = $.fn.editableutils.itemsByValue(value, this.sourceData);
            if (items.length) {
                text = items[0].text;
            }
            $.fn.editabletypes.abstractinput.prototype.value2html.call(this, text, element);
        },
        autosubmit: function() {
            this.$input.off("keydown.editable").on("change.editable", function() {
                $(this).closest("form").submit();
            });
        }
    });
    Select.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {
        tpl: "<select></select>"
    });
    $.fn.editabletypes.select = Select;
})(window.jQuery);

(function($) {
    "use strict";
    var Checklist = function(options) {
        this.init("checklist", options, Checklist.defaults);
    };
    $.fn.editableutils.inherit(Checklist, $.fn.editabletypes.list);
    $.extend(Checklist.prototype, {
        renderList: function() {
            var $label, $div;
            this.$tpl.empty();
            if (!$.isArray(this.sourceData)) {
                return;
            }
            for (var i = 0; i < this.sourceData.length; i++) {
                $label = $("<label>").append($("<input>", {
                    type: "checkbox",
                    value: this.sourceData[i].value
                }));
                var $option = $("<span>");
                $option[this.options.escape ? "text" : "html"](" " + this.sourceData[i].text);
                $label.append($option);
                $("<div>").append($label).appendTo(this.$tpl);
            }
            this.$input = this.$tpl.find('input[type="checkbox"]');
            this.setClass();
        },
        value2str: function(value) {
            return $.isArray(value) ? value.sort().join($.trim(this.options.separator)) : "";
        },
        str2value: function(str) {
            var reg, value = null;
            if (typeof str === "string" && str.length) {
                reg = new RegExp("\\s*" + $.trim(this.options.separator) + "\\s*");
                value = str.split(reg);
            } else if ($.isArray(str)) {
                value = str;
            } else {
                value = [ str ];
            }
            return value;
        },
        value2input: function(value) {
            this.$input.prop("checked", false);
            if ($.isArray(value) && value.length) {
                this.$input.each(function(i, el) {
                    var $el = $(el);
                    $.each(value, function(j, val) {
                        if ($el.val() == val) {
                            $el.prop("checked", true);
                        }
                    });
                });
            }
        },
        input2value: function() {
            var checked = [];
            this.$input.filter(":checked").each(function(i, el) {
                checked.push($(el).val());
            });
            return checked;
        },
        value2htmlFinal: function(value, element) {
            var html = [], checked = $.fn.editableutils.itemsByValue(value, this.sourceData), escape = this.options.escape;
            if (checked.length) {
                $.each(checked, function(i, v) {
                    var text = escape ? $.fn.editableutils.escape(v.text) : v.text;
                    html.push(text);
                });
                $(element).html(html.join("<br>"));
            } else {
                $(element).empty();
            }
        },
        activate: function() {
            this.$input.first().focus();
        },
        autosubmit: function() {
            this.$input.on("keydown", function(e) {
                if (e.which === 13) {
                    $(this).closest("form").submit();
                }
            });
        }
    });
    Checklist.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {
        tpl: '<div class="editable-checklist"></div>',
        inputclass: null,
        separator: ","
    });
    $.fn.editabletypes.checklist = Checklist;
})(window.jQuery);

(function($) {
    "use strict";
    var Password = function(options) {
        this.init("password", options, Password.defaults);
    };
    $.fn.editableutils.inherit(Password, $.fn.editabletypes.text);
    $.extend(Password.prototype, {
        value2html: function(value, element) {
            if (value) {
                $(element).text("[hidden]");
            } else {
                $(element).empty();
            }
        },
        html2value: function(html) {
            return null;
        }
    });
    Password.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
        tpl: '<input type="password">'
    });
    $.fn.editabletypes.password = Password;
})(window.jQuery);

(function($) {
    "use strict";
    var Email = function(options) {
        this.init("email", options, Email.defaults);
    };
    $.fn.editableutils.inherit(Email, $.fn.editabletypes.text);
    Email.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
        tpl: '<input type="email">'
    });
    $.fn.editabletypes.email = Email;
})(window.jQuery);

(function($) {
    "use strict";
    var Url = function(options) {
        this.init("url", options, Url.defaults);
    };
    $.fn.editableutils.inherit(Url, $.fn.editabletypes.text);
    Url.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
        tpl: '<input type="url">'
    });
    $.fn.editabletypes.url = Url;
})(window.jQuery);

(function($) {
    "use strict";
    var Tel = function(options) {
        this.init("tel", options, Tel.defaults);
    };
    $.fn.editableutils.inherit(Tel, $.fn.editabletypes.text);
    Tel.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
        tpl: '<input type="tel">'
    });
    $.fn.editabletypes.tel = Tel;
})(window.jQuery);

(function($) {
    "use strict";
    var NumberInput = function(options) {
        this.init("number", options, NumberInput.defaults);
    };
    $.fn.editableutils.inherit(NumberInput, $.fn.editabletypes.text);
    $.extend(NumberInput.prototype, {
        render: function() {
            NumberInput.superclass.render.call(this);
            this.setAttr("min");
            this.setAttr("max");
            this.setAttr("step");
        },
        postrender: function() {
            if (this.$clear) {
                this.$clear.css({
                    right: 24
                });
            }
        }
    });
    NumberInput.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {
        tpl: '<input type="number">',
        inputclass: "input-mini",
        min: null,
        max: null,
        step: null
    });
    $.fn.editabletypes.number = NumberInput;
})(window.jQuery);

(function($) {
    "use strict";
    var Range = function(options) {
        this.init("range", options, Range.defaults);
    };
    $.fn.editableutils.inherit(Range, $.fn.editabletypes.number);
    $.extend(Range.prototype, {
        render: function() {
            this.$input = this.$tpl.filter("input");
            this.setClass();
            this.setAttr("min");
            this.setAttr("max");
            this.setAttr("step");
            this.$input.on("input", function() {
                $(this).siblings("output").text($(this).val());
            });
        },
        activate: function() {
            this.$input.focus();
        }
    });
    Range.defaults = $.extend({}, $.fn.editabletypes.number.defaults, {
        tpl: '<input type="range"><output style="width: 30px; display: inline-block"></output>',
        inputclass: "input-medium"
    });
    $.fn.editabletypes.range = Range;
})(window.jQuery);

(function($) {
    "use strict";
    var Time = function(options) {
        this.init("time", options, Time.defaults);
    };
    $.fn.editableutils.inherit(Time, $.fn.editabletypes.abstractinput);
    $.extend(Time.prototype, {
        render: function() {
            this.setClass();
        }
    });
    Time.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
        tpl: '<input type="time">'
    });
    $.fn.editabletypes.time = Time;
})(window.jQuery);

(function($) {
    "use strict";
    var Constructor = function(options) {
        this.init("select2", options, Constructor.defaults);
        options.select2 = options.select2 || {};
        this.sourceData = null;
        if (options.placeholder) {
            options.select2.placeholder = options.placeholder;
        }
        if (!options.select2.tags && options.source) {
            var source = options.source;
            if ($.isFunction(options.source)) {
                source = options.source.call(options.scope);
            }
            if (typeof source === "string") {
                options.select2.ajax = options.select2.ajax || {};
                if (!options.select2.ajax.data) {
                    options.select2.ajax.data = function(term) {
                        return {
                            query: term
                        };
                    };
                }
                if (!options.select2.ajax.results) {
                    options.select2.ajax.results = function(data) {
                        return {
                            results: data
                        };
                    };
                }
                options.select2.ajax.url = source;
            } else {
                this.sourceData = this.convertSource(source);
                options.select2.data = this.sourceData;
            }
        }
        this.options.select2 = $.extend({}, Constructor.defaults.select2, options.select2);
        this.isMultiple = this.options.select2.tags || this.options.select2.multiple;
        this.isRemote = "ajax" in this.options.select2;
        this.idFunc = this.options.select2.id;
        if (typeof this.idFunc !== "function") {
            var idKey = this.idFunc || "id";
            this.idFunc = function(e) {
                return e[idKey];
            };
        }
        this.formatSelection = this.options.select2.formatSelection;
        if (typeof this.formatSelection !== "function") {
            this.formatSelection = function(e) {
                return e.text;
            };
        }
    };
    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);
    $.extend(Constructor.prototype, {
        render: function() {
            this.setClass();
            if (this.isRemote) {
                this.$input.on("select2-loaded", $.proxy(function(e) {
                    this.sourceData = e.items.results;
                }, this));
            }
            if (this.isMultiple) {
                this.$input.on("change", function() {
                    $(this).closest("form").parent().triggerHandler("resize");
                });
            }
        },
        value2html: function(value, element) {
            var text = "", data, that = this;
            if (this.options.select2.tags) {
                data = value;
            } else if (this.sourceData) {
                data = $.fn.editableutils.itemsByValue(value, this.sourceData, this.idFunc);
            } else {}
            if ($.isArray(data)) {
                text = [];
                $.each(data, function(k, v) {
                    text.push(v && typeof v === "object" ? that.formatSelection(v) : v);
                });
            } else if (data) {
                text = that.formatSelection(data);
            }
            text = $.isArray(text) ? text.join(this.options.viewseparator) : text;
            Constructor.superclass.value2html.call(this, text, element);
        },
        html2value: function(html) {
            return this.options.select2.tags ? this.str2value(html, this.options.viewseparator) : null;
        },
        value2input: function(value) {
            if ($.isArray(value)) {
                value = value.join(this.getSeparator());
            }
            if (!this.$input.data("select2")) {
                this.$input.val(value);
                this.$input.select2(this.options.select2);
            } else {
                this.$input.val(value).trigger("change", true);
            }
            if (this.isRemote && !this.isMultiple && !this.options.select2.initSelection) {
                var customId = this.options.select2.id, customText = this.options.select2.formatSelection;
                if (!customId && !customText) {
                    var $el = $(this.options.scope);
                    if (!$el.data("editable").isEmpty) {
                        var data = {
                            id: value,
                            text: $el.text()
                        };
                        this.$input.select2("data", data);
                    }
                }
            }
        },
        input2value: function() {
            return this.$input.select2("val");
        },
        str2value: function(str, separator) {
            if (typeof str !== "string" || !this.isMultiple) {
                return str;
            }
            separator = separator || this.getSeparator();
            var val, i, l;
            if (str === null || str.length < 1) {
                return null;
            }
            val = str.split(separator);
            for (i = 0, l = val.length; i < l; i = i + 1) {
                val[i] = $.trim(val[i]);
            }
            return val;
        },
        autosubmit: function() {
            this.$input.on("change", function(e, isInitial) {
                if (!isInitial) {
                    $(this).closest("form").submit();
                }
            });
        },
        getSeparator: function() {
            return this.options.select2.separator || $.fn.select2.defaults.separator;
        },
        convertSource: function(source) {
            if ($.isArray(source) && source.length && source[0].value !== undefined) {
                for (var i = 0; i < source.length; i++) {
                    if (source[i].value !== undefined) {
                        source[i].id = source[i].value;
                        delete source[i].value;
                    }
                }
            }
            return source;
        },
        destroy: function() {
            if (this.$input.data("select2")) {
                this.$input.select2("destroy");
            }
        }
    });
    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
        tpl: '<input type="hidden">',
        select2: null,
        placeholder: null,
        source: null,
        viewseparator: ", "
    });
    $.fn.editabletypes.select2 = Constructor;
})(window.jQuery);

(function($) {
    var Combodate = function(element, options) {
        this.$element = $(element);
        if (!this.$element.is("input")) {
            $.error("Combodate should be applied to INPUT element");
            return;
        }
        this.options = $.extend({}, $.fn.combodate.defaults, options, this.$element.data());
        this.init();
    };
    Combodate.prototype = {
        constructor: Combodate,
        init: function() {
            this.map = {
                day: [ "D", "date" ],
                month: [ "M", "month" ],
                year: [ "Y", "year" ],
                hour: [ "[Hh]", "hours" ],
                minute: [ "m", "minutes" ],
                second: [ "s", "seconds" ],
                ampm: [ "[Aa]", "" ]
            };
            this.$widget = $('<span class="combodate"></span>').html(this.getTemplate());
            this.initCombos();
            this.$widget.on("change", "select", $.proxy(function(e) {
                this.$element.val(this.getValue()).change();
                if (this.options.smartDays) {
                    if ($(e.target).is(".month") || $(e.target).is(".year")) {
                        this.fillCombo("day");
                    }
                }
            }, this));
            this.$widget.find("select").css("width", "auto");
            this.$element.hide().after(this.$widget);
            this.setValue(this.$element.val() || this.options.value);
        },
        getTemplate: function() {
            var tpl = this.options.template;
            $.each(this.map, function(k, v) {
                v = v[0];
                var r = new RegExp(v + "+"), token = v.length > 1 ? v.substring(1, 2) : v;
                tpl = tpl.replace(r, "{" + token + "}");
            });
            tpl = tpl.replace(/ /g, "&nbsp;");
            $.each(this.map, function(k, v) {
                v = v[0];
                var token = v.length > 1 ? v.substring(1, 2) : v;
                tpl = tpl.replace("{" + token + "}", '<select class="' + k + '"></select>');
            });
            return tpl;
        },
        initCombos: function() {
            for (var k in this.map) {
                var $c = this.$widget.find("." + k);
                this["$" + k] = $c.length ? $c : null;
                this.fillCombo(k);
            }
        },
        fillCombo: function(k) {
            var $combo = this["$" + k];
            if (!$combo) {
                return;
            }
            var f = "fill" + k.charAt(0).toUpperCase() + k.slice(1);
            var items = this[f]();
            var value = $combo.val();
            $combo.empty();
            for (var i = 0; i < items.length; i++) {
                $combo.append('<option value="' + items[i][0] + '">' + items[i][1] + "</option>");
            }
            $combo.val(value);
        },
        fillCommon: function(key) {
            var values = [], relTime;
            if (this.options.firstItem === "name") {
                relTime = moment.relativeTime || moment.langData()._relativeTime;
                var header = typeof relTime[key] === "function" ? relTime[key](1, true, key, false) : relTime[key];
                header = header.split(" ").reverse()[0];
                values.push([ "", header ]);
            } else if (this.options.firstItem === "empty") {
                values.push([ "", "" ]);
            }
            return values;
        },
        fillDay: function() {
            var items = this.fillCommon("d"), name, i, twoDigit = this.options.template.indexOf("DD") !== -1, daysCount = 31;
            if (this.options.smartDays && this.$month && this.$year) {
                var month = parseInt(this.$month.val(), 10);
                var year = parseInt(this.$year.val(), 10);
                if (!isNaN(month) && !isNaN(year)) {
                    daysCount = moment([ year, month ]).daysInMonth();
                }
            }
            for (i = 1; i <= daysCount; i++) {
                name = twoDigit ? this.leadZero(i) : i;
                items.push([ i, name ]);
            }
            return items;
        },
        fillMonth: function() {
            var items = this.fillCommon("M"), name, i, longNames = this.options.template.indexOf("MMMM") !== -1, shortNames = this.options.template.indexOf("MMM") !== -1, twoDigit = this.options.template.indexOf("MM") !== -1;
            for (i = 0; i <= 11; i++) {
                if (longNames) {
                    name = moment().date(1).month(i).format("MMMM");
                } else if (shortNames) {
                    name = moment().date(1).month(i).format("MMM");
                } else if (twoDigit) {
                    name = this.leadZero(i + 1);
                } else {
                    name = i + 1;
                }
                items.push([ i, name ]);
            }
            return items;
        },
        fillYear: function() {
            var items = [], name, i, longNames = this.options.template.indexOf("YYYY") !== -1;
            for (i = this.options.maxYear; i >= this.options.minYear; i--) {
                name = longNames ? i : (i + "").substring(2);
                items[this.options.yearDescending ? "push" : "unshift"]([ i, name ]);
            }
            items = this.fillCommon("y").concat(items);
            return items;
        },
        fillHour: function() {
            var items = this.fillCommon("h"), name, i, h12 = this.options.template.indexOf("h") !== -1, h24 = this.options.template.indexOf("H") !== -1, twoDigit = this.options.template.toLowerCase().indexOf("hh") !== -1, min = h12 ? 1 : 0, max = h12 ? 12 : 23;
            for (i = min; i <= max; i++) {
                name = twoDigit ? this.leadZero(i) : i;
                items.push([ i, name ]);
            }
            return items;
        },
        fillMinute: function() {
            var items = this.fillCommon("m"), name, i, twoDigit = this.options.template.indexOf("mm") !== -1;
            for (i = 0; i <= 59; i += this.options.minuteStep) {
                name = twoDigit ? this.leadZero(i) : i;
                items.push([ i, name ]);
            }
            return items;
        },
        fillSecond: function() {
            var items = this.fillCommon("s"), name, i, twoDigit = this.options.template.indexOf("ss") !== -1;
            for (i = 0; i <= 59; i += this.options.secondStep) {
                name = twoDigit ? this.leadZero(i) : i;
                items.push([ i, name ]);
            }
            return items;
        },
        fillAmpm: function() {
            var ampmL = this.options.template.indexOf("a") !== -1, ampmU = this.options.template.indexOf("A") !== -1, items = [ [ "am", ampmL ? "am" : "AM" ], [ "pm", ampmL ? "pm" : "PM" ] ];
            return items;
        },
        getValue: function(format) {
            var dt, values = {}, that = this, notSelected = false;
            $.each(this.map, function(k, v) {
                if (k === "ampm") {
                    return;
                }
                var def = k === "day" ? 1 : 0;
                values[k] = that["$" + k] ? parseInt(that["$" + k].val(), 10) : def;
                if (isNaN(values[k])) {
                    notSelected = true;
                    return false;
                }
            });
            if (notSelected) {
                return "";
            }
            if (this.$ampm) {
                if (values.hour === 12) {
                    values.hour = this.$ampm.val() === "am" ? 0 : 12;
                } else {
                    values.hour = this.$ampm.val() === "am" ? values.hour : values.hour + 12;
                }
            }
            dt = moment([ values.year, values.month, values.day, values.hour, values.minute, values.second ]);
            this.highlight(dt);
            format = format === undefined ? this.options.format : format;
            if (format === null) {
                return dt.isValid() ? dt : null;
            } else {
                return dt.isValid() ? dt.format(format) : "";
            }
        },
        setValue: function(value) {
            if (!value) {
                return;
            }
            var dt = typeof value === "string" ? moment(value, this.options.format) : moment(value), that = this, values = {};
            function getNearest($select, value) {
                var delta = {};
                $select.children("option").each(function(i, opt) {
                    var optValue = $(opt).attr("value"), distance;
                    if (optValue === "") return;
                    distance = Math.abs(optValue - value);
                    if (typeof delta.distance === "undefined" || distance < delta.distance) {
                        delta = {
                            value: optValue,
                            distance: distance
                        };
                    }
                });
                return delta.value;
            }
            if (dt.isValid()) {
                $.each(this.map, function(k, v) {
                    if (k === "ampm") {
                        return;
                    }
                    values[k] = dt[v[1]]();
                });
                if (this.$ampm) {
                    if (values.hour >= 12) {
                        values.ampm = "pm";
                        if (values.hour > 12) {
                            values.hour -= 12;
                        }
                    } else {
                        values.ampm = "am";
                        if (values.hour === 0) {
                            values.hour = 12;
                        }
                    }
                }
                $.each(values, function(k, v) {
                    if (that["$" + k]) {
                        if (k === "minute" && that.options.minuteStep > 1 && that.options.roundTime) {
                            v = getNearest(that["$" + k], v);
                        }
                        if (k === "second" && that.options.secondStep > 1 && that.options.roundTime) {
                            v = getNearest(that["$" + k], v);
                        }
                        that["$" + k].val(v);
                    }
                });
                if (this.options.smartDays) {
                    this.fillCombo("day");
                }
                this.$element.val(dt.format(this.options.format)).change();
            }
        },
        highlight: function(dt) {
            if (!dt.isValid()) {
                if (this.options.errorClass) {
                    this.$widget.addClass(this.options.errorClass);
                } else {
                    if (!this.borderColor) {
                        this.borderColor = this.$widget.find("select").css("border-color");
                    }
                    this.$widget.find("select").css("border-color", "red");
                }
            } else {
                if (this.options.errorClass) {
                    this.$widget.removeClass(this.options.errorClass);
                } else {
                    this.$widget.find("select").css("border-color", this.borderColor);
                }
            }
        },
        leadZero: function(v) {
            return v <= 9 ? "0" + v : v;
        },
        destroy: function() {
            this.$widget.remove();
            this.$element.removeData("combodate").show();
        }
    };
    $.fn.combodate = function(option) {
        var d, args = Array.apply(null, arguments);
        args.shift();
        if (option === "getValue" && this.length && (d = this.eq(0).data("combodate"))) {
            return d.getValue.apply(d, args);
        }
        return this.each(function() {
            var $this = $(this), data = $this.data("combodate"), options = typeof option == "object" && option;
            if (!data) {
                $this.data("combodate", data = new Combodate(this, options));
            }
            if (typeof option == "string" && typeof data[option] == "function") {
                data[option].apply(data, args);
            }
        });
    };
    $.fn.combodate.defaults = {
        format: "DD-MM-YYYY HH:mm",
        template: "D / MMM / YYYY   H : mm",
        value: null,
        minYear: 1970,
        maxYear: 2015,
        yearDescending: true,
        minuteStep: 5,
        secondStep: 1,
        firstItem: "empty",
        errorClass: null,
        roundTime: true,
        smartDays: false
    };
})(window.jQuery);

(function($) {
    "use strict";
    var Constructor = function(options) {
        this.init("combodate", options, Constructor.defaults);
        if (!this.options.viewformat) {
            this.options.viewformat = this.options.format;
        }
        options.combodate = $.fn.editableutils.tryParseJson(options.combodate, true);
        this.options.combodate = $.extend({}, Constructor.defaults.combodate, options.combodate, {
            format: this.options.format,
            template: this.options.template
        });
    };
    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);
    $.extend(Constructor.prototype, {
        render: function() {
            this.$input.combodate(this.options.combodate);
            if ($.fn.editableform.engine === "bs3") {
                this.$input.siblings().find("select").addClass("form-control");
            }
            if (this.options.inputclass) {
                this.$input.siblings().find("select").addClass(this.options.inputclass);
            }
        },
        value2html: function(value, element) {
            var text = value ? value.format(this.options.viewformat) : "";
            Constructor.superclass.value2html.call(this, text, element);
        },
        html2value: function(html) {
            return html ? moment(html, this.options.viewformat) : null;
        },
        value2str: function(value) {
            return value ? value.format(this.options.format) : "";
        },
        str2value: function(str) {
            return str ? moment(str, this.options.format) : null;
        },
        value2submit: function(value) {
            return this.value2str(value);
        },
        value2input: function(value) {
            this.$input.combodate("setValue", value);
        },
        input2value: function() {
            return this.$input.combodate("getValue", null);
        },
        activate: function() {
            this.$input.siblings(".combodate").find("select").eq(0).focus();
        },
        autosubmit: function() {}
    });
    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
        tpl: '<input type="text">',
        inputclass: null,
        format: "YYYY-MM-DD",
        viewformat: null,
        template: "D / MMM / YYYY",
        combodate: null
    });
    $.fn.editabletypes.combodate = Constructor;
})(window.jQuery);

(function($) {
    "use strict";
    $.extend($.fn.editableContainer.Popup.prototype, {
        containerName: "poshytip",
        innerCss: "div.tip-inner",
        defaults: $.fn.poshytip.defaults,
        initContainer: function() {
            this.handlePlacement();
            $.extend(this.containerOptions, {
                showOn: "none",
                content: "",
                alignTo: "target"
            });
            this.call(this.containerOptions);
        },
        show: function(closeAll) {
            this.$element.addClass("editable-open");
            if (closeAll !== false) {
                this.closeOthers(this.$element[0]);
            }
            this.$form = $("<div>");
            this.renderForm();
            var $label = $("<label>").text(this.options.title || this.$element.data("title") || this.$element.data("originalTitle")), $content = $("<div>").append($label).append(this.$form);
            this.call("update", $content);
            this.call("show");
            this.tip().addClass(this.containerClass);
            this.$form.data("editableform").input.activate();
        },
        innerHide: function() {
            this.call("hide");
        },
        innerDestroy: function() {
            this.call("destroy");
        },
        setPosition: function() {
            this.container().refresh(false);
        },
        handlePlacement: function() {
            var x, y, ox = 0, oy = 0;
            switch (this.options.placement) {
              case "top":
                x = "center";
                y = "top";
                oy = 5;
                break;

              case "right":
                x = "right";
                y = "center";
                ox = 10;
                break;

              case "bottom":
                x = "center";
                y = "bottom";
                oy = 5;
                break;

              case "left":
                x = "left";
                y = "center";
                ox = 10;
                break;
            }
            $.extend(this.containerOptions, {
                alignX: x,
                offsetX: ox,
                alignY: y,
                offsetY: oy
            });
        }
    });
    $.fn.editableContainer.defaults = $.extend({}, $.fn.editableContainer.defaults, {
        className: "tip-yellowsimple"
    });
    if ($.Poshytip) {
        var tips = [], reBgImage = /^url\(["']?([^"'\)]*)["']?\);?$/i, rePNG = /\.png$/i, ie6 = !!window.createPopup && document.documentElement.currentStyle.minWidth == "undefined";
        $.Poshytip.prototype.refresh = function(async) {
            if (this.disabled) return;
            var currPos;
            if (async) {
                if (!this.$tip.data("active")) return;
                currPos = {
                    left: this.$tip.css("left"),
                    top: this.$tip.css("top")
                };
            }
            this.$tip.css({
                left: 0,
                top: 0
            }).appendTo(document.body);
            if (this.opacity === undefined) this.opacity = this.$tip.css("opacity");
            var bgImage = this.$tip.css("background-image").match(reBgImage), arrow = this.$arrow.css("background-image").match(reBgImage);
            if (bgImage) {
                var bgImagePNG = rePNG.test(bgImage[1]);
                if (ie6 && bgImagePNG) {
                    this.$tip.css("background-image", "none");
                    this.$inner.css({
                        margin: 0,
                        border: 0,
                        padding: 0
                    });
                    bgImage = bgImagePNG = false;
                } else {
                    this.$tip.prepend('<table class="fallback" border="0" cellpadding="0" cellspacing="0"><tr><td class="tip-top tip-bg-image" colspan="2"><span></span></td><td class="tip-right tip-bg-image" rowspan="2"><span></span></td></tr><tr><td class="tip-left tip-bg-image" rowspan="2"><span></span></td><td></td></tr><tr><td class="tip-bottom tip-bg-image" colspan="2"><span></span></td></tr></table>').css({
                        border: 0,
                        padding: 0,
                        "background-image": "none",
                        "background-color": "transparent"
                    }).find(".tip-bg-image").css("background-image", 'url("' + bgImage[1] + '")').end().find("td").eq(3).append(this.$inner);
                }
                if (bgImagePNG && !$.support.opacity) this.opts.fade = false;
            }
            if (arrow && !$.support.opacity) {
                if (ie6 && rePNG.test(arrow[1])) {
                    arrow = false;
                    this.$arrow.css("background-image", "none");
                }
                this.opts.fade = false;
            }
            var $table = this.$tip.find("table.fallback");
            if (ie6) {
                this.$tip[0].style.width = "";
                $table.width("auto").find("td").eq(3).width("auto");
                var tipW = this.$tip.width(), minW = parseInt(this.$tip.css("min-width"), 10), maxW = parseInt(this.$tip.css("max-width"), 10);
                if (!isNaN(minW) && tipW < minW) tipW = minW; else if (!isNaN(maxW) && tipW > maxW) tipW = maxW;
                this.$tip.add($table).width(tipW).eq(0).find("td").eq(3).width("100%");
            } else if ($table[0]) {
                $table.width("auto").find("td").eq(3).width("auto").end().end().width(document.defaultView && document.defaultView.getComputedStyle && parseFloat(document.defaultView.getComputedStyle(this.$tip[0], null).width) || this.$tip.width()).find("td").eq(3).width("100%");
            }
            this.tipOuterW = this.$tip.outerWidth();
            this.tipOuterH = this.$tip.outerHeight();
            this.calcPos();
            if (arrow && this.pos.arrow) {
                this.$arrow[0].className = "tip-arrow tip-arrow-" + this.pos.arrow;
                this.$arrow.css("visibility", "inherit");
            }
            if (async) {
                this.asyncAnimating = true;
                var self = this;
                this.$tip.css(currPos).animate({
                    left: this.pos.l,
                    top: this.pos.t
                }, 200, function() {
                    self.asyncAnimating = false;
                });
            } else {
                this.$tip.css({
                    left: this.pos.l,
                    top: this.pos.t
                });
            }
        };
    }
})(window.jQuery);

(function($) {
    "use strict";
    var DateUI = function(options) {
        this.init("dateui", options, DateUI.defaults);
        this.initPicker(options, DateUI.defaults);
    };
    $.fn.editableutils.inherit(DateUI, $.fn.editabletypes.abstractinput);
    $.extend(DateUI.prototype, {
        initPicker: function(options, defaults) {
            if (!this.options.viewformat) {
                this.options.viewformat = this.options.format;
            }
            this.options.viewformat = this.options.viewformat.replace("yyyy", "yy");
            this.options.format = this.options.format.replace("yyyy", "yy");
            this.options.datepicker = $.extend({}, defaults.datepicker, options.datepicker, {
                dateFormat: this.options.viewformat
            });
        },
        render: function() {
            this.$input.datepicker(this.options.datepicker);
            if (this.options.clear) {
                this.$clear = $('<a href="#"></a>').html(this.options.clear).click($.proxy(function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.clear();
                }, this));
                this.$tpl.parent().append($('<div class="editable-clear">').append(this.$clear));
            }
        },
        value2html: function(value, element) {
            var text = $.datepicker.formatDate(this.options.viewformat, value);
            DateUI.superclass.value2html.call(this, text, element);
        },
        html2value: function(html) {
            if (typeof html !== "string") {
                return html;
            }
            var d;
            try {
                d = $.datepicker.parseDate(this.options.viewformat, html);
            } catch (e) {}
            return d;
        },
        value2str: function(value) {
            return $.datepicker.formatDate(this.options.format, value);
        },
        str2value: function(str) {
            if (typeof str !== "string") {
                return str;
            }
            var d;
            try {
                d = $.datepicker.parseDate(this.options.format, str);
            } catch (e) {}
            return d;
        },
        value2submit: function(value) {
            return this.value2str(value);
        },
        value2input: function(value) {
            this.$input.datepicker("setDate", value);
        },
        input2value: function() {
            return this.$input.datepicker("getDate");
        },
        activate: function() {},
        clear: function() {
            this.$input.datepicker("setDate", null);
            if (this.isAutosubmit) {
                this.submit();
            }
        },
        autosubmit: function() {
            this.isAutosubmit = true;
            this.$input.on("mouseup", "table.ui-datepicker-calendar a.ui-state-default", $.proxy(this.submit, this));
        },
        submit: function() {
            var $form = this.$input.closest("form");
            setTimeout(function() {
                $form.submit();
            }, 200);
        }
    });
    DateUI.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {
        tpl: '<div class="editable-date"></div>',
        inputclass: null,
        format: "yyyy-mm-dd",
        viewformat: null,
        datepicker: {
            firstDay: 0,
            changeYear: true,
            changeMonth: true,
            showOtherMonths: true
        },
        clear: "&times; clear"
    });
    $.fn.editabletypes.dateui = DateUI;
})(window.jQuery);

(function($) {
    "use strict";
    var DateUIField = function(options) {
        this.init("dateuifield", options, DateUIField.defaults);
        this.initPicker(options, DateUIField.defaults);
    };
    $.fn.editableutils.inherit(DateUIField, $.fn.editabletypes.dateui);
    $.extend(DateUIField.prototype, {
        render: function() {
            this.$input.datepicker(this.options.datepicker);
            $.fn.editabletypes.text.prototype.renderClear.call(this);
        },
        value2input: function(value) {
            this.$input.val($.datepicker.formatDate(this.options.viewformat, value));
        },
        input2value: function() {
            return this.html2value(this.$input.val());
        },
        activate: function() {
            $.fn.editabletypes.text.prototype.activate.call(this);
        },
        toggleClear: function() {
            $.fn.editabletypes.text.prototype.toggleClear.call(this);
        },
        autosubmit: function() {}
    });
    DateUIField.defaults = $.extend({}, $.fn.editabletypes.dateui.defaults, {
        tpl: '<input type="text"/>',
        inputclass: null,
        datepicker: {
            showOn: "button",
            buttonImage: "http://jqueryui.com/resources/demos/datepicker/images/calendar.gif",
            buttonImageOnly: true,
            firstDay: 0,
            changeYear: true,
            changeMonth: true,
            showOtherMonths: true
        },
        clear: false
    });
    $.fn.editabletypes.dateuifield = DateUIField;
})(window.jQuery);

(function(window, document, undefined) {
    var oldL = window.L, L = {};
    L.version = "0.7.3";
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = L;
    } else if (typeof define === "function" && define.amd) {
        define(L);
    }
    L.noConflict = function() {
        window.L = oldL;
        return this;
    };
    window.L = L;
    L.Util = {
        extend: function(dest) {
            var sources = Array.prototype.slice.call(arguments, 1), i, j, len, src;
            for (j = 0, len = sources.length; j < len; j++) {
                src = sources[j] || {};
                for (i in src) {
                    if (src.hasOwnProperty(i)) {
                        dest[i] = src[i];
                    }
                }
            }
            return dest;
        },
        bind: function(fn, obj) {
            var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
            return function() {
                return fn.apply(obj, args || arguments);
            };
        },
        stamp: function() {
            var lastId = 0, key = "_leaflet_id";
            return function(obj) {
                obj[key] = obj[key] || ++lastId;
                return obj[key];
            };
        }(),
        invokeEach: function(obj, method, context) {
            var i, args;
            if (typeof obj === "object") {
                args = Array.prototype.slice.call(arguments, 3);
                for (i in obj) {
                    method.apply(context, [ i, obj[i] ].concat(args));
                }
                return true;
            }
            return false;
        },
        limitExecByInterval: function(fn, time, context) {
            var lock, execOnUnlock;
            return function wrapperFn() {
                var args = arguments;
                if (lock) {
                    execOnUnlock = true;
                    return;
                }
                lock = true;
                setTimeout(function() {
                    lock = false;
                    if (execOnUnlock) {
                        wrapperFn.apply(context, args);
                        execOnUnlock = false;
                    }
                }, time);
                fn.apply(context, args);
            };
        },
        falseFn: function() {
            return false;
        },
        formatNum: function(num, digits) {
            var pow = Math.pow(10, digits || 5);
            return Math.round(num * pow) / pow;
        },
        trim: function(str) {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
        },
        splitWords: function(str) {
            return L.Util.trim(str).split(/\s+/);
        },
        setOptions: function(obj, options) {
            obj.options = L.extend({}, obj.options, options);
            return obj.options;
        },
        getParamString: function(obj, existingUrl, uppercase) {
            var params = [];
            for (var i in obj) {
                params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
            }
            return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        },
        template: function(str, data) {
            return str.replace(/\{ *([\w_]+) *\}/g, function(str, key) {
                var value = data[key];
                if (value === undefined) {
                    throw new Error("No value provided for variable " + str);
                } else if (typeof value === "function") {
                    value = value(data);
                }
                return value;
            });
        },
        isArray: Array.isArray || function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
        },
        emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
    };
    (function() {
        function getPrefixed(name) {
            var i, fn, prefixes = [ "webkit", "moz", "o", "ms" ];
            for (i = 0; i < prefixes.length && !fn; i++) {
                fn = window[prefixes[i] + name];
            }
            return fn;
        }
        var lastTime = 0;
        function timeoutDefer(fn) {
            var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
            lastTime = time + timeToCall;
            return window.setTimeout(fn, timeToCall);
        }
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
            window.clearTimeout(id);
        };
        L.Util.requestAnimFrame = function(fn, context, immediate, element) {
            fn = L.bind(fn, context);
            if (immediate && requestFn === timeoutDefer) {
                fn();
            } else {
                return requestFn.call(window, fn, element);
            }
        };
        L.Util.cancelAnimFrame = function(id) {
            if (id) {
                cancelFn.call(window, id);
            }
        };
    })();
    L.extend = L.Util.extend;
    L.bind = L.Util.bind;
    L.stamp = L.Util.stamp;
    L.setOptions = L.Util.setOptions;
    L.Class = function() {};
    L.Class.extend = function(props) {
        var NewClass = function() {
            if (this.initialize) {
                this.initialize.apply(this, arguments);
            }
            if (this._initHooks) {
                this.callInitHooks();
            }
        };
        var F = function() {};
        F.prototype = this.prototype;
        var proto = new F();
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        for (var i in this) {
            if (this.hasOwnProperty(i) && i !== "prototype") {
                NewClass[i] = this[i];
            }
        }
        if (props.statics) {
            L.extend(NewClass, props.statics);
            delete props.statics;
        }
        if (props.includes) {
            L.Util.extend.apply(null, [ proto ].concat(props.includes));
            delete props.includes;
        }
        if (props.options && proto.options) {
            props.options = L.extend({}, proto.options, props.options);
        }
        L.extend(proto, props);
        proto._initHooks = [];
        var parent = this;
        NewClass.__super__ = parent.prototype;
        proto.callInitHooks = function() {
            if (this._initHooksCalled) {
                return;
            }
            if (parent.prototype.callInitHooks) {
                parent.prototype.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                proto._initHooks[i].call(this);
            }
        };
        return NewClass;
    };
    L.Class.include = function(props) {
        L.extend(this.prototype, props);
    };
    L.Class.mergeOptions = function(options) {
        L.extend(this.prototype.options, options);
    };
    L.Class.addInitHook = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        var init = typeof fn === "function" ? fn : function() {
            this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
    };
    var eventsKey = "_leaflet_events";
    L.Mixin = {};
    L.Mixin.Events = {
        addEventListener: function(types, fn, context) {
            if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) {
                return this;
            }
            var events = this[eventsKey] = this[eventsKey] || {}, contextId = context && context !== this && L.stamp(context), i, len, event, type, indexKey, indexLenKey, typeIndex;
            types = L.Util.splitWords(types);
            for (i = 0, len = types.length; i < len; i++) {
                event = {
                    action: fn,
                    context: context || this
                };
                type = types[i];
                if (contextId) {
                    indexKey = type + "_idx";
                    indexLenKey = indexKey + "_len";
                    typeIndex = events[indexKey] = events[indexKey] || {};
                    if (!typeIndex[contextId]) {
                        typeIndex[contextId] = [];
                        events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                    }
                    typeIndex[contextId].push(event);
                } else {
                    events[type] = events[type] || [];
                    events[type].push(event);
                }
            }
            return this;
        },
        hasEventListeners: function(type) {
            var events = this[eventsKey];
            return !!events && (type in events && events[type].length > 0 || type + "_idx" in events && events[type + "_idx_len"] > 0);
        },
        removeEventListener: function(types, fn, context) {
            if (!this[eventsKey]) {
                return this;
            }
            if (!types) {
                return this.clearAllEventListeners();
            }
            if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) {
                return this;
            }
            var events = this[eventsKey], contextId = context && context !== this && L.stamp(context), i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;
            types = L.Util.splitWords(types);
            for (i = 0, len = types.length; i < len; i++) {
                type = types[i];
                indexKey = type + "_idx";
                indexLenKey = indexKey + "_len";
                typeIndex = events[indexKey];
                if (!fn) {
                    delete events[type];
                    delete events[indexKey];
                    delete events[indexLenKey];
                } else {
                    listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];
                    if (listeners) {
                        for (j = listeners.length - 1; j >= 0; j--) {
                            if (listeners[j].action === fn && (!context || listeners[j].context === context)) {
                                removed = listeners.splice(j, 1);
                                removed[0].action = L.Util.falseFn;
                            }
                        }
                        if (context && typeIndex && listeners.length === 0) {
                            delete typeIndex[contextId];
                            events[indexLenKey]--;
                        }
                    }
                }
            }
            return this;
        },
        clearAllEventListeners: function() {
            delete this[eventsKey];
            return this;
        },
        fireEvent: function(type, data) {
            if (!this.hasEventListeners(type)) {
                return this;
            }
            var event = L.Util.extend({}, data, {
                type: type,
                target: this
            });
            var events = this[eventsKey], listeners, i, len, typeIndex, contextId;
            if (events[type]) {
                listeners = events[type].slice();
                for (i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].action.call(listeners[i].context, event);
                }
            }
            typeIndex = events[type + "_idx"];
            for (contextId in typeIndex) {
                listeners = typeIndex[contextId].slice();
                if (listeners) {
                    for (i = 0, len = listeners.length; i < len; i++) {
                        listeners[i].action.call(listeners[i].context, event);
                    }
                }
            }
            return this;
        },
        addOneTimeEventListener: function(types, fn, context) {
            if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) {
                return this;
            }
            var handler = L.bind(function() {
                this.removeEventListener(types, fn, context).removeEventListener(types, handler, context);
            }, this);
            return this.addEventListener(types, fn, context).addEventListener(types, handler, context);
        }
    };
    L.Mixin.Events.on = L.Mixin.Events.addEventListener;
    L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
    L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
    L.Mixin.Events.fire = L.Mixin.Events.fireEvent;
    (function() {
        var ie = "ActiveXObject" in window, ielt9 = ie && !document.addEventListener, ua = navigator.userAgent.toLowerCase(), webkit = ua.indexOf("webkit") !== -1, chrome = ua.indexOf("chrome") !== -1, phantomjs = ua.indexOf("phantom") !== -1, android = ua.indexOf("android") !== -1, android23 = ua.search("android [23]") !== -1, gecko = ua.indexOf("gecko") !== -1, mobile = typeof orientation !== undefined + "", msPointer = window.navigator && window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints && !window.PointerEvent, pointer = window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints || msPointer, retina = "devicePixelRatio" in window && window.devicePixelRatio > 1 || "matchMedia" in window && window.matchMedia("(min-resolution:144dpi)") && window.matchMedia("(min-resolution:144dpi)").matches, doc = document.documentElement, ie3d = ie && "transition" in doc.style, webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23, gecko3d = "MozPerspective" in doc.style, opera3d = "OTransition" in doc.style, any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;
        var touch = !window.L_NO_TOUCH && !phantomjs && function() {
            var startName = "ontouchstart";
            if (pointer || startName in doc) {
                return true;
            }
            var div = document.createElement("div"), supported = false;
            if (!div.setAttribute) {
                return false;
            }
            div.setAttribute(startName, "return;");
            if (typeof div[startName] === "function") {
                supported = true;
            }
            div.removeAttribute(startName);
            div = null;
            return supported;
        }();
        L.Browser = {
            ie: ie,
            ielt9: ielt9,
            webkit: webkit,
            gecko: gecko && !webkit && !window.opera && !ie,
            android: android,
            android23: android23,
            chrome: chrome,
            ie3d: ie3d,
            webkit3d: webkit3d,
            gecko3d: gecko3d,
            opera3d: opera3d,
            any3d: any3d,
            mobile: mobile,
            mobileWebkit: mobile && webkit,
            mobileWebkit3d: mobile && webkit3d,
            mobileOpera: mobile && window.opera,
            touch: touch,
            msPointer: msPointer,
            pointer: pointer,
            retina: retina
        };
    })();
    L.Point = function(x, y, round) {
        this.x = round ? Math.round(x) : x;
        this.y = round ? Math.round(y) : y;
    };
    L.Point.prototype = {
        clone: function() {
            return new L.Point(this.x, this.y);
        },
        add: function(point) {
            return this.clone()._add(L.point(point));
        },
        _add: function(point) {
            this.x += point.x;
            this.y += point.y;
            return this;
        },
        subtract: function(point) {
            return this.clone()._subtract(L.point(point));
        },
        _subtract: function(point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
        },
        divideBy: function(num) {
            return this.clone()._divideBy(num);
        },
        _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
        },
        multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
        },
        round: function() {
            return this.clone()._round();
        },
        _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        },
        floor: function() {
            return this.clone()._floor();
        },
        _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        },
        distanceTo: function(point) {
            point = L.point(point);
            var x = point.x - this.x, y = point.y - this.y;
            return Math.sqrt(x * x + y * y);
        },
        equals: function(point) {
            point = L.point(point);
            return point.x === this.x && point.y === this.y;
        },
        contains: function(point) {
            point = L.point(point);
            return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
        },
        toString: function() {
            return "Point(" + L.Util.formatNum(this.x) + ", " + L.Util.formatNum(this.y) + ")";
        }
    };
    L.point = function(x, y, round) {
        if (x instanceof L.Point) {
            return x;
        }
        if (L.Util.isArray(x)) {
            return new L.Point(x[0], x[1]);
        }
        if (x === undefined || x === null) {
            return x;
        }
        return new L.Point(x, y, round);
    };
    L.Bounds = function(a, b) {
        if (!a) {
            return;
        }
        var points = b ? [ a, b ] : a;
        for (var i = 0, len = points.length; i < len; i++) {
            this.extend(points[i]);
        }
    };
    L.Bounds.prototype = {
        extend: function(point) {
            point = L.point(point);
            if (!this.min && !this.max) {
                this.min = point.clone();
                this.max = point.clone();
            } else {
                this.min.x = Math.min(point.x, this.min.x);
                this.max.x = Math.max(point.x, this.max.x);
                this.min.y = Math.min(point.y, this.min.y);
                this.max.y = Math.max(point.y, this.max.y);
            }
            return this;
        },
        getCenter: function(round) {
            return new L.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
        },
        getBottomLeft: function() {
            return new L.Point(this.min.x, this.max.y);
        },
        getTopRight: function() {
            return new L.Point(this.max.x, this.min.y);
        },
        getSize: function() {
            return this.max.subtract(this.min);
        },
        contains: function(obj) {
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof L.Point) {
                obj = L.point(obj);
            } else {
                obj = L.bounds(obj);
            }
            if (obj instanceof L.Bounds) {
                min = obj.min;
                max = obj.max;
            } else {
                min = max = obj;
            }
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
        },
        intersects: function(bounds) {
            bounds = L.bounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
        },
        isValid: function() {
            return !!(this.min && this.max);
        }
    };
    L.bounds = function(a, b) {
        if (!a || a instanceof L.Bounds) {
            return a;
        }
        return new L.Bounds(a, b);
    };
    L.Transformation = function(a, b, c, d) {
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
    };
    L.Transformation.prototype = {
        transform: function(point, scale) {
            return this._transform(point.clone(), scale);
        },
        _transform: function(point, scale) {
            scale = scale || 1;
            point.x = scale * (this._a * point.x + this._b);
            point.y = scale * (this._c * point.y + this._d);
            return point;
        },
        untransform: function(point, scale) {
            scale = scale || 1;
            return new L.Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
        }
    };
    L.DomUtil = {
        get: function(id) {
            return typeof id === "string" ? document.getElementById(id) : id;
        },
        getStyle: function(el, style) {
            var value = el.style[style];
            if (!value && el.currentStyle) {
                value = el.currentStyle[style];
            }
            if ((!value || value === "auto") && document.defaultView) {
                var css = document.defaultView.getComputedStyle(el, null);
                value = css ? css[style] : null;
            }
            return value === "auto" ? null : value;
        },
        getViewportOffset: function(element) {
            var top = 0, left = 0, el = element, docBody = document.body, docEl = document.documentElement, pos;
            do {
                top += el.offsetTop || 0;
                left += el.offsetLeft || 0;
                top += parseInt(L.DomUtil.getStyle(el, "borderTopWidth"), 10) || 0;
                left += parseInt(L.DomUtil.getStyle(el, "borderLeftWidth"), 10) || 0;
                pos = L.DomUtil.getStyle(el, "position");
                if (el.offsetParent === docBody && pos === "absolute") {
                    break;
                }
                if (pos === "fixed") {
                    top += docBody.scrollTop || docEl.scrollTop || 0;
                    left += docBody.scrollLeft || docEl.scrollLeft || 0;
                    break;
                }
                if (pos === "relative" && !el.offsetLeft) {
                    var width = L.DomUtil.getStyle(el, "width"), maxWidth = L.DomUtil.getStyle(el, "max-width"), r = el.getBoundingClientRect();
                    if (width !== "none" || maxWidth !== "none") {
                        left += r.left + el.clientLeft;
                    }
                    top += r.top + (docBody.scrollTop || docEl.scrollTop || 0);
                    break;
                }
                el = el.offsetParent;
            } while (el);
            el = element;
            do {
                if (el === docBody) {
                    break;
                }
                top -= el.scrollTop || 0;
                left -= el.scrollLeft || 0;
                el = el.parentNode;
            } while (el);
            return new L.Point(left, top);
        },
        documentIsLtr: function() {
            if (!L.DomUtil._docIsLtrCached) {
                L.DomUtil._docIsLtrCached = true;
                L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, "direction") === "ltr";
            }
            return L.DomUtil._docIsLtr;
        },
        create: function(tagName, className, container) {
            var el = document.createElement(tagName);
            el.className = className;
            if (container) {
                container.appendChild(el);
            }
            return el;
        },
        hasClass: function(el, name) {
            if (el.classList !== undefined) {
                return el.classList.contains(name);
            }
            var className = L.DomUtil._getClass(el);
            return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        },
        addClass: function(el, name) {
            if (el.classList !== undefined) {
                var classes = L.Util.splitWords(name);
                for (var i = 0, len = classes.length; i < len; i++) {
                    el.classList.add(classes[i]);
                }
            } else if (!L.DomUtil.hasClass(el, name)) {
                var className = L.DomUtil._getClass(el);
                L.DomUtil._setClass(el, (className ? className + " " : "") + name);
            }
        },
        removeClass: function(el, name) {
            if (el.classList !== undefined) {
                el.classList.remove(name);
            } else {
                L.DomUtil._setClass(el, L.Util.trim((" " + L.DomUtil._getClass(el) + " ").replace(" " + name + " ", " ")));
            }
        },
        _setClass: function(el, name) {
            if (el.className.baseVal === undefined) {
                el.className = name;
            } else {
                el.className.baseVal = name;
            }
        },
        _getClass: function(el) {
            return el.className.baseVal === undefined ? el.className : el.className.baseVal;
        },
        setOpacity: function(el, value) {
            if ("opacity" in el.style) {
                el.style.opacity = value;
            } else if ("filter" in el.style) {
                var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
                try {
                    filter = el.filters.item(filterName);
                } catch (e) {
                    if (value === 1) {
                        return;
                    }
                }
                value = Math.round(value * 100);
                if (filter) {
                    filter.Enabled = value !== 100;
                    filter.Opacity = value;
                } else {
                    el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
                }
            }
        },
        testProp: function(props) {
            var style = document.documentElement.style;
            for (var i = 0; i < props.length; i++) {
                if (props[i] in style) {
                    return props[i];
                }
            }
            return false;
        },
        getTranslateString: function(point) {
            var is3d = L.Browser.webkit3d, open = "translate" + (is3d ? "3d" : "") + "(", close = (is3d ? ",0" : "") + ")";
            return open + point.x + "px," + point.y + "px" + close;
        },
        getScaleString: function(scale, origin) {
            var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))), scaleStr = " scale(" + scale + ") ";
            return preTranslateStr + scaleStr;
        },
        setPosition: function(el, point, disable3D) {
            el._leaflet_pos = point;
            if (!disable3D && L.Browser.any3d) {
                el.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(point);
            } else {
                el.style.left = point.x + "px";
                el.style.top = point.y + "px";
            }
        },
        getPosition: function(el) {
            return el._leaflet_pos;
        }
    };
    L.DomUtil.TRANSFORM = L.DomUtil.testProp([ "transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform" ]);
    L.DomUtil.TRANSITION = L.DomUtil.testProp([ "webkitTransition", "transition", "OTransition", "MozTransition", "msTransition" ]);
    L.DomUtil.TRANSITION_END = L.DomUtil.TRANSITION === "webkitTransition" || L.DomUtil.TRANSITION === "OTransition" ? L.DomUtil.TRANSITION + "End" : "transitionend";
    (function() {
        if ("onselectstart" in document) {
            L.extend(L.DomUtil, {
                disableTextSelection: function() {
                    L.DomEvent.on(window, "selectstart", L.DomEvent.preventDefault);
                },
                enableTextSelection: function() {
                    L.DomEvent.off(window, "selectstart", L.DomEvent.preventDefault);
                }
            });
        } else {
            var userSelectProperty = L.DomUtil.testProp([ "userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect" ]);
            L.extend(L.DomUtil, {
                disableTextSelection: function() {
                    if (userSelectProperty) {
                        var style = document.documentElement.style;
                        this._userSelect = style[userSelectProperty];
                        style[userSelectProperty] = "none";
                    }
                },
                enableTextSelection: function() {
                    if (userSelectProperty) {
                        document.documentElement.style[userSelectProperty] = this._userSelect;
                        delete this._userSelect;
                    }
                }
            });
        }
        L.extend(L.DomUtil, {
            disableImageDrag: function() {
                L.DomEvent.on(window, "dragstart", L.DomEvent.preventDefault);
            },
            enableImageDrag: function() {
                L.DomEvent.off(window, "dragstart", L.DomEvent.preventDefault);
            }
        });
    })();
    L.LatLng = function(lat, lng, alt) {
        lat = parseFloat(lat);
        lng = parseFloat(lng);
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        }
        this.lat = lat;
        this.lng = lng;
        if (alt !== undefined) {
            this.alt = parseFloat(alt);
        }
    };
    L.extend(L.LatLng, {
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        MAX_MARGIN: 1e-9
    });
    L.LatLng.prototype = {
        equals: function(obj) {
            if (!obj) {
                return false;
            }
            obj = L.latLng(obj);
            var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
            return margin <= L.LatLng.MAX_MARGIN;
        },
        toString: function(precision) {
            return "LatLng(" + L.Util.formatNum(this.lat, precision) + ", " + L.Util.formatNum(this.lng, precision) + ")";
        },
        distanceTo: function(other) {
            other = L.latLng(other);
            var R = 6378137, d2r = L.LatLng.DEG_TO_RAD, dLat = (other.lat - this.lat) * d2r, dLon = (other.lng - this.lng) * d2r, lat1 = this.lat * d2r, lat2 = other.lat * d2r, sin1 = Math.sin(dLat / 2), sin2 = Math.sin(dLon / 2);
            var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        },
        wrap: function(a, b) {
            var lng = this.lng;
            a = a || -180;
            b = b || 180;
            lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);
            return new L.LatLng(this.lat, lng);
        }
    };
    L.latLng = function(a, b) {
        if (a instanceof L.LatLng) {
            return a;
        }
        if (L.Util.isArray(a)) {
            if (typeof a[0] === "number" || typeof a[0] === "string") {
                return new L.LatLng(a[0], a[1], a[2]);
            } else {
                return null;
            }
        }
        if (a === undefined || a === null) {
            return a;
        }
        if (typeof a === "object" && "lat" in a) {
            return new L.LatLng(a.lat, "lng" in a ? a.lng : a.lon);
        }
        if (b === undefined) {
            return null;
        }
        return new L.LatLng(a, b);
    };
    L.LatLngBounds = function(southWest, northEast) {
        if (!southWest) {
            return;
        }
        var latlngs = northEast ? [ southWest, northEast ] : southWest;
        for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
        }
    };
    L.LatLngBounds.prototype = {
        extend: function(obj) {
            if (!obj) {
                return this;
            }
            var latLng = L.latLng(obj);
            if (latLng !== null) {
                obj = latLng;
            } else {
                obj = L.latLngBounds(obj);
            }
            if (obj instanceof L.LatLng) {
                if (!this._southWest && !this._northEast) {
                    this._southWest = new L.LatLng(obj.lat, obj.lng);
                    this._northEast = new L.LatLng(obj.lat, obj.lng);
                } else {
                    this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
                    this._southWest.lng = Math.min(obj.lng, this._southWest.lng);
                    this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
                    this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
                }
            } else if (obj instanceof L.LatLngBounds) {
                this.extend(obj._southWest);
                this.extend(obj._northEast);
            }
            return this;
        },
        pad: function(bufferRatio) {
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new L.LatLngBounds(new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
        },
        getCenter: function() {
            return new L.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
        },
        getSouthWest: function() {
            return this._southWest;
        },
        getNorthEast: function() {
            return this._northEast;
        },
        getNorthWest: function() {
            return new L.LatLng(this.getNorth(), this.getWest());
        },
        getSouthEast: function() {
            return new L.LatLng(this.getSouth(), this.getEast());
        },
        getWest: function() {
            return this._southWest.lng;
        },
        getSouth: function() {
            return this._southWest.lat;
        },
        getEast: function() {
            return this._northEast.lng;
        },
        getNorth: function() {
            return this._northEast.lat;
        },
        contains: function(obj) {
            if (typeof obj[0] === "number" || obj instanceof L.LatLng) {
                obj = L.latLng(obj);
            } else {
                obj = L.latLngBounds(obj);
            }
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof L.LatLngBounds) {
                sw2 = obj.getSouthWest();
                ne2 = obj.getNorthEast();
            } else {
                sw2 = ne2 = obj;
            }
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        intersects: function(bounds) {
            bounds = L.latLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
        },
        toBBoxString: function() {
            return [ this.getWest(), this.getSouth(), this.getEast(), this.getNorth() ].join(",");
        },
        equals: function(bounds) {
            if (!bounds) {
                return false;
            }
            bounds = L.latLngBounds(bounds);
            return this._southWest.equals(bounds.getSouthWest()) && this._northEast.equals(bounds.getNorthEast());
        },
        isValid: function() {
            return !!(this._southWest && this._northEast);
        }
    };
    L.latLngBounds = function(a, b) {
        if (!a || a instanceof L.LatLngBounds) {
            return a;
        }
        return new L.LatLngBounds(a, b);
    };
    L.Projection = {};
    L.Projection.SphericalMercator = {
        MAX_LATITUDE: 85.0511287798,
        project: function(latlng) {
            var d = L.LatLng.DEG_TO_RAD, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), x = latlng.lng * d, y = lat * d;
            y = Math.log(Math.tan(Math.PI / 4 + y / 2));
            return new L.Point(x, y);
        },
        unproject: function(point) {
            var d = L.LatLng.RAD_TO_DEG, lng = point.x * d, lat = (2 * Math.atan(Math.exp(point.y)) - Math.PI / 2) * d;
            return new L.LatLng(lat, lng);
        }
    };
    L.Projection.LonLat = {
        project: function(latlng) {
            return new L.Point(latlng.lng, latlng.lat);
        },
        unproject: function(point) {
            return new L.LatLng(point.y, point.x);
        }
    };
    L.CRS = {
        latLngToPoint: function(latlng, zoom) {
            var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom);
            return this.transformation._transform(projectedPoint, scale);
        },
        pointToLatLng: function(point, zoom) {
            var scale = this.scale(zoom), untransformedPoint = this.transformation.untransform(point, scale);
            return this.projection.unproject(untransformedPoint);
        },
        project: function(latlng) {
            return this.projection.project(latlng);
        },
        scale: function(zoom) {
            return 256 * Math.pow(2, zoom);
        },
        getSize: function(zoom) {
            var s = this.scale(zoom);
            return L.point(s, s);
        }
    };
    L.CRS.Simple = L.extend({}, L.CRS, {
        projection: L.Projection.LonLat,
        transformation: new L.Transformation(1, 0, -1, 0),
        scale: function(zoom) {
            return Math.pow(2, zoom);
        }
    });
    L.CRS.EPSG3857 = L.extend({}, L.CRS, {
        code: "EPSG:3857",
        projection: L.Projection.SphericalMercator,
        transformation: new L.Transformation(.5 / Math.PI, .5, -.5 / Math.PI, .5),
        project: function(latlng) {
            var projectedPoint = this.projection.project(latlng), earthRadius = 6378137;
            return projectedPoint.multiplyBy(earthRadius);
        }
    });
    L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
        code: "EPSG:900913"
    });
    L.CRS.EPSG4326 = L.extend({}, L.CRS, {
        code: "EPSG:4326",
        projection: L.Projection.LonLat,
        transformation: new L.Transformation(1 / 360, .5, -1 / 360, .5)
    });
    L.Map = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            crs: L.CRS.EPSG3857,
            fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
            trackResize: true,
            markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
        },
        initialize: function(id, options) {
            options = L.setOptions(this, options);
            this._initContainer(id);
            this._initLayout();
            this._onResize = L.bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) {
                this.setMaxBounds(options.maxBounds);
            }
            if (options.center && options.zoom !== undefined) {
                this.setView(L.latLng(options.center), options.zoom, {
                    reset: true
                });
            }
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._tileLayersNum = 0;
            this.callInitHooks();
            this._addLayers(options.layers);
        },
        setView: function(center, zoom) {
            zoom = zoom === undefined ? this.getZoom() : zoom;
            this._resetView(L.latLng(center), this._limitZoom(zoom));
            return this;
        },
        setZoom: function(zoom, options) {
            if (!this._loaded) {
                this._zoom = this._limitZoom(zoom);
                return this;
            }
            return this.setView(this.getCenter(), zoom, {
                zoom: options
            });
        },
        zoomIn: function(delta, options) {
            return this.setZoom(this._zoom + (delta || 1), options);
        },
        zoomOut: function(delta, options) {
            return this.setZoom(this._zoom - (delta || 1), options);
        },
        setZoomAround: function(latlng, zoom, options) {
            var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom, {
                zoom: options
            });
        },
        fitBounds: function(bounds, options) {
            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);
            var paddingTL = L.point(options.paddingTopLeft || options.padding || [ 0, 0 ]), paddingBR = L.point(options.paddingBottomRight || options.padding || [ 0, 0 ]), zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR)), paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom), nePoint = this.project(bounds.getNorthEast(), zoom), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
            zoom = options && options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;
            return this.setView(center, zoom, options);
        },
        fitWorld: function(options) {
            return this.fitBounds([ [ -90, -180 ], [ 90, 180 ] ], options);
        },
        panTo: function(center, options) {
            return this.setView(center, this._zoom, {
                pan: options
            });
        },
        panBy: function(offset) {
            this.fire("movestart");
            this._rawPanBy(L.point(offset));
            this.fire("move");
            return this.fire("moveend");
        },
        setMaxBounds: function(bounds) {
            bounds = L.latLngBounds(bounds);
            this.options.maxBounds = bounds;
            if (!bounds) {
                return this.off("moveend", this._panInsideMaxBounds, this);
            }
            if (this._loaded) {
                this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds, this);
        },
        panInsideBounds: function(bounds, options) {
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, bounds);
            if (center.equals(newCenter)) {
                return this;
            }
            return this.panTo(newCenter, options);
        },
        addLayer: function(layer) {
            var id = L.stamp(layer);
            if (this._layers[id]) {
                return this;
            }
            this._layers[id] = layer;
            if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
                this._zoomBoundLayers[id] = layer;
                this._updateZoomLevels();
            }
            if (this.options.zoomAnimation && L.TileLayer && layer instanceof L.TileLayer) {
                this._tileLayersNum++;
                this._tileLayersToLoad++;
                layer.on("load", this._onTileLayerLoad, this);
            }
            if (this._loaded) {
                this._layerAdd(layer);
            }
            return this;
        },
        removeLayer: function(layer) {
            var id = L.stamp(layer);
            if (!this._layers[id]) {
                return this;
            }
            if (this._loaded) {
                layer.onRemove(this);
            }
            delete this._layers[id];
            if (this._loaded) {
                this.fire("layerremove", {
                    layer: layer
                });
            }
            if (this._zoomBoundLayers[id]) {
                delete this._zoomBoundLayers[id];
                this._updateZoomLevels();
            }
            if (this.options.zoomAnimation && L.TileLayer && layer instanceof L.TileLayer) {
                this._tileLayersNum--;
                this._tileLayersToLoad--;
                layer.off("load", this._onTileLayerLoad, this);
            }
            return this;
        },
        hasLayer: function(layer) {
            if (!layer) {
                return false;
            }
            return L.stamp(layer) in this._layers;
        },
        eachLayer: function(method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },
        invalidateSize: function(options) {
            if (!this._loaded) {
                return this;
            }
            options = L.extend({
                animate: false,
                pan: true
            }, options === true ? {
                animate: true
            } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._initialCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
                return this;
            }
            if (options.animate && options.pan) {
                this.panBy(offset);
            } else {
                if (options.pan) {
                    this._rawPanBy(offset);
                }
                this.fire("move");
                if (options.debounceMoveend) {
                    clearTimeout(this._sizeTimer);
                    this._sizeTimer = setTimeout(L.bind(this.fire, this, "moveend"), 200);
                } else {
                    this.fire("moveend");
                }
            }
            return this.fire("resize", {
                oldSize: oldSize,
                newSize: newSize
            });
        },
        addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
                return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
                handler.enable();
            }
            return this;
        },
        remove: function() {
            if (this._loaded) {
                this.fire("unload");
            }
            this._initEvents("off");
            try {
                delete this._container._leaflet;
            } catch (e) {
                this._container._leaflet = undefined;
            }
            this._clearPanes();
            if (this._clearControlPos) {
                this._clearControlPos();
            }
            this._clearHandlers();
            return this;
        },
        getCenter: function() {
            this._checkIfLoaded();
            if (this._initialCenter && !this._moved()) {
                return this._initialCenter;
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        getZoom: function() {
            return this._zoom;
        },
        getBounds: function() {
            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
            return new L.LatLngBounds(sw, ne);
        },
        getMinZoom: function() {
            return this.options.minZoom === undefined ? this._layersMinZoom === undefined ? 0 : this._layersMinZoom : this.options.minZoom;
        },
        getMaxZoom: function() {
            return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        getBoundsZoom: function(bounds, inside, padding) {
            bounds = L.latLngBounds(bounds);
            var zoom = this.getMinZoom() - (inside ? 1 : 0), maxZoom = this.getMaxZoom(), size = this.getSize(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), zoomNotFound = true, boundsSize;
            padding = L.point(padding || [ 0, 0 ]);
            do {
                zoom++;
                boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
                zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;
            } while (zoomNotFound && zoom <= maxZoom);
            if (zoomNotFound && inside) {
                return null;
            }
            return inside ? zoom : zoom - 1;
        },
        getSize: function() {
            if (!this._size || this._sizeChanged) {
                this._size = new L.Point(this._container.clientWidth, this._container.clientHeight);
                this._sizeChanged = false;
            }
            return this._size.clone();
        },
        getPixelBounds: function() {
            var topLeftPoint = this._getTopLeftPoint();
            return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._initialTopLeftPoint;
        },
        getPanes: function() {
            return this._panes;
        },
        getContainer: function() {
            return this._container;
        },
        getZoomScale: function(toZoom) {
            var crs = this.options.crs;
            return crs.scale(toZoom) / crs.scale(this._zoom);
        },
        getScaleZoom: function(scale) {
            return this._zoom + Math.log(scale) / Math.LN2;
        },
        project: function(latlng, zoom) {
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
        },
        unproject: function(point, zoom) {
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.pointToLatLng(L.point(point), zoom);
        },
        layerPointToLatLng: function(point) {
            var projectedPoint = L.point(point).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
        },
        latLngToLayerPoint: function(latlng) {
            var projectedPoint = this.project(L.latLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
        },
        containerPointToLayerPoint: function(point) {
            return L.point(point).subtract(this._getMapPanePos());
        },
        layerPointToContainerPoint: function(point) {
            return L.point(point).add(this._getMapPanePos());
        },
        containerPointToLatLng: function(point) {
            var layerPoint = this.containerPointToLayerPoint(L.point(point));
            return this.layerPointToLatLng(layerPoint);
        },
        latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
        },
        mouseEventToContainerPoint: function(e) {
            return L.DomEvent.getMousePosition(e, this._container);
        },
        mouseEventToLayerPoint: function(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },
        mouseEventToLatLng: function(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },
        _initContainer: function(id) {
            var container = this._container = L.DomUtil.get(id);
            if (!container) {
                throw new Error("Map container not found.");
            } else if (container._leaflet) {
                throw new Error("Map container is already initialized.");
            }
            container._leaflet = true;
        },
        _initLayout: function() {
            var container = this._container;
            L.DomUtil.addClass(container, "leaflet-container" + (L.Browser.touch ? " leaflet-touch" : "") + (L.Browser.retina ? " leaflet-retina" : "") + (L.Browser.ielt9 ? " leaflet-oldie" : "") + (this.options.fadeAnimation ? " leaflet-fade-anim" : ""));
            var position = L.DomUtil.getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed") {
                container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
                this._initControlPos();
            }
        },
        _initPanes: function() {
            var panes = this._panes = {};
            this._mapPane = panes.mapPane = this._createPane("leaflet-map-pane", this._container);
            this._tilePane = panes.tilePane = this._createPane("leaflet-tile-pane", this._mapPane);
            panes.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane);
            panes.shadowPane = this._createPane("leaflet-shadow-pane");
            panes.overlayPane = this._createPane("leaflet-overlay-pane");
            panes.markerPane = this._createPane("leaflet-marker-pane");
            panes.popupPane = this._createPane("leaflet-popup-pane");
            var zoomHide = " leaflet-zoom-hide";
            if (!this.options.markerZoomAnimation) {
                L.DomUtil.addClass(panes.markerPane, zoomHide);
                L.DomUtil.addClass(panes.shadowPane, zoomHide);
                L.DomUtil.addClass(panes.popupPane, zoomHide);
            }
        },
        _createPane: function(className, container) {
            return L.DomUtil.create("div", className, container || this._panes.objectsPane);
        },
        _clearPanes: function() {
            this._container.removeChild(this._mapPane);
        },
        _addLayers: function(layers) {
            layers = layers ? L.Util.isArray(layers) ? layers : [ layers ] : [];
            for (var i = 0, len = layers.length; i < len; i++) {
                this.addLayer(layers[i]);
            }
        },
        _resetView: function(center, zoom, preserveMapOffset, afterZoomAnim) {
            var zoomChanged = this._zoom !== zoom;
            if (!afterZoomAnim) {
                this.fire("movestart");
                if (zoomChanged) {
                    this.fire("zoomstart");
                }
            }
            this._zoom = zoom;
            this._initialCenter = center;
            this._initialTopLeftPoint = this._getNewTopLeftPoint(center);
            if (!preserveMapOffset) {
                L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
            } else {
                this._initialTopLeftPoint._add(this._getMapPanePos());
            }
            this._tileLayersToLoad = this._tileLayersNum;
            var loading = !this._loaded;
            this._loaded = true;
            this.fire("viewreset", {
                hard: !preserveMapOffset
            });
            if (loading) {
                this.fire("load");
                this.eachLayer(this._layerAdd, this);
            }
            this.fire("move");
            if (zoomChanged || afterZoomAnim) {
                this.fire("zoomend");
            }
            this.fire("moveend", {
                hard: !preserveMapOffset
            });
        },
        _rawPanBy: function(offset) {
            L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },
        _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
        },
        _updateZoomLevels: function() {
            var i, minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (i in this._zoomBoundLayers) {
                var layer = this._zoomBoundLayers[i];
                if (!isNaN(layer.options.minZoom)) {
                    minZoom = Math.min(minZoom, layer.options.minZoom);
                }
                if (!isNaN(layer.options.maxZoom)) {
                    maxZoom = Math.max(maxZoom, layer.options.maxZoom);
                }
            }
            if (i === undefined) {
                this._layersMaxZoom = this._layersMinZoom = undefined;
            } else {
                this._layersMaxZoom = maxZoom;
                this._layersMinZoom = minZoom;
            }
            if (oldZoomSpan !== this._getZoomSpan()) {
                this.fire("zoomlevelschange");
            }
        },
        _panInsideMaxBounds: function() {
            this.panInsideBounds(this.options.maxBounds);
        },
        _checkIfLoaded: function() {
            if (!this._loaded) {
                throw new Error("Set map center and zoom first.");
            }
        },
        _initEvents: function(onOff) {
            if (!L.DomEvent) {
                return;
            }
            onOff = onOff || "on";
            L.DomEvent[onOff](this._container, "click", this._onMouseClick, this);
            var events = [ "dblclick", "mousedown", "mouseup", "mouseenter", "mouseleave", "mousemove", "contextmenu" ], i, len;
            for (i = 0, len = events.length; i < len; i++) {
                L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
            }
            if (this.options.trackResize) {
                L.DomEvent[onOff](window, "resize", this._onResize, this);
            }
        },
        _onResize: function() {
            L.Util.cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = L.Util.requestAnimFrame(function() {
                this.invalidateSize({
                    debounceMoveend: true
                });
            }, this, false, this._container);
        },
        _onMouseClick: function(e) {
            if (!this._loaded || !e._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || L.DomEvent._skipped(e)) {
                return;
            }
            this.fire("preclick");
            this._fireMouseEvent(e);
        },
        _fireMouseEvent: function(e) {
            if (!this._loaded || L.DomEvent._skipped(e)) {
                return;
            }
            var type = e.type;
            type = type === "mouseenter" ? "mouseover" : type === "mouseleave" ? "mouseout" : type;
            if (!this.hasEventListeners(type)) {
                return;
            }
            if (type === "contextmenu") {
                L.DomEvent.preventDefault(e);
            }
            var containerPoint = this.mouseEventToContainerPoint(e), layerPoint = this.containerPointToLayerPoint(containerPoint), latlng = this.layerPointToLatLng(layerPoint);
            this.fire(type, {
                latlng: latlng,
                layerPoint: layerPoint,
                containerPoint: containerPoint,
                originalEvent: e
            });
        },
        _onTileLayerLoad: function() {
            this._tileLayersToLoad--;
            if (this._tileLayersNum && !this._tileLayersToLoad) {
                this.fire("tilelayersload");
            }
        },
        _clearHandlers: function() {
            for (var i = 0, len = this._handlers.length; i < len; i++) {
                this._handlers[i].disable();
            }
        },
        whenReady: function(callback, context) {
            if (this._loaded) {
                callback.call(context || this, this);
            } else {
                this.on("load", callback, context);
            }
            return this;
        },
        _layerAdd: function(layer) {
            layer.onAdd(this);
            this.fire("layeradd", {
                layer: layer
            });
        },
        _getMapPanePos: function() {
            return L.DomUtil.getPosition(this._mapPane);
        },
        _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([ 0, 0 ]);
        },
        _getTopLeftPoint: function() {
            return this.getPixelOrigin().subtract(this._getMapPanePos());
        },
        _getNewTopLeftPoint: function(center, zoom) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom)._subtract(viewHalf)._round();
        },
        _latLngToNewLayerPoint: function(latlng, newZoom, newCenter) {
            var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
            return this.project(latlng, newZoom)._subtract(topLeft);
        },
        _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        _limitCenter: function(center, zoom, bounds) {
            if (!bounds) {
                return center;
            }
            var centerPoint = this.project(center, zoom), viewHalf = this.getSize().divideBy(2), viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom);
            return this.unproject(centerPoint.add(offset), zoom);
        },
        _limitOffset: function(offset, bounds) {
            if (!bounds) {
                return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds));
        },
        _getBoundsOffset: function(pxBounds, maxBounds, zoom) {
            var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min), seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max), dx = this._rebound(nwOffset.x, -seOffset.x), dy = this._rebound(nwOffset.y, -seOffset.y);
            return new L.Point(dx, dy);
        },
        _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function(zoom) {
            var min = this.getMinZoom(), max = this.getMaxZoom();
            return Math.max(min, Math.min(max, zoom));
        }
    });
    L.map = function(id, options) {
        return new L.Map(id, options);
    };
    L.Projection.Mercator = {
        MAX_LATITUDE: 85.0840591556,
        R_MINOR: 6356752.314245179,
        R_MAJOR: 6378137,
        project: function(latlng) {
            var d = L.LatLng.DEG_TO_RAD, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), r = this.R_MAJOR, r2 = this.R_MINOR, x = latlng.lng * d * r, y = lat * d, tmp = r2 / r, eccent = Math.sqrt(1 - tmp * tmp), con = eccent * Math.sin(y);
            con = Math.pow((1 - con) / (1 + con), eccent * .5);
            var ts = Math.tan(.5 * (Math.PI * .5 - y)) / con;
            y = -r * Math.log(ts);
            return new L.Point(x, y);
        },
        unproject: function(point) {
            var d = L.LatLng.RAD_TO_DEG, r = this.R_MAJOR, r2 = this.R_MINOR, lng = point.x * d / r, tmp = r2 / r, eccent = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts), numIter = 15, tol = 1e-7, i = numIter, dphi = .1, con;
            while (Math.abs(dphi) > tol && --i > 0) {
                con = eccent * Math.sin(phi);
                dphi = Math.PI / 2 - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), .5 * eccent)) - phi;
                phi += dphi;
            }
            return new L.LatLng(phi * d, lng);
        }
    };
    L.CRS.EPSG3395 = L.extend({}, L.CRS, {
        code: "EPSG:3395",
        projection: L.Projection.Mercator,
        transformation: function() {
            var m = L.Projection.Mercator, r = m.R_MAJOR, scale = .5 / (Math.PI * r);
            return new L.Transformation(scale, .5, -scale, .5);
        }()
    });
    L.TileLayer = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            minZoom: 0,
            maxZoom: 18,
            tileSize: 256,
            subdomains: "abc",
            errorTileUrl: "",
            attribution: "",
            zoomOffset: 0,
            opacity: 1,
            unloadInvisibleTiles: L.Browser.mobile,
            updateWhenIdle: L.Browser.mobile
        },
        initialize: function(url, options) {
            options = L.setOptions(this, options);
            if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {
                options.tileSize = Math.floor(options.tileSize / 2);
                options.zoomOffset++;
                if (options.minZoom > 0) {
                    options.minZoom--;
                }
                this.options.maxZoom--;
            }
            if (options.bounds) {
                options.bounds = L.latLngBounds(options.bounds);
            }
            this._url = url;
            var subdomains = this.options.subdomains;
            if (typeof subdomains === "string") {
                this.options.subdomains = subdomains.split("");
            }
        },
        onAdd: function(map) {
            this._map = map;
            this._animated = map._zoomAnimated;
            this._initContainer();
            map.on({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            if (this._animated) {
                map.on({
                    zoomanim: this._animateZoom,
                    zoomend: this._endZoomAnim
                }, this);
            }
            if (!this.options.updateWhenIdle) {
                this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
                map.on("move", this._limitedUpdate, this);
            }
            this._reset();
            this._update();
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        onRemove: function(map) {
            this._container.parentNode.removeChild(this._container);
            map.off({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            if (this._animated) {
                map.off({
                    zoomanim: this._animateZoom,
                    zoomend: this._endZoomAnim
                }, this);
            }
            if (!this.options.updateWhenIdle) {
                map.off("move", this._limitedUpdate, this);
            }
            this._container = null;
            this._map = null;
        },
        bringToFront: function() {
            var pane = this._map._panes.tilePane;
            if (this._container) {
                pane.appendChild(this._container);
                this._setAutoZIndex(pane, Math.max);
            }
            return this;
        },
        bringToBack: function() {
            var pane = this._map._panes.tilePane;
            if (this._container) {
                pane.insertBefore(this._container, pane.firstChild);
                this._setAutoZIndex(pane, Math.min);
            }
            return this;
        },
        getAttribution: function() {
            return this.options.attribution;
        },
        getContainer: function() {
            return this._container;
        },
        setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
                this._updateOpacity();
            }
            return this;
        },
        setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
        },
        setUrl: function(url, noRedraw) {
            this._url = url;
            if (!noRedraw) {
                this.redraw();
            }
            return this;
        },
        redraw: function() {
            if (this._map) {
                this._reset({
                    hard: true
                });
                this._update();
            }
            return this;
        },
        _updateZIndex: function() {
            if (this._container && this.options.zIndex !== undefined) {
                this._container.style.zIndex = this.options.zIndex;
            }
        },
        _setAutoZIndex: function(pane, compare) {
            var layers = pane.children, edgeZIndex = -compare(Infinity, -Infinity), zIndex, i, len;
            for (i = 0, len = layers.length; i < len; i++) {
                if (layers[i] !== this._container) {
                    zIndex = parseInt(layers[i].style.zIndex, 10);
                    if (!isNaN(zIndex)) {
                        edgeZIndex = compare(edgeZIndex, zIndex);
                    }
                }
            }
            this.options.zIndex = this._container.style.zIndex = (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
        },
        _updateOpacity: function() {
            var i, tiles = this._tiles;
            if (L.Browser.ielt9) {
                for (i in tiles) {
                    L.DomUtil.setOpacity(tiles[i], this.options.opacity);
                }
            } else {
                L.DomUtil.setOpacity(this._container, this.options.opacity);
            }
        },
        _initContainer: function() {
            var tilePane = this._map._panes.tilePane;
            if (!this._container) {
                this._container = L.DomUtil.create("div", "leaflet-layer");
                this._updateZIndex();
                if (this._animated) {
                    var className = "leaflet-tile-container";
                    this._bgBuffer = L.DomUtil.create("div", className, this._container);
                    this._tileContainer = L.DomUtil.create("div", className, this._container);
                } else {
                    this._tileContainer = this._container;
                }
                tilePane.appendChild(this._container);
                if (this.options.opacity < 1) {
                    this._updateOpacity();
                }
            }
        },
        _reset: function(e) {
            for (var key in this._tiles) {
                this.fire("tileunload", {
                    tile: this._tiles[key]
                });
            }
            this._tiles = {};
            this._tilesToLoad = 0;
            if (this.options.reuseTiles) {
                this._unusedTiles = [];
            }
            this._tileContainer.innerHTML = "";
            if (this._animated && e && e.hard) {
                this._clearBgBuffer();
            }
            this._initContainer();
        },
        _getTileSize: function() {
            var map = this._map, zoom = map.getZoom() + this.options.zoomOffset, zoomN = this.options.maxNativeZoom, tileSize = this.options.tileSize;
            if (zoomN && zoom > zoomN) {
                tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
            }
            return tileSize;
        },
        _update: function() {
            if (!this._map) {
                return;
            }
            var map = this._map, bounds = map.getPixelBounds(), zoom = map.getZoom(), tileSize = this._getTileSize();
            if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                return;
            }
            var tileBounds = L.bounds(bounds.min.divideBy(tileSize)._floor(), bounds.max.divideBy(tileSize)._floor());
            this._addTilesFromCenterOut(tileBounds);
            if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
                this._removeOtherTiles(tileBounds);
            }
        },
        _addTilesFromCenterOut: function(bounds) {
            var queue = [], center = bounds.getCenter();
            var j, i, point;
            for (j = bounds.min.y; j <= bounds.max.y; j++) {
                for (i = bounds.min.x; i <= bounds.max.x; i++) {
                    point = new L.Point(i, j);
                    if (this._tileShouldBeLoaded(point)) {
                        queue.push(point);
                    }
                }
            }
            var tilesToLoad = queue.length;
            if (tilesToLoad === 0) {
                return;
            }
            queue.sort(function(a, b) {
                return a.distanceTo(center) - b.distanceTo(center);
            });
            var fragment = document.createDocumentFragment();
            if (!this._tilesToLoad) {
                this.fire("loading");
            }
            this._tilesToLoad += tilesToLoad;
            for (i = 0; i < tilesToLoad; i++) {
                this._addTile(queue[i], fragment);
            }
            this._tileContainer.appendChild(fragment);
        },
        _tileShouldBeLoaded: function(tilePoint) {
            if (tilePoint.x + ":" + tilePoint.y in this._tiles) {
                return false;
            }
            var options = this.options;
            if (!options.continuousWorld) {
                var limit = this._getWrapTileNum();
                if (options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x) || tilePoint.y < 0 || tilePoint.y >= limit.y) {
                    return false;
                }
            }
            if (options.bounds) {
                var tileSize = options.tileSize, nwPoint = tilePoint.multiplyBy(tileSize), sePoint = nwPoint.add([ tileSize, tileSize ]), nw = this._map.unproject(nwPoint), se = this._map.unproject(sePoint);
                if (!options.continuousWorld && !options.noWrap) {
                    nw = nw.wrap();
                    se = se.wrap();
                }
                if (!options.bounds.intersects([ nw, se ])) {
                    return false;
                }
            }
            return true;
        },
        _removeOtherTiles: function(bounds) {
            var kArr, x, y, key;
            for (key in this._tiles) {
                kArr = key.split(":");
                x = parseInt(kArr[0], 10);
                y = parseInt(kArr[1], 10);
                if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
                    this._removeTile(key);
                }
            }
        },
        _removeTile: function(key) {
            var tile = this._tiles[key];
            this.fire("tileunload", {
                tile: tile,
                url: tile.src
            });
            if (this.options.reuseTiles) {
                L.DomUtil.removeClass(tile, "leaflet-tile-loaded");
                this._unusedTiles.push(tile);
            } else if (tile.parentNode === this._tileContainer) {
                this._tileContainer.removeChild(tile);
            }
            if (!L.Browser.android) {
                tile.onload = null;
                tile.src = L.Util.emptyImageUrl;
            }
            delete this._tiles[key];
        },
        _addTile: function(tilePoint, container) {
            var tilePos = this._getTilePos(tilePoint);
            var tile = this._getTile();
            L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);
            this._tiles[tilePoint.x + ":" + tilePoint.y] = tile;
            this._loadTile(tile, tilePoint);
            if (tile.parentNode !== this._tileContainer) {
                container.appendChild(tile);
            }
        },
        _getZoomForUrl: function() {
            var options = this.options, zoom = this._map.getZoom();
            if (options.zoomReverse) {
                zoom = options.maxZoom - zoom;
            }
            zoom += options.zoomOffset;
            return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
        },
        _getTilePos: function(tilePoint) {
            var origin = this._map.getPixelOrigin(), tileSize = this._getTileSize();
            return tilePoint.multiplyBy(tileSize).subtract(origin);
        },
        getTileUrl: function(tilePoint) {
            return L.Util.template(this._url, L.extend({
                s: this._getSubdomain(tilePoint),
                z: tilePoint.z,
                x: tilePoint.x,
                y: tilePoint.y
            }, this.options));
        },
        _getWrapTileNum: function() {
            var crs = this._map.options.crs, size = crs.getSize(this._map.getZoom());
            return size.divideBy(this._getTileSize())._floor();
        },
        _adjustTilePoint: function(tilePoint) {
            var limit = this._getWrapTileNum();
            if (!this.options.continuousWorld && !this.options.noWrap) {
                tilePoint.x = (tilePoint.x % limit.x + limit.x) % limit.x;
            }
            if (this.options.tms) {
                tilePoint.y = limit.y - tilePoint.y - 1;
            }
            tilePoint.z = this._getZoomForUrl();
        },
        _getSubdomain: function(tilePoint) {
            var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index];
        },
        _getTile: function() {
            if (this.options.reuseTiles && this._unusedTiles.length > 0) {
                var tile = this._unusedTiles.pop();
                this._resetTile(tile);
                return tile;
            }
            return this._createTile();
        },
        _resetTile: function() {},
        _createTile: function() {
            var tile = L.DomUtil.create("img", "leaflet-tile");
            tile.style.width = tile.style.height = this._getTileSize() + "px";
            tile.galleryimg = "no";
            tile.onselectstart = tile.onmousemove = L.Util.falseFn;
            if (L.Browser.ielt9 && this.options.opacity !== undefined) {
                L.DomUtil.setOpacity(tile, this.options.opacity);
            }
            if (L.Browser.mobileWebkit3d) {
                tile.style.WebkitBackfaceVisibility = "hidden";
            }
            return tile;
        },
        _loadTile: function(tile, tilePoint) {
            tile._layer = this;
            tile.onload = this._tileOnLoad;
            tile.onerror = this._tileOnError;
            this._adjustTilePoint(tilePoint);
            tile.src = this.getTileUrl(tilePoint);
            this.fire("tileloadstart", {
                tile: tile,
                url: tile.src
            });
        },
        _tileLoaded: function() {
            this._tilesToLoad--;
            if (this._animated) {
                L.DomUtil.addClass(this._tileContainer, "leaflet-zoom-animated");
            }
            if (!this._tilesToLoad) {
                this.fire("load");
                if (this._animated) {
                    clearTimeout(this._clearBgBufferTimer);
                    this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
                }
            }
        },
        _tileOnLoad: function() {
            var layer = this._layer;
            if (this.src !== L.Util.emptyImageUrl) {
                L.DomUtil.addClass(this, "leaflet-tile-loaded");
                layer.fire("tileload", {
                    tile: this,
                    url: this.src
                });
            }
            layer._tileLoaded();
        },
        _tileOnError: function() {
            var layer = this._layer;
            layer.fire("tileerror", {
                tile: this,
                url: this.src
            });
            var newUrl = layer.options.errorTileUrl;
            if (newUrl) {
                this.src = newUrl;
            }
            layer._tileLoaded();
        }
    });
    L.tileLayer = function(url, options) {
        return new L.TileLayer(url, options);
    };
    L.TileLayer.WMS = L.TileLayer.extend({
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            version: "1.1.1",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: false
        },
        initialize: function(url, options) {
            this._url = url;
            var wmsParams = L.extend({}, this.defaultWmsParams), tileSize = options.tileSize || this.options.tileSize;
            if (options.detectRetina && L.Browser.retina) {
                wmsParams.width = wmsParams.height = tileSize * 2;
            } else {
                wmsParams.width = wmsParams.height = tileSize;
            }
            for (var i in options) {
                if (!this.options.hasOwnProperty(i) && i !== "crs") {
                    wmsParams[i] = options[i];
                }
            }
            this.wmsParams = wmsParams;
            L.setOptions(this, options);
        },
        onAdd: function(map) {
            this._crs = this.options.crs || map.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            L.TileLayer.prototype.onAdd.call(this, map);
        },
        getTileUrl: function(tilePoint) {
            var map = this._map, tileSize = this.options.tileSize, nwPoint = tilePoint.multiplyBy(tileSize), sePoint = nwPoint.add([ tileSize, tileSize ]), nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)), se = this._crs.project(map.unproject(sePoint, tilePoint.z)), bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ? [ se.y, nw.x, nw.y, se.x ].join(",") : [ nw.x, se.y, se.x, nw.y ].join(","), url = L.Util.template(this._url, {
                s: this._getSubdomain(tilePoint)
            });
            return url + L.Util.getParamString(this.wmsParams, url, true) + "&BBOX=" + bbox;
        },
        setParams: function(params, noRedraw) {
            L.extend(this.wmsParams, params);
            if (!noRedraw) {
                this.redraw();
            }
            return this;
        }
    });
    L.tileLayer.wms = function(url, options) {
        return new L.TileLayer.WMS(url, options);
    };
    L.TileLayer.Canvas = L.TileLayer.extend({
        options: {
            async: false
        },
        initialize: function(options) {
            L.setOptions(this, options);
        },
        redraw: function() {
            if (this._map) {
                this._reset({
                    hard: true
                });
                this._update();
            }
            for (var i in this._tiles) {
                this._redrawTile(this._tiles[i]);
            }
            return this;
        },
        _redrawTile: function(tile) {
            this.drawTile(tile, tile._tilePoint, this._map._zoom);
        },
        _createTile: function() {
            var tile = L.DomUtil.create("canvas", "leaflet-tile");
            tile.width = tile.height = this.options.tileSize;
            tile.onselectstart = tile.onmousemove = L.Util.falseFn;
            return tile;
        },
        _loadTile: function(tile, tilePoint) {
            tile._layer = this;
            tile._tilePoint = tilePoint;
            this._redrawTile(tile);
            if (!this.options.async) {
                this.tileDrawn(tile);
            }
        },
        drawTile: function() {},
        tileDrawn: function(tile) {
            this._tileOnLoad.call(tile);
        }
    });
    L.tileLayer.canvas = function(options) {
        return new L.TileLayer.Canvas(options);
    };
    L.ImageOverlay = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            opacity: 1
        },
        initialize: function(url, bounds, options) {
            this._url = url;
            this._bounds = L.latLngBounds(bounds);
            L.setOptions(this, options);
        },
        onAdd: function(map) {
            this._map = map;
            if (!this._image) {
                this._initImage();
            }
            map._panes.overlayPane.appendChild(this._image);
            map.on("viewreset", this._reset, this);
            if (map.options.zoomAnimation && L.Browser.any3d) {
                map.on("zoomanim", this._animateZoom, this);
            }
            this._reset();
        },
        onRemove: function(map) {
            map.getPanes().overlayPane.removeChild(this._image);
            map.off("viewreset", this._reset, this);
            if (map.options.zoomAnimation) {
                map.off("zoomanim", this._animateZoom, this);
            }
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
        },
        bringToFront: function() {
            if (this._image) {
                this._map._panes.overlayPane.appendChild(this._image);
            }
            return this;
        },
        bringToBack: function() {
            var pane = this._map._panes.overlayPane;
            if (this._image) {
                pane.insertBefore(this._image, pane.firstChild);
            }
            return this;
        },
        setUrl: function(url) {
            this._url = url;
            this._image.src = this._url;
        },
        getAttribution: function() {
            return this.options.attribution;
        },
        _initImage: function() {
            this._image = L.DomUtil.create("img", "leaflet-image-layer");
            if (this._map.options.zoomAnimation && L.Browser.any3d) {
                L.DomUtil.addClass(this._image, "leaflet-zoom-animated");
            } else {
                L.DomUtil.addClass(this._image, "leaflet-zoom-hide");
            }
            this._updateOpacity();
            L.extend(this._image, {
                galleryimg: "no",
                onselectstart: L.Util.falseFn,
                onmousemove: L.Util.falseFn,
                onload: L.bind(this._onImageLoad, this),
                src: this._url
            });
        },
        _animateZoom: function(e) {
            var map = this._map, image = this._image, scale = map.getZoomScale(e.zoom), nw = this._bounds.getNorthWest(), se = this._bounds.getSouthEast(), topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center), size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft), origin = topLeft._add(size._multiplyBy(1 / 2 * (1 - 1 / scale)));
            image.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(origin) + " scale(" + scale + ") ";
        },
        _reset: function() {
            var image = this._image, topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()), size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);
            L.DomUtil.setPosition(image, topLeft);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
        },
        _onImageLoad: function() {
            this.fire("load");
        },
        _updateOpacity: function() {
            L.DomUtil.setOpacity(this._image, this.options.opacity);
        }
    });
    L.imageOverlay = function(url, bounds, options) {
        return new L.ImageOverlay(url, bounds, options);
    };
    L.Icon = L.Class.extend({
        options: {
            className: ""
        },
        initialize: function(options) {
            L.setOptions(this, options);
        },
        createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
        },
        createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
                if (name === "icon") {
                    throw new Error("iconUrl not set in Icon options (see the docs).");
                }
                return null;
            }
            var img;
            if (!oldIcon || oldIcon.tagName !== "IMG") {
                img = this._createImg(src);
            } else {
                img = this._createImg(src, oldIcon);
            }
            this._setIconStyles(img, name);
            return img;
        },
        _setIconStyles: function(img, name) {
            var options = this.options, size = L.point(options[name + "Size"]), anchor;
            if (name === "shadow") {
                anchor = L.point(options.shadowAnchor || options.iconAnchor);
            } else {
                anchor = L.point(options.iconAnchor);
            }
            if (!anchor && size) {
                anchor = size.divideBy(2, true);
            }
            img.className = "leaflet-marker-" + name + " " + options.className;
            if (anchor) {
                img.style.marginLeft = -anchor.x + "px";
                img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
                img.style.width = size.x + "px";
                img.style.height = size.y + "px";
            }
        },
        _createImg: function(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
        },
        _getIconUrl: function(name) {
            if (L.Browser.retina && this.options[name + "RetinaUrl"]) {
                return this.options[name + "RetinaUrl"];
            }
            return this.options[name + "Url"];
        }
    });
    L.icon = function(options) {
        return new L.Icon(options);
    };
    L.Icon.Default = L.Icon.extend({
        options: {
            iconSize: [ 25, 41 ],
            iconAnchor: [ 12, 41 ],
            popupAnchor: [ 1, -34 ],
            shadowSize: [ 41, 41 ]
        },
        _getIconUrl: function(name) {
            var key = name + "Url";
            if (this.options[key]) {
                return this.options[key];
            }
            if (L.Browser.retina && name === "icon") {
                name += "-2x";
            }
            var path = L.Icon.Default.imagePath;
            if (!path) {
                throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
            }
            return path + "/marker-" + name + ".png";
        }
    });
    L.Icon.Default.imagePath = function() {
        var scripts = document.getElementsByTagName("script"), leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
        var i, len, src, matches, path;
        for (i = 0, len = scripts.length; i < len; i++) {
            src = scripts[i].src;
            matches = src.match(leafletRe);
            if (matches) {
                path = src.split(leafletRe)[0];
                return (path ? path + "/" : "") + "images";
            }
        }
    }();
    L.Marker = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            icon: new L.Icon.Default(),
            title: "",
            alt: "",
            clickable: true,
            draggable: false,
            keyboard: true,
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: false,
            riseOffset: 250
        },
        initialize: function(latlng, options) {
            L.setOptions(this, options);
            this._latlng = L.latLng(latlng);
        },
        onAdd: function(map) {
            this._map = map;
            map.on("viewreset", this.update, this);
            this._initIcon();
            this.update();
            this.fire("add");
            if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
                map.on("zoomanim", this._animateZoom, this);
            }
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        onRemove: function(map) {
            if (this.dragging) {
                this.dragging.disable();
            }
            this._removeIcon();
            this._removeShadow();
            this.fire("remove");
            map.off({
                viewreset: this.update,
                zoomanim: this._animateZoom
            }, this);
            this._map = null;
        },
        getLatLng: function() {
            return this._latlng;
        },
        setLatLng: function(latlng) {
            this._latlng = L.latLng(latlng);
            this.update();
            return this.fire("move", {
                latlng: this._latlng
            });
        },
        setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            this.update();
            return this;
        },
        setIcon: function(icon) {
            this.options.icon = icon;
            if (this._map) {
                this._initIcon();
                this.update();
            }
            if (this._popup) {
                this.bindPopup(this._popup);
            }
            return this;
        },
        update: function() {
            if (this._icon) {
                var pos = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(pos);
            }
            return this;
        },
        _initIcon: function() {
            var options = this.options, map = this._map, animation = map.options.zoomAnimation && map.options.markerZoomAnimation, classToAdd = animation ? "leaflet-zoom-animated" : "leaflet-zoom-hide";
            var icon = options.icon.createIcon(this._icon), addIcon = false;
            if (icon !== this._icon) {
                if (this._icon) {
                    this._removeIcon();
                }
                addIcon = true;
                if (options.title) {
                    icon.title = options.title;
                }
                if (options.alt) {
                    icon.alt = options.alt;
                }
            }
            L.DomUtil.addClass(icon, classToAdd);
            if (options.keyboard) {
                icon.tabIndex = "0";
            }
            this._icon = icon;
            this._initInteraction();
            if (options.riseOnHover) {
                L.DomEvent.on(icon, "mouseover", this._bringToFront, this).on(icon, "mouseout", this._resetZIndex, this);
            }
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
                this._removeShadow();
                addShadow = true;
            }
            if (newShadow) {
                L.DomUtil.addClass(newShadow, classToAdd);
            }
            this._shadow = newShadow;
            if (options.opacity < 1) {
                this._updateOpacity();
            }
            var panes = this._map._panes;
            if (addIcon) {
                panes.markerPane.appendChild(this._icon);
            }
            if (newShadow && addShadow) {
                panes.shadowPane.appendChild(this._shadow);
            }
        },
        _removeIcon: function() {
            if (this.options.riseOnHover) {
                L.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex);
            }
            this._map._panes.markerPane.removeChild(this._icon);
            this._icon = null;
        },
        _removeShadow: function() {
            if (this._shadow) {
                this._map._panes.shadowPane.removeChild(this._shadow);
            }
            this._shadow = null;
        },
        _setPos: function(pos) {
            L.DomUtil.setPosition(this._icon, pos);
            if (this._shadow) {
                L.DomUtil.setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
        },
        _updateZIndex: function(offset) {
            this._icon.style.zIndex = this._zIndex + offset;
        },
        _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
        },
        _initInteraction: function() {
            if (!this.options.clickable) {
                return;
            }
            var icon = this._icon, events = [ "dblclick", "mousedown", "mouseover", "mouseout", "contextmenu" ];
            L.DomUtil.addClass(icon, "leaflet-clickable");
            L.DomEvent.on(icon, "click", this._onMouseClick, this);
            L.DomEvent.on(icon, "keypress", this._onKeyPress, this);
            for (var i = 0; i < events.length; i++) {
                L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
            }
            if (L.Handler.MarkerDrag) {
                this.dragging = new L.Handler.MarkerDrag(this);
                if (this.options.draggable) {
                    this.dragging.enable();
                }
            }
        },
        _onMouseClick: function(e) {
            var wasDragged = this.dragging && this.dragging.moved();
            if (this.hasEventListeners(e.type) || wasDragged) {
                L.DomEvent.stopPropagation(e);
            }
            if (wasDragged) {
                return;
            }
            if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) {
                return;
            }
            this.fire(e.type, {
                originalEvent: e,
                latlng: this._latlng
            });
        },
        _onKeyPress: function(e) {
            if (e.keyCode === 13) {
                this.fire("click", {
                    originalEvent: e,
                    latlng: this._latlng
                });
            }
        },
        _fireMouseEvent: function(e) {
            this.fire(e.type, {
                originalEvent: e,
                latlng: this._latlng
            });
            if (e.type === "contextmenu" && this.hasEventListeners(e.type)) {
                L.DomEvent.preventDefault(e);
            }
            if (e.type !== "mousedown") {
                L.DomEvent.stopPropagation(e);
            } else {
                L.DomEvent.preventDefault(e);
            }
        },
        setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
                this._updateOpacity();
            }
            return this;
        },
        _updateOpacity: function() {
            L.DomUtil.setOpacity(this._icon, this.options.opacity);
            if (this._shadow) {
                L.DomUtil.setOpacity(this._shadow, this.options.opacity);
            }
        },
        _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
            this._updateZIndex(0);
        }
    });
    L.marker = function(latlng, options) {
        return new L.Marker(latlng, options);
    };
    L.DivIcon = L.Icon.extend({
        options: {
            iconSize: [ 12, 12 ],
            className: "leaflet-div-icon",
            html: false
        },
        createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html !== false) {
                div.innerHTML = options.html;
            } else {
                div.innerHTML = "";
            }
            if (options.bgPos) {
                div.style.backgroundPosition = -options.bgPos.x + "px " + -options.bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
        },
        createShadow: function() {
            return null;
        }
    });
    L.divIcon = function(options) {
        return new L.DivIcon(options);
    };
    L.Map.mergeOptions({
        closePopupOnClick: true
    });
    L.Popup = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            minWidth: 50,
            maxWidth: 300,
            autoPan: true,
            closeButton: true,
            offset: [ 0, 7 ],
            autoPanPadding: [ 5, 5 ],
            keepInView: false,
            className: "",
            zoomAnimation: true
        },
        initialize: function(options, source) {
            L.setOptions(this, options);
            this._source = source;
            this._animated = L.Browser.any3d && this.options.zoomAnimation;
            this._isOpen = false;
        },
        onAdd: function(map) {
            this._map = map;
            if (!this._container) {
                this._initLayout();
            }
            var animFade = map.options.fadeAnimation;
            if (animFade) {
                L.DomUtil.setOpacity(this._container, 0);
            }
            map._panes.popupPane.appendChild(this._container);
            map.on(this._getEvents(), this);
            this.update();
            if (animFade) {
                L.DomUtil.setOpacity(this._container, 1);
            }
            this.fire("open");
            map.fire("popupopen", {
                popup: this
            });
            if (this._source) {
                this._source.fire("popupopen", {
                    popup: this
                });
            }
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        openOn: function(map) {
            map.openPopup(this);
            return this;
        },
        onRemove: function(map) {
            map._panes.popupPane.removeChild(this._container);
            L.Util.falseFn(this._container.offsetWidth);
            map.off(this._getEvents(), this);
            if (map.options.fadeAnimation) {
                L.DomUtil.setOpacity(this._container, 0);
            }
            this._map = null;
            this.fire("close");
            map.fire("popupclose", {
                popup: this
            });
            if (this._source) {
                this._source.fire("popupclose", {
                    popup: this
                });
            }
        },
        getLatLng: function() {
            return this._latlng;
        },
        setLatLng: function(latlng) {
            this._latlng = L.latLng(latlng);
            if (this._map) {
                this._updatePosition();
                this._adjustPan();
            }
            return this;
        },
        getContent: function() {
            return this._content;
        },
        setContent: function(content) {
            this._content = content;
            this.update();
            return this;
        },
        update: function() {
            if (!this._map) {
                return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
        },
        _getEvents: function() {
            var events = {
                viewreset: this._updatePosition
            };
            if (this._animated) {
                events.zoomanim = this._zoomAnimation;
            }
            if ("closeOnClick" in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
                events.preclick = this._close;
            }
            if (this.options.keepInView) {
                events.moveend = this._adjustPan;
            }
            return events;
        },
        _close: function() {
            if (this._map) {
                this._map.closePopup(this);
            }
        },
        _initLayout: function() {
            var prefix = "leaflet-popup", containerClass = prefix + " " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"), container = this._container = L.DomUtil.create("div", containerClass), closeButton;
            if (this.options.closeButton) {
                closeButton = this._closeButton = L.DomUtil.create("a", prefix + "-close-button", container);
                closeButton.href = "#close";
                closeButton.innerHTML = "&#215;";
                L.DomEvent.disableClickPropagation(closeButton);
                L.DomEvent.on(closeButton, "click", this._onCloseButtonClick, this);
            }
            var wrapper = this._wrapper = L.DomUtil.create("div", prefix + "-content-wrapper", container);
            L.DomEvent.disableClickPropagation(wrapper);
            this._contentNode = L.DomUtil.create("div", prefix + "-content", wrapper);
            L.DomEvent.disableScrollPropagation(this._contentNode);
            L.DomEvent.on(wrapper, "contextmenu", L.DomEvent.stopPropagation);
            this._tipContainer = L.DomUtil.create("div", prefix + "-tip-container", container);
            this._tip = L.DomUtil.create("div", prefix + "-tip", this._tipContainer);
        },
        _updateContent: function() {
            if (!this._content) {
                return;
            }
            if (typeof this._content === "string") {
                this._contentNode.innerHTML = this._content;
            } else {
                while (this._contentNode.hasChildNodes()) {
                    this._contentNode.removeChild(this._contentNode.firstChild);
                }
                this._contentNode.appendChild(this._content);
            }
            this.fire("contentupdate");
        },
        _updateLayout: function() {
            var container = this._contentNode, style = container.style;
            style.width = "";
            style.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style.width = width + 1 + "px";
            style.whiteSpace = "";
            style.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
                style.height = maxHeight + "px";
                L.DomUtil.addClass(container, scrolledClass);
            } else {
                L.DomUtil.removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
        },
        _updatePosition: function() {
            if (!this._map) {
                return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), animated = this._animated, offset = L.point(this.options.offset);
            if (animated) {
                L.DomUtil.setPosition(this._container, pos);
            }
            this._containerBottom = -offset.y - (animated ? 0 : pos.y);
            this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);
            this._container.style.bottom = this._containerBottom + "px";
            this._container.style.left = this._containerLeft + "px";
        },
        _zoomAnimation: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);
            L.DomUtil.setPosition(this._container, pos);
        },
        _adjustPan: function() {
            if (!this.options.autoPan) {
                return;
            }
            var map = this._map, containerHeight = this._container.offsetHeight, containerWidth = this._containerWidth, layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);
            if (this._animated) {
                layerPos._add(L.DomUtil.getPosition(this._container));
            }
            var containerPos = map.layerPointToContainerPoint(layerPos), padding = L.point(this.options.autoPanPadding), paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding), paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
                dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
                dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
                dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
                dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
                map.fire("autopanstart").panBy([ dx, dy ]);
            }
        },
        _onCloseButtonClick: function(e) {
            this._close();
            L.DomEvent.stop(e);
        }
    });
    L.popup = function(options, source) {
        return new L.Popup(options, source);
    };
    L.Map.include({
        openPopup: function(popup, latlng, options) {
            this.closePopup();
            if (!(popup instanceof L.Popup)) {
                var content = popup;
                popup = new L.Popup(options).setLatLng(latlng).setContent(content);
            }
            popup._isOpen = true;
            this._popup = popup;
            return this.addLayer(popup);
        },
        closePopup: function(popup) {
            if (!popup || popup === this._popup) {
                popup = this._popup;
                this._popup = null;
            }
            if (popup) {
                this.removeLayer(popup);
                popup._isOpen = false;
            }
            return this;
        }
    });
    L.Marker.include({
        openPopup: function() {
            if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
                this._popup.setLatLng(this._latlng);
                this._map.openPopup(this._popup);
            }
            return this;
        },
        closePopup: function() {
            if (this._popup) {
                this._popup._close();
            }
            return this;
        },
        togglePopup: function() {
            if (this._popup) {
                if (this._popup._isOpen) {
                    this.closePopup();
                } else {
                    this.openPopup();
                }
            }
            return this;
        },
        bindPopup: function(content, options) {
            var anchor = L.point(this.options.icon.options.popupAnchor || [ 0, 0 ]);
            anchor = anchor.add(L.Popup.prototype.options.offset);
            if (options && options.offset) {
                anchor = anchor.add(options.offset);
            }
            options = L.extend({
                offset: anchor
            }, options);
            if (!this._popupHandlersAdded) {
                this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this);
                this._popupHandlersAdded = true;
            }
            if (content instanceof L.Popup) {
                L.setOptions(content, options);
                this._popup = content;
            } else {
                this._popup = new L.Popup(options, this).setContent(content);
            }
            return this;
        },
        setPopupContent: function(content) {
            if (this._popup) {
                this._popup.setContent(content);
            }
            return this;
        },
        unbindPopup: function() {
            if (this._popup) {
                this._popup = null;
                this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this);
                this._popupHandlersAdded = false;
            }
            return this;
        },
        getPopup: function() {
            return this._popup;
        },
        _movePopup: function(e) {
            this._popup.setLatLng(e.latlng);
        }
    });
    L.LayerGroup = L.Class.extend({
        initialize: function(layers) {
            this._layers = {};
            var i, len;
            if (layers) {
                for (i = 0, len = layers.length; i < len; i++) {
                    this.addLayer(layers[i]);
                }
            }
        },
        addLayer: function(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) {
                this._map.addLayer(layer);
            }
            return this;
        },
        removeLayer: function(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) {
                this._map.removeLayer(this._layers[id]);
            }
            delete this._layers[id];
            return this;
        },
        hasLayer: function(layer) {
            if (!layer) {
                return false;
            }
            return layer in this._layers || this.getLayerId(layer) in this._layers;
        },
        clearLayers: function() {
            this.eachLayer(this.removeLayer, this);
            return this;
        },
        invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i, layer;
            for (i in this._layers) {
                layer = this._layers[i];
                if (layer[methodName]) {
                    layer[methodName].apply(layer, args);
                }
            }
            return this;
        },
        onAdd: function(map) {
            this._map = map;
            this.eachLayer(map.addLayer, map);
        },
        onRemove: function(map) {
            this.eachLayer(map.removeLayer, map);
            this._map = null;
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        eachLayer: function(method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },
        getLayer: function(id) {
            return this._layers[id];
        },
        getLayers: function() {
            var layers = [];
            for (var i in this._layers) {
                layers.push(this._layers[i]);
            }
            return layers;
        },
        setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
        },
        getLayerId: function(layer) {
            return L.stamp(layer);
        }
    });
    L.layerGroup = function(layers) {
        return new L.LayerGroup(layers);
    };
    L.FeatureGroup = L.LayerGroup.extend({
        includes: L.Mixin.Events,
        statics: {
            EVENTS: "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"
        },
        addLayer: function(layer) {
            if (this.hasLayer(layer)) {
                return this;
            }
            if ("on" in layer) {
                layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
            }
            L.LayerGroup.prototype.addLayer.call(this, layer);
            if (this._popupContent && layer.bindPopup) {
                layer.bindPopup(this._popupContent, this._popupOptions);
            }
            return this.fire("layeradd", {
                layer: layer
            });
        },
        removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
                return this;
            }
            if (layer in this._layers) {
                layer = this._layers[layer];
            }
            layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);
            L.LayerGroup.prototype.removeLayer.call(this, layer);
            if (this._popupContent) {
                this.invoke("unbindPopup");
            }
            return this.fire("layerremove", {
                layer: layer
            });
        },
        bindPopup: function(content, options) {
            this._popupContent = content;
            this._popupOptions = options;
            return this.invoke("bindPopup", content, options);
        },
        openPopup: function(latlng) {
            for (var id in this._layers) {
                this._layers[id].openPopup(latlng);
                break;
            }
            return this;
        },
        setStyle: function(style) {
            return this.invoke("setStyle", style);
        },
        bringToFront: function() {
            return this.invoke("bringToFront");
        },
        bringToBack: function() {
            return this.invoke("bringToBack");
        },
        getBounds: function() {
            var bounds = new L.LatLngBounds();
            this.eachLayer(function(layer) {
                bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
            });
            return bounds;
        },
        _propagateEvent: function(e) {
            e = L.extend({
                layer: e.target,
                target: this
            }, e);
            this.fire(e.type, e);
        }
    });
    L.featureGroup = function(layers) {
        return new L.FeatureGroup(layers);
    };
    L.Path = L.Class.extend({
        includes: [ L.Mixin.Events ],
        statics: {
            CLIP_PADDING: function() {
                var max = L.Browser.mobile ? 1280 : 2e3, target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
                return Math.max(0, Math.min(.5, target));
            }()
        },
        options: {
            stroke: true,
            color: "#0033ff",
            dashArray: null,
            lineCap: null,
            lineJoin: null,
            weight: 5,
            opacity: .5,
            fill: false,
            fillColor: null,
            fillOpacity: .2,
            clickable: true
        },
        initialize: function(options) {
            L.setOptions(this, options);
        },
        onAdd: function(map) {
            this._map = map;
            if (!this._container) {
                this._initElements();
                this._initEvents();
            }
            this.projectLatlngs();
            this._updatePath();
            if (this._container) {
                this._map._pathRoot.appendChild(this._container);
            }
            this.fire("add");
            map.on({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this);
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        onRemove: function(map) {
            map._pathRoot.removeChild(this._container);
            this.fire("remove");
            this._map = null;
            if (L.Browser.vml) {
                this._container = null;
                this._stroke = null;
                this._fill = null;
            }
            map.off({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this);
        },
        projectLatlngs: function() {},
        setStyle: function(style) {
            L.setOptions(this, style);
            if (this._container) {
                this._updateStyle();
            }
            return this;
        },
        redraw: function() {
            if (this._map) {
                this.projectLatlngs();
                this._updatePath();
            }
            return this;
        }
    });
    L.Map.include({
        _updatePathViewport: function() {
            var p = L.Path.CLIP_PADDING, size = this.getSize(), panePos = L.DomUtil.getPosition(this._mapPane), min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()), max = min.add(size.multiplyBy(1 + p * 2)._round());
            this._pathViewport = new L.Bounds(min, max);
        }
    });
    L.Path.SVG_NS = "http://www.w3.org/2000/svg";
    L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, "svg").createSVGRect);
    L.Path = L.Path.extend({
        statics: {
            SVG: L.Browser.svg
        },
        bringToFront: function() {
            var root = this._map._pathRoot, path = this._container;
            if (path && root.lastChild !== path) {
                root.appendChild(path);
            }
            return this;
        },
        bringToBack: function() {
            var root = this._map._pathRoot, path = this._container, first = root.firstChild;
            if (path && first !== path) {
                root.insertBefore(path, first);
            }
            return this;
        },
        getPathString: function() {},
        _createElement: function(name) {
            return document.createElementNS(L.Path.SVG_NS, name);
        },
        _initElements: function() {
            this._map._initPathRoot();
            this._initPath();
            this._initStyle();
        },
        _initPath: function() {
            this._container = this._createElement("g");
            this._path = this._createElement("path");
            if (this.options.className) {
                L.DomUtil.addClass(this._path, this.options.className);
            }
            this._container.appendChild(this._path);
        },
        _initStyle: function() {
            if (this.options.stroke) {
                this._path.setAttribute("stroke-linejoin", "round");
                this._path.setAttribute("stroke-linecap", "round");
            }
            if (this.options.fill) {
                this._path.setAttribute("fill-rule", "evenodd");
            }
            if (this.options.pointerEvents) {
                this._path.setAttribute("pointer-events", this.options.pointerEvents);
            }
            if (!this.options.clickable && !this.options.pointerEvents) {
                this._path.setAttribute("pointer-events", "none");
            }
            this._updateStyle();
        },
        _updateStyle: function() {
            if (this.options.stroke) {
                this._path.setAttribute("stroke", this.options.color);
                this._path.setAttribute("stroke-opacity", this.options.opacity);
                this._path.setAttribute("stroke-width", this.options.weight);
                if (this.options.dashArray) {
                    this._path.setAttribute("stroke-dasharray", this.options.dashArray);
                } else {
                    this._path.removeAttribute("stroke-dasharray");
                }
                if (this.options.lineCap) {
                    this._path.setAttribute("stroke-linecap", this.options.lineCap);
                }
                if (this.options.lineJoin) {
                    this._path.setAttribute("stroke-linejoin", this.options.lineJoin);
                }
            } else {
                this._path.setAttribute("stroke", "none");
            }
            if (this.options.fill) {
                this._path.setAttribute("fill", this.options.fillColor || this.options.color);
                this._path.setAttribute("fill-opacity", this.options.fillOpacity);
            } else {
                this._path.setAttribute("fill", "none");
            }
        },
        _updatePath: function() {
            var str = this.getPathString();
            if (!str) {
                str = "M0 0";
            }
            this._path.setAttribute("d", str);
        },
        _initEvents: function() {
            if (this.options.clickable) {
                if (L.Browser.svg || !L.Browser.vml) {
                    L.DomUtil.addClass(this._path, "leaflet-clickable");
                }
                L.DomEvent.on(this._container, "click", this._onMouseClick, this);
                var events = [ "dblclick", "mousedown", "mouseover", "mouseout", "mousemove", "contextmenu" ];
                for (var i = 0; i < events.length; i++) {
                    L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
                }
            }
        },
        _onMouseClick: function(e) {
            if (this._map.dragging && this._map.dragging.moved()) {
                return;
            }
            this._fireMouseEvent(e);
        },
        _fireMouseEvent: function(e) {
            if (!this.hasEventListeners(e.type)) {
                return;
            }
            var map = this._map, containerPoint = map.mouseEventToContainerPoint(e), layerPoint = map.containerPointToLayerPoint(containerPoint), latlng = map.layerPointToLatLng(layerPoint);
            this.fire(e.type, {
                latlng: latlng,
                layerPoint: layerPoint,
                containerPoint: containerPoint,
                originalEvent: e
            });
            if (e.type === "contextmenu") {
                L.DomEvent.preventDefault(e);
            }
            if (e.type !== "mousemove") {
                L.DomEvent.stopPropagation(e);
            }
        }
    });
    L.Map.include({
        _initPathRoot: function() {
            if (!this._pathRoot) {
                this._pathRoot = L.Path.prototype._createElement("svg");
                this._panes.overlayPane.appendChild(this._pathRoot);
                if (this.options.zoomAnimation && L.Browser.any3d) {
                    L.DomUtil.addClass(this._pathRoot, "leaflet-zoom-animated");
                    this.on({
                        zoomanim: this._animatePathZoom,
                        zoomend: this._endPathZoom
                    });
                } else {
                    L.DomUtil.addClass(this._pathRoot, "leaflet-zoom-hide");
                }
                this.on("moveend", this._updateSvgViewport);
                this._updateSvgViewport();
            }
        },
        _animatePathZoom: function(e) {
            var scale = this.getZoomScale(e.zoom), offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);
            this._pathRoot.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + " scale(" + scale + ") ";
            this._pathZooming = true;
        },
        _endPathZoom: function() {
            this._pathZooming = false;
        },
        _updateSvgViewport: function() {
            if (this._pathZooming) {
                return;
            }
            this._updatePathViewport();
            var vp = this._pathViewport, min = vp.min, max = vp.max, width = max.x - min.x, height = max.y - min.y, root = this._pathRoot, pane = this._panes.overlayPane;
            if (L.Browser.mobileWebkit) {
                pane.removeChild(root);
            }
            L.DomUtil.setPosition(root, min);
            root.setAttribute("width", width);
            root.setAttribute("height", height);
            root.setAttribute("viewBox", [ min.x, min.y, width, height ].join(" "));
            if (L.Browser.mobileWebkit) {
                pane.appendChild(root);
            }
        }
    });
    L.Path.include({
        bindPopup: function(content, options) {
            if (content instanceof L.Popup) {
                this._popup = content;
            } else {
                if (!this._popup || options) {
                    this._popup = new L.Popup(options, this);
                }
                this._popup.setContent(content);
            }
            if (!this._popupHandlersAdded) {
                this.on("click", this._openPopup, this).on("remove", this.closePopup, this);
                this._popupHandlersAdded = true;
            }
            return this;
        },
        unbindPopup: function() {
            if (this._popup) {
                this._popup = null;
                this.off("click", this._openPopup).off("remove", this.closePopup);
                this._popupHandlersAdded = false;
            }
            return this;
        },
        openPopup: function(latlng) {
            if (this._popup) {
                latlng = latlng || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)];
                this._openPopup({
                    latlng: latlng
                });
            }
            return this;
        },
        closePopup: function() {
            if (this._popup) {
                this._popup._close();
            }
            return this;
        },
        _openPopup: function(e) {
            this._popup.setLatLng(e.latlng);
            this._map.openPopup(this._popup);
        }
    });
    L.Browser.vml = !L.Browser.svg && function() {
        try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
        } catch (e) {
            return false;
        }
    }();
    L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
        statics: {
            VML: true,
            CLIP_PADDING: .02
        },
        _createElement: function() {
            try {
                document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
                return function(name) {
                    return document.createElement("<lvml:" + name + ' class="lvml">');
                };
            } catch (e) {
                return function(name) {
                    return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                };
            }
        }(),
        _initPath: function() {
            var container = this._container = this._createElement("shape");
            L.DomUtil.addClass(container, "leaflet-vml-shape" + (this.options.className ? " " + this.options.className : ""));
            if (this.options.clickable) {
                L.DomUtil.addClass(container, "leaflet-clickable");
            }
            container.coordsize = "1 1";
            this._path = this._createElement("path");
            container.appendChild(this._path);
            this._map._pathRoot.appendChild(container);
        },
        _initStyle: function() {
            this._updateStyle();
        },
        _updateStyle: function() {
            var stroke = this._stroke, fill = this._fill, options = this.options, container = this._container;
            container.stroked = options.stroke;
            container.filled = options.fill;
            if (options.stroke) {
                if (!stroke) {
                    stroke = this._stroke = this._createElement("stroke");
                    stroke.endcap = "round";
                    container.appendChild(stroke);
                }
                stroke.weight = options.weight + "px";
                stroke.color = options.color;
                stroke.opacity = options.opacity;
                if (options.dashArray) {
                    stroke.dashStyle = L.Util.isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
                } else {
                    stroke.dashStyle = "";
                }
                if (options.lineCap) {
                    stroke.endcap = options.lineCap.replace("butt", "flat");
                }
                if (options.lineJoin) {
                    stroke.joinstyle = options.lineJoin;
                }
            } else if (stroke) {
                container.removeChild(stroke);
                this._stroke = null;
            }
            if (options.fill) {
                if (!fill) {
                    fill = this._fill = this._createElement("fill");
                    container.appendChild(fill);
                }
                fill.color = options.fillColor || options.color;
                fill.opacity = options.fillOpacity;
            } else if (fill) {
                container.removeChild(fill);
                this._fill = null;
            }
        },
        _updatePath: function() {
            var style = this._container.style;
            style.display = "none";
            this._path.v = this.getPathString() + " ";
            style.display = "";
        }
    });
    L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
        _initPathRoot: function() {
            if (this._pathRoot) {
                return;
            }
            var root = this._pathRoot = document.createElement("div");
            root.className = "leaflet-vml-container";
            this._panes.overlayPane.appendChild(root);
            this.on("moveend", this._updatePathViewport);
            this._updatePathViewport();
        }
    });
    L.Browser.canvas = function() {
        return !!document.createElement("canvas").getContext;
    }();
    L.Path = L.Path.SVG && !window.L_PREFER_CANVAS || !L.Browser.canvas ? L.Path : L.Path.extend({
        statics: {
            CANVAS: true,
            SVG: false
        },
        redraw: function() {
            if (this._map) {
                this.projectLatlngs();
                this._requestUpdate();
            }
            return this;
        },
        setStyle: function(style) {
            L.setOptions(this, style);
            if (this._map) {
                this._updateStyle();
                this._requestUpdate();
            }
            return this;
        },
        onRemove: function(map) {
            map.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this);
            if (this.options.clickable) {
                this._map.off("click", this._onClick, this);
                this._map.off("mousemove", this._onMouseMove, this);
            }
            this._requestUpdate();
            this.fire("remove");
            this._map = null;
        },
        _requestUpdate: function() {
            if (this._map && !L.Path._updateRequest) {
                L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
            }
        },
        _fireMapMoveEnd: function() {
            L.Path._updateRequest = null;
            this.fire("moveend");
        },
        _initElements: function() {
            this._map._initPathRoot();
            this._ctx = this._map._canvasCtx;
        },
        _updateStyle: function() {
            var options = this.options;
            if (options.stroke) {
                this._ctx.lineWidth = options.weight;
                this._ctx.strokeStyle = options.color;
            }
            if (options.fill) {
                this._ctx.fillStyle = options.fillColor || options.color;
            }
        },
        _drawPath: function() {
            var i, j, len, len2, point, drawMethod;
            this._ctx.beginPath();
            for (i = 0, len = this._parts.length; i < len; i++) {
                for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
                    point = this._parts[i][j];
                    drawMethod = (j === 0 ? "move" : "line") + "To";
                    this._ctx[drawMethod](point.x, point.y);
                }
                if (this instanceof L.Polygon) {
                    this._ctx.closePath();
                }
            }
        },
        _checkIfEmpty: function() {
            return !this._parts.length;
        },
        _updatePath: function() {
            if (this._checkIfEmpty()) {
                return;
            }
            var ctx = this._ctx, options = this.options;
            this._drawPath();
            ctx.save();
            this._updateStyle();
            if (options.fill) {
                ctx.globalAlpha = options.fillOpacity;
                ctx.fill();
            }
            if (options.stroke) {
                ctx.globalAlpha = options.opacity;
                ctx.stroke();
            }
            ctx.restore();
        },
        _initEvents: function() {
            if (this.options.clickable) {
                this._map.on("mousemove", this._onMouseMove, this);
                this._map.on("click", this._onClick, this);
            }
        },
        _onClick: function(e) {
            if (this._containsPoint(e.layerPoint)) {
                this.fire("click", e);
            }
        },
        _onMouseMove: function(e) {
            if (!this._map || this._map._animatingZoom) {
                return;
            }
            if (this._containsPoint(e.layerPoint)) {
                this._ctx.canvas.style.cursor = "pointer";
                this._mouseInside = true;
                this.fire("mouseover", e);
            } else if (this._mouseInside) {
                this._ctx.canvas.style.cursor = "";
                this._mouseInside = false;
                this.fire("mouseout", e);
            }
        }
    });
    L.Map.include(L.Path.SVG && !window.L_PREFER_CANVAS || !L.Browser.canvas ? {} : {
        _initPathRoot: function() {
            var root = this._pathRoot, ctx;
            if (!root) {
                root = this._pathRoot = document.createElement("canvas");
                root.style.position = "absolute";
                ctx = this._canvasCtx = root.getContext("2d");
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                this._panes.overlayPane.appendChild(root);
                if (this.options.zoomAnimation) {
                    this._pathRoot.className = "leaflet-zoom-animated";
                    this.on("zoomanim", this._animatePathZoom);
                    this.on("zoomend", this._endPathZoom);
                }
                this.on("moveend", this._updateCanvasViewport);
                this._updateCanvasViewport();
            }
        },
        _updateCanvasViewport: function() {
            if (this._pathZooming) {
                return;
            }
            this._updatePathViewport();
            var vp = this._pathViewport, min = vp.min, size = vp.max.subtract(min), root = this._pathRoot;
            L.DomUtil.setPosition(root, min);
            root.width = size.x;
            root.height = size.y;
            root.getContext("2d").translate(-min.x, -min.y);
        }
    });
    L.LineUtil = {
        simplify: function(points, tolerance) {
            if (!tolerance || !points.length) {
                return points.slice();
            }
            var sqTolerance = tolerance * tolerance;
            points = this._reducePoints(points, sqTolerance);
            points = this._simplifyDP(points, sqTolerance);
            return points;
        },
        pointToSegmentDistance: function(p, p1, p2) {
            return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
        },
        closestPointOnSegment: function(p, p1, p2) {
            return this._sqClosestPointOnSegment(p, p1, p2);
        },
        _simplifyDP: function(points, sqTolerance) {
            var len = points.length, ArrayConstructor = typeof Uint8Array !== undefined + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
            markers[0] = markers[len - 1] = 1;
            this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
            var i, newPoints = [];
            for (i = 0; i < len; i++) {
                if (markers[i]) {
                    newPoints.push(points[i]);
                }
            }
            return newPoints;
        },
        _simplifyDPStep: function(points, markers, sqTolerance, first, last) {
            var maxSqDist = 0, index, i, sqDist;
            for (i = first + 1; i <= last - 1; i++) {
                sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);
                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }
            if (maxSqDist > sqTolerance) {
                markers[index] = 1;
                this._simplifyDPStep(points, markers, sqTolerance, first, index);
                this._simplifyDPStep(points, markers, sqTolerance, index, last);
            }
        },
        _reducePoints: function(points, sqTolerance) {
            var reducedPoints = [ points[0] ];
            for (var i = 1, prev = 0, len = points.length; i < len; i++) {
                if (this._sqDist(points[i], points[prev]) > sqTolerance) {
                    reducedPoints.push(points[i]);
                    prev = i;
                }
            }
            if (prev < len - 1) {
                reducedPoints.push(points[len - 1]);
            }
            return reducedPoints;
        },
        clipSegment: function(a, b, bounds, useLastCode) {
            var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds), codeB = this._getBitCode(b, bounds), codeOut, p, newCode;
            this._lastCode = codeB;
            while (true) {
                if (!(codeA | codeB)) {
                    return [ a, b ];
                } else if (codeA & codeB) {
                    return false;
                } else {
                    codeOut = codeA || codeB;
                    p = this._getEdgeIntersection(a, b, codeOut, bounds);
                    newCode = this._getBitCode(p, bounds);
                    if (codeOut === codeA) {
                        a = p;
                        codeA = newCode;
                    } else {
                        b = p;
                        codeB = newCode;
                    }
                }
            }
        },
        _getEdgeIntersection: function(a, b, code, bounds) {
            var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max;
            if (code & 8) {
                return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
            } else if (code & 4) {
                return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
            } else if (code & 2) {
                return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
            } else if (code & 1) {
                return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
            }
        },
        _getBitCode: function(p, bounds) {
            var code = 0;
            if (p.x < bounds.min.x) {
                code |= 1;
            } else if (p.x > bounds.max.x) {
                code |= 2;
            }
            if (p.y < bounds.min.y) {
                code |= 4;
            } else if (p.y > bounds.max.y) {
                code |= 8;
            }
            return code;
        },
        _sqDist: function(p1, p2) {
            var dx = p2.x - p1.x, dy = p2.y - p1.y;
            return dx * dx + dy * dy;
        },
        _sqClosestPointOnSegment: function(p, p1, p2, sqDist) {
            var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
            if (dot > 0) {
                t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
                if (t > 1) {
                    x = p2.x;
                    y = p2.y;
                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }
            dx = p.x - x;
            dy = p.y - y;
            return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
        }
    };
    L.Polyline = L.Path.extend({
        initialize: function(latlngs, options) {
            L.Path.prototype.initialize.call(this, options);
            this._latlngs = this._convertLatLngs(latlngs);
        },
        options: {
            smoothFactor: 1,
            noClip: false
        },
        projectLatlngs: function() {
            this._originalPoints = [];
            for (var i = 0, len = this._latlngs.length; i < len; i++) {
                this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
            }
        },
        getPathString: function() {
            for (var i = 0, len = this._parts.length, str = ""; i < len; i++) {
                str += this._getPathPartStr(this._parts[i]);
            }
            return str;
        },
        getLatLngs: function() {
            return this._latlngs;
        },
        setLatLngs: function(latlngs) {
            this._latlngs = this._convertLatLngs(latlngs);
            return this.redraw();
        },
        addLatLng: function(latlng) {
            this._latlngs.push(L.latLng(latlng));
            return this.redraw();
        },
        spliceLatLngs: function() {
            var removed = [].splice.apply(this._latlngs, arguments);
            this._convertLatLngs(this._latlngs, true);
            this.redraw();
            return removed;
        },
        closestLayerPoint: function(p) {
            var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;
            for (var j = 0, jLen = parts.length; j < jLen; j++) {
                var points = parts[j];
                for (var i = 1, len = points.length; i < len; i++) {
                    p1 = points[i - 1];
                    p2 = points[i];
                    var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
                    if (sqDist < minDistance) {
                        minDistance = sqDist;
                        minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
                    }
                }
            }
            if (minPoint) {
                minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
        },
        getBounds: function() {
            return new L.LatLngBounds(this.getLatLngs());
        },
        _convertLatLngs: function(latlngs, overwrite) {
            var i, len, target = overwrite ? latlngs : [];
            for (i = 0, len = latlngs.length; i < len; i++) {
                if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== "number") {
                    return;
                }
                target[i] = L.latLng(latlngs[i]);
            }
            return target;
        },
        _initEvents: function() {
            L.Path.prototype._initEvents.call(this);
        },
        _getPathPartStr: function(points) {
            var round = L.Path.VML;
            for (var j = 0, len2 = points.length, str = "", p; j < len2; j++) {
                p = points[j];
                if (round) {
                    p._round();
                }
                str += (j ? "L" : "M") + p.x + " " + p.y;
            }
            return str;
        },
        _clipPoints: function() {
            var points = this._originalPoints, len = points.length, i, k, segment;
            if (this.options.noClip) {
                this._parts = [ points ];
                return;
            }
            this._parts = [];
            var parts = this._parts, vp = this._map._pathViewport, lu = L.LineUtil;
            for (i = 0, k = 0; i < len - 1; i++) {
                segment = lu.clipSegment(points[i], points[i + 1], vp, i);
                if (!segment) {
                    continue;
                }
                parts[k] = parts[k] || [];
                parts[k].push(segment[0]);
                if (segment[1] !== points[i + 1] || i === len - 2) {
                    parts[k].push(segment[1]);
                    k++;
                }
            }
        },
        _simplifyPoints: function() {
            var parts = this._parts, lu = L.LineUtil;
            for (var i = 0, len = parts.length; i < len; i++) {
                parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
            }
        },
        _updatePath: function() {
            if (!this._map) {
                return;
            }
            this._clipPoints();
            this._simplifyPoints();
            L.Path.prototype._updatePath.call(this);
        }
    });
    L.polyline = function(latlngs, options) {
        return new L.Polyline(latlngs, options);
    };
    L.PolyUtil = {};
    L.PolyUtil.clipPolygon = function(points, bounds) {
        var clippedPoints, edges = [ 1, 4, 2, 8 ], i, j, k, a, b, len, edge, p, lu = L.LineUtil;
        for (i = 0, len = points.length; i < len; i++) {
            points[i]._code = lu._getBitCode(points[i], bounds);
        }
        for (k = 0; k < 4; k++) {
            edge = edges[k];
            clippedPoints = [];
            for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                a = points[i];
                b = points[j];
                if (!(a._code & edge)) {
                    if (b._code & edge) {
                        p = lu._getEdgeIntersection(b, a, edge, bounds);
                        p._code = lu._getBitCode(p, bounds);
                        clippedPoints.push(p);
                    }
                    clippedPoints.push(a);
                } else if (!(b._code & edge)) {
                    p = lu._getEdgeIntersection(b, a, edge, bounds);
                    p._code = lu._getBitCode(p, bounds);
                    clippedPoints.push(p);
                }
            }
            points = clippedPoints;
        }
        return points;
    };
    L.Polygon = L.Polyline.extend({
        options: {
            fill: true
        },
        initialize: function(latlngs, options) {
            L.Polyline.prototype.initialize.call(this, latlngs, options);
            this._initWithHoles(latlngs);
        },
        _initWithHoles: function(latlngs) {
            var i, len, hole;
            if (latlngs && L.Util.isArray(latlngs[0]) && typeof latlngs[0][0] !== "number") {
                this._latlngs = this._convertLatLngs(latlngs[0]);
                this._holes = latlngs.slice(1);
                for (i = 0, len = this._holes.length; i < len; i++) {
                    hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
                    if (hole[0].equals(hole[hole.length - 1])) {
                        hole.pop();
                    }
                }
            }
            latlngs = this._latlngs;
            if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
                latlngs.pop();
            }
        },
        projectLatlngs: function() {
            L.Polyline.prototype.projectLatlngs.call(this);
            this._holePoints = [];
            if (!this._holes) {
                return;
            }
            var i, j, len, len2;
            for (i = 0, len = this._holes.length; i < len; i++) {
                this._holePoints[i] = [];
                for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
                    this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
                }
            }
        },
        setLatLngs: function(latlngs) {
            if (latlngs && L.Util.isArray(latlngs[0]) && typeof latlngs[0][0] !== "number") {
                this._initWithHoles(latlngs);
                return this.redraw();
            } else {
                return L.Polyline.prototype.setLatLngs.call(this, latlngs);
            }
        },
        _clipPoints: function() {
            var points = this._originalPoints, newParts = [];
            this._parts = [ points ].concat(this._holePoints);
            if (this.options.noClip) {
                return;
            }
            for (var i = 0, len = this._parts.length; i < len; i++) {
                var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
                if (clipped.length) {
                    newParts.push(clipped);
                }
            }
            this._parts = newParts;
        },
        _getPathPartStr: function(points) {
            var str = L.Polyline.prototype._getPathPartStr.call(this, points);
            return str + (L.Browser.svg ? "z" : "x");
        }
    });
    L.polygon = function(latlngs, options) {
        return new L.Polygon(latlngs, options);
    };
    (function() {
        function createMulti(Klass) {
            return L.FeatureGroup.extend({
                initialize: function(latlngs, options) {
                    this._layers = {};
                    this._options = options;
                    this.setLatLngs(latlngs);
                },
                setLatLngs: function(latlngs) {
                    var i = 0, len = latlngs.length;
                    this.eachLayer(function(layer) {
                        if (i < len) {
                            layer.setLatLngs(latlngs[i++]);
                        } else {
                            this.removeLayer(layer);
                        }
                    }, this);
                    while (i < len) {
                        this.addLayer(new Klass(latlngs[i++], this._options));
                    }
                    return this;
                },
                getLatLngs: function() {
                    var latlngs = [];
                    this.eachLayer(function(layer) {
                        latlngs.push(layer.getLatLngs());
                    });
                    return latlngs;
                }
            });
        }
        L.MultiPolyline = createMulti(L.Polyline);
        L.MultiPolygon = createMulti(L.Polygon);
        L.multiPolyline = function(latlngs, options) {
            return new L.MultiPolyline(latlngs, options);
        };
        L.multiPolygon = function(latlngs, options) {
            return new L.MultiPolygon(latlngs, options);
        };
    })();
    L.Rectangle = L.Polygon.extend({
        initialize: function(latLngBounds, options) {
            L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
        },
        setBounds: function(latLngBounds) {
            this.setLatLngs(this._boundsToLatLngs(latLngBounds));
        },
        _boundsToLatLngs: function(latLngBounds) {
            latLngBounds = L.latLngBounds(latLngBounds);
            return [ latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast() ];
        }
    });
    L.rectangle = function(latLngBounds, options) {
        return new L.Rectangle(latLngBounds, options);
    };
    L.Circle = L.Path.extend({
        initialize: function(latlng, radius, options) {
            L.Path.prototype.initialize.call(this, options);
            this._latlng = L.latLng(latlng);
            this._mRadius = radius;
        },
        options: {
            fill: true
        },
        setLatLng: function(latlng) {
            this._latlng = L.latLng(latlng);
            return this.redraw();
        },
        setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
        },
        projectLatlngs: function() {
            var lngRadius = this._getLngRadius(), latlng = this._latlng, pointLeft = this._map.latLngToLayerPoint([ latlng.lat, latlng.lng - lngRadius ]);
            this._point = this._map.latLngToLayerPoint(latlng);
            this._radius = Math.max(this._point.x - pointLeft.x, 1);
        },
        getBounds: function() {
            var lngRadius = this._getLngRadius(), latRadius = this._mRadius / 40075017 * 360, latlng = this._latlng;
            return new L.LatLngBounds([ latlng.lat - latRadius, latlng.lng - lngRadius ], [ latlng.lat + latRadius, latlng.lng + lngRadius ]);
        },
        getLatLng: function() {
            return this._latlng;
        },
        getPathString: function() {
            var p = this._point, r = this._radius;
            if (this._checkIfEmpty()) {
                return "";
            }
            if (L.Browser.svg) {
                return "M" + p.x + "," + (p.y - r) + "A" + r + "," + r + ",0,1,1," + (p.x - .1) + "," + (p.y - r) + " z";
            } else {
                p._round();
                r = Math.round(r);
                return "AL " + p.x + "," + p.y + " " + r + "," + r + " 0," + 65535 * 360;
            }
        },
        getRadius: function() {
            return this._mRadius;
        },
        _getLatRadius: function() {
            return this._mRadius / 40075017 * 360;
        },
        _getLngRadius: function() {
            return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
        },
        _checkIfEmpty: function() {
            if (!this._map) {
                return false;
            }
            var vp = this._map._pathViewport, r = this._radius, p = this._point;
            return p.x - r > vp.max.x || p.y - r > vp.max.y || p.x + r < vp.min.x || p.y + r < vp.min.y;
        }
    });
    L.circle = function(latlng, radius, options) {
        return new L.Circle(latlng, radius, options);
    };
    L.CircleMarker = L.Circle.extend({
        options: {
            radius: 10,
            weight: 2
        },
        initialize: function(latlng, options) {
            L.Circle.prototype.initialize.call(this, latlng, null, options);
            this._radius = this.options.radius;
        },
        projectLatlngs: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
        },
        _updateStyle: function() {
            L.Circle.prototype._updateStyle.call(this);
            this.setRadius(this.options.radius);
        },
        setLatLng: function(latlng) {
            L.Circle.prototype.setLatLng.call(this, latlng);
            if (this._popup && this._popup._isOpen) {
                this._popup.setLatLng(latlng);
            }
            return this;
        },
        setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
        },
        getRadius: function() {
            return this._radius;
        }
    });
    L.circleMarker = function(latlng, options) {
        return new L.CircleMarker(latlng, options);
    };
    L.Polyline.include(!L.Path.CANVAS ? {} : {
        _containsPoint: function(p, closed) {
            var i, j, k, len, len2, dist, part, w = this.options.weight / 2;
            if (L.Browser.touch) {
                w += 10;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];
                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    if (!closed && j === 0) {
                        continue;
                    }
                    dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);
                    if (dist <= w) {
                        return true;
                    }
                }
            }
            return false;
        }
    });
    L.Polygon.include(!L.Path.CANVAS ? {} : {
        _containsPoint: function(p) {
            var inside = false, part, p1, p2, i, j, k, len, len2;
            if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
                return true;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];
                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    p1 = part[j];
                    p2 = part[k];
                    if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                        inside = !inside;
                    }
                }
            }
            return inside;
        }
    });
    L.Circle.include(!L.Path.CANVAS ? {} : {
        _drawPath: function() {
            var p = this._point;
            this._ctx.beginPath();
            this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
        },
        _containsPoint: function(p) {
            var center = this._point, w2 = this.options.stroke ? this.options.weight / 2 : 0;
            return p.distanceTo(center) <= this._radius + w2;
        }
    });
    L.CircleMarker.include(!L.Path.CANVAS ? {} : {
        _updateStyle: function() {
            L.Path.prototype._updateStyle.call(this);
        }
    });
    L.GeoJSON = L.FeatureGroup.extend({
        initialize: function(geojson, options) {
            L.setOptions(this, options);
            this._layers = {};
            if (geojson) {
                this.addData(geojson);
            }
        },
        addData: function(geojson) {
            var features = L.Util.isArray(geojson) ? geojson : geojson.features, i, len, feature;
            if (features) {
                for (i = 0, len = features.length; i < len; i++) {
                    feature = features[i];
                    if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                        this.addData(features[i]);
                    }
                }
                return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) {
                return;
            }
            var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
            layer.feature = L.GeoJSON.asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) {
                options.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
        },
        resetStyle: function(layer) {
            var style = this.options.style;
            if (style) {
                L.Util.extend(layer.options, layer.defaultOptions);
                this._setLayerStyle(layer, style);
            }
        },
        setStyle: function(style) {
            this.eachLayer(function(layer) {
                this._setLayerStyle(layer, style);
            }, this);
        },
        _setLayerStyle: function(layer, style) {
            if (typeof style === "function") {
                style = style(layer.feature);
            }
            if (layer.setStyle) {
                layer.setStyle(style);
            }
        }
    });
    L.extend(L.GeoJSON, {
        geometryToLayer: function(geojson, pointToLayer, coordsToLatLng, vectorOptions) {
            var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry.coordinates, layers = [], latlng, latlngs, i, len;
            coordsToLatLng = coordsToLatLng || this.coordsToLatLng;
            switch (geometry.type) {
              case "Point":
                latlng = coordsToLatLng(coords);
                return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

              case "MultiPoint":
                for (i = 0, len = coords.length; i < len; i++) {
                    latlng = coordsToLatLng(coords[i]);
                    layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
                }
                return new L.FeatureGroup(layers);

              case "LineString":
                latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
                return new L.Polyline(latlngs, vectorOptions);

              case "Polygon":
                if (coords.length === 2 && !coords[1].length) {
                    throw new Error("Invalid GeoJSON object.");
                }
                latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                return new L.Polygon(latlngs, vectorOptions);

              case "MultiLineString":
                latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                return new L.MultiPolyline(latlngs, vectorOptions);

              case "MultiPolygon":
                latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
                return new L.MultiPolygon(latlngs, vectorOptions);

              case "GeometryCollection":
                for (i = 0, len = geometry.geometries.length; i < len; i++) {
                    layers.push(this.geometryToLayer({
                        geometry: geometry.geometries[i],
                        type: "Feature",
                        properties: geojson.properties
                    }, pointToLayer, coordsToLatLng, vectorOptions));
                }
                return new L.FeatureGroup(layers);

              default:
                throw new Error("Invalid GeoJSON object.");
            }
        },
        coordsToLatLng: function(coords) {
            return new L.LatLng(coords[1], coords[0], coords[2]);
        },
        coordsToLatLngs: function(coords, levelsDeep, coordsToLatLng) {
            var latlng, i, len, latlngs = [];
            for (i = 0, len = coords.length; i < len; i++) {
                latlng = levelsDeep ? this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) : (coordsToLatLng || this.coordsToLatLng)(coords[i]);
                latlngs.push(latlng);
            }
            return latlngs;
        },
        latLngToCoords: function(latlng) {
            var coords = [ latlng.lng, latlng.lat ];
            if (latlng.alt !== undefined) {
                coords.push(latlng.alt);
            }
            return coords;
        },
        latLngsToCoords: function(latLngs) {
            var coords = [];
            for (var i = 0, len = latLngs.length; i < len; i++) {
                coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
            }
            return coords;
        },
        getFeature: function(layer, newGeometry) {
            return layer.feature ? L.extend({}, layer.feature, {
                geometry: newGeometry
            }) : L.GeoJSON.asFeature(newGeometry);
        },
        asFeature: function(geoJSON) {
            if (geoJSON.type === "Feature") {
                return geoJSON;
            }
            return {
                type: "Feature",
                properties: {},
                geometry: geoJSON
            };
        }
    });
    var PointToGeoJSON = {
        toGeoJSON: function() {
            return L.GeoJSON.getFeature(this, {
                type: "Point",
                coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
            });
        }
    };
    L.Marker.include(PointToGeoJSON);
    L.Circle.include(PointToGeoJSON);
    L.CircleMarker.include(PointToGeoJSON);
    L.Polyline.include({
        toGeoJSON: function() {
            return L.GeoJSON.getFeature(this, {
                type: "LineString",
                coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
            });
        }
    });
    L.Polygon.include({
        toGeoJSON: function() {
            var coords = [ L.GeoJSON.latLngsToCoords(this.getLatLngs()) ], i, len, hole;
            coords[0].push(coords[0][0]);
            if (this._holes) {
                for (i = 0, len = this._holes.length; i < len; i++) {
                    hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
                    hole.push(hole[0]);
                    coords.push(hole);
                }
            }
            return L.GeoJSON.getFeature(this, {
                type: "Polygon",
                coordinates: coords
            });
        }
    });
    (function() {
        function multiToGeoJSON(type) {
            return function() {
                var coords = [];
                this.eachLayer(function(layer) {
                    coords.push(layer.toGeoJSON().geometry.coordinates);
                });
                return L.GeoJSON.getFeature(this, {
                    type: type,
                    coordinates: coords
                });
            };
        }
        L.MultiPolyline.include({
            toGeoJSON: multiToGeoJSON("MultiLineString")
        });
        L.MultiPolygon.include({
            toGeoJSON: multiToGeoJSON("MultiPolygon")
        });
        L.LayerGroup.include({
            toGeoJSON: function() {
                var geometry = this.feature && this.feature.geometry, jsons = [], json;
                if (geometry && geometry.type === "MultiPoint") {
                    return multiToGeoJSON("MultiPoint").call(this);
                }
                var isGeometryCollection = geometry && geometry.type === "GeometryCollection";
                this.eachLayer(function(layer) {
                    if (layer.toGeoJSON) {
                        json = layer.toGeoJSON();
                        jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
                    }
                });
                if (isGeometryCollection) {
                    return L.GeoJSON.getFeature(this, {
                        geometries: jsons,
                        type: "GeometryCollection"
                    });
                }
                return {
                    type: "FeatureCollection",
                    features: jsons
                };
            }
        });
    })();
    L.geoJson = function(geojson, options) {
        return new L.GeoJSON(geojson, options);
    };
    L.DomEvent = {
        addListener: function(obj, type, fn, context) {
            var id = L.stamp(fn), key = "_leaflet_" + type + id, handler, originalHandler, newType;
            if (obj[key]) {
                return this;
            }
            handler = function(e) {
                return fn.call(context || obj, e || L.DomEvent._getEvent());
            };
            if (L.Browser.pointer && type.indexOf("touch") === 0) {
                return this.addPointerListener(obj, type, handler, id);
            }
            if (L.Browser.touch && type === "dblclick" && this.addDoubleTapListener) {
                this.addDoubleTapListener(obj, handler, id);
            }
            if ("addEventListener" in obj) {
                if (type === "mousewheel") {
                    obj.addEventListener("DOMMouseScroll", handler, false);
                    obj.addEventListener(type, handler, false);
                } else if (type === "mouseenter" || type === "mouseleave") {
                    originalHandler = handler;
                    newType = type === "mouseenter" ? "mouseover" : "mouseout";
                    handler = function(e) {
                        if (!L.DomEvent._checkMouse(obj, e)) {
                            return;
                        }
                        return originalHandler(e);
                    };
                    obj.addEventListener(newType, handler, false);
                } else if (type === "click" && L.Browser.android) {
                    originalHandler = handler;
                    handler = function(e) {
                        return L.DomEvent._filterClick(e, originalHandler);
                    };
                    obj.addEventListener(type, handler, false);
                } else {
                    obj.addEventListener(type, handler, false);
                }
            } else if ("attachEvent" in obj) {
                obj.attachEvent("on" + type, handler);
            }
            obj[key] = handler;
            return this;
        },
        removeListener: function(obj, type, fn) {
            var id = L.stamp(fn), key = "_leaflet_" + type + id, handler = obj[key];
            if (!handler) {
                return this;
            }
            if (L.Browser.pointer && type.indexOf("touch") === 0) {
                this.removePointerListener(obj, type, id);
            } else if (L.Browser.touch && type === "dblclick" && this.removeDoubleTapListener) {
                this.removeDoubleTapListener(obj, id);
            } else if ("removeEventListener" in obj) {
                if (type === "mousewheel") {
                    obj.removeEventListener("DOMMouseScroll", handler, false);
                    obj.removeEventListener(type, handler, false);
                } else if (type === "mouseenter" || type === "mouseleave") {
                    obj.removeEventListener(type === "mouseenter" ? "mouseover" : "mouseout", handler, false);
                } else {
                    obj.removeEventListener(type, handler, false);
                }
            } else if ("detachEvent" in obj) {
                obj.detachEvent("on" + type, handler);
            }
            obj[key] = null;
            return this;
        },
        stopPropagation: function(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            } else {
                e.cancelBubble = true;
            }
            L.DomEvent._skipped(e);
            return this;
        },
        disableScrollPropagation: function(el) {
            var stop = L.DomEvent.stopPropagation;
            return L.DomEvent.on(el, "mousewheel", stop).on(el, "MozMousePixelScroll", stop);
        },
        disableClickPropagation: function(el) {
            var stop = L.DomEvent.stopPropagation;
            for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                L.DomEvent.on(el, L.Draggable.START[i], stop);
            }
            return L.DomEvent.on(el, "click", L.DomEvent._fakeStop).on(el, "dblclick", stop);
        },
        preventDefault: function(e) {
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            return this;
        },
        stop: function(e) {
            return L.DomEvent.preventDefault(e).stopPropagation(e);
        },
        getMousePosition: function(e, container) {
            if (!container) {
                return new L.Point(e.clientX, e.clientY);
            }
            var rect = container.getBoundingClientRect();
            return new L.Point(e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop);
        },
        getWheelDelta: function(e) {
            var delta = 0;
            if (e.wheelDelta) {
                delta = e.wheelDelta / 120;
            }
            if (e.detail) {
                delta = -e.detail / 3;
            }
            return delta;
        },
        _skipEvents: {},
        _fakeStop: function(e) {
            L.DomEvent._skipEvents[e.type] = true;
        },
        _skipped: function(e) {
            var skipped = this._skipEvents[e.type];
            this._skipEvents[e.type] = false;
            return skipped;
        },
        _checkMouse: function(el, e) {
            var related = e.relatedTarget;
            if (!related) {
                return true;
            }
            try {
                while (related && related !== el) {
                    related = related.parentNode;
                }
            } catch (err) {
                return false;
            }
            return related !== el;
        },
        _getEvent: function() {
            var e = window.event;
            if (!e) {
                var caller = arguments.callee.caller;
                while (caller) {
                    e = caller["arguments"][0];
                    if (e && window.Event === e.constructor) {
                        break;
                    }
                    caller = caller.caller;
                }
            }
            return e;
        },
        _filterClick: function(e, handler) {
            var timeStamp = e.timeStamp || e.originalEvent.timeStamp, elapsed = L.DomEvent._lastClick && timeStamp - L.DomEvent._lastClick;
            if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {
                L.DomEvent.stop(e);
                return;
            }
            L.DomEvent._lastClick = timeStamp;
            return handler(e);
        }
    };
    L.DomEvent.on = L.DomEvent.addListener;
    L.DomEvent.off = L.DomEvent.removeListener;
    L.Draggable = L.Class.extend({
        includes: L.Mixin.Events,
        statics: {
            START: L.Browser.touch ? [ "touchstart", "mousedown" ] : [ "mousedown" ],
            END: {
                mousedown: "mouseup",
                touchstart: "touchend",
                pointerdown: "touchend",
                MSPointerDown: "touchend"
            },
            MOVE: {
                mousedown: "mousemove",
                touchstart: "touchmove",
                pointerdown: "touchmove",
                MSPointerDown: "touchmove"
            }
        },
        initialize: function(element, dragStartTarget) {
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
        },
        enable: function() {
            if (this._enabled) {
                return;
            }
            for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
            }
            this._enabled = true;
        },
        disable: function() {
            if (!this._enabled) {
                return;
            }
            for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
            }
            this._enabled = false;
            this._moved = false;
        },
        _onDown: function(e) {
            this._moved = false;
            if (e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
                return;
            }
            L.DomEvent.stopPropagation(e);
            if (L.Draggable._disabled) {
                return;
            }
            L.DomUtil.disableImageDrag();
            L.DomUtil.disableTextSelection();
            if (this._moving) {
                return;
            }
            var first = e.touches ? e.touches[0] : e;
            this._startPoint = new L.Point(first.clientX, first.clientY);
            this._startPos = this._newPos = L.DomUtil.getPosition(this._element);
            L.DomEvent.on(document, L.Draggable.MOVE[e.type], this._onMove, this).on(document, L.Draggable.END[e.type], this._onUp, this);
        },
        _onMove: function(e) {
            if (e.touches && e.touches.length > 1) {
                this._moved = true;
                return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, newPoint = new L.Point(first.clientX, first.clientY), offset = newPoint.subtract(this._startPoint);
            if (!offset.x && !offset.y) {
                return;
            }
            if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) {
                return;
            }
            L.DomEvent.preventDefault(e);
            if (!this._moved) {
                this.fire("dragstart");
                this._moved = true;
                this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);
                L.DomUtil.addClass(document.body, "leaflet-dragging");
                this._lastTarget = e.target || e.srcElement;
                L.DomUtil.addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            L.Util.cancelAnimFrame(this._animRequest);
            this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
        },
        _updatePosition: function() {
            this.fire("predrag");
            L.DomUtil.setPosition(this._element, this._newPos);
            this.fire("drag");
        },
        _onUp: function() {
            L.DomUtil.removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
                L.DomUtil.removeClass(this._lastTarget, "leaflet-drag-target");
                this._lastTarget = null;
            }
            for (var i in L.Draggable.MOVE) {
                L.DomEvent.off(document, L.Draggable.MOVE[i], this._onMove).off(document, L.Draggable.END[i], this._onUp);
            }
            L.DomUtil.enableImageDrag();
            L.DomUtil.enableTextSelection();
            if (this._moved && this._moving) {
                L.Util.cancelAnimFrame(this._animRequest);
                this.fire("dragend", {
                    distance: this._newPos.distanceTo(this._startPos)
                });
            }
            this._moving = false;
        }
    });
    L.Handler = L.Class.extend({
        initialize: function(map) {
            this._map = map;
        },
        enable: function() {
            if (this._enabled) {
                return;
            }
            this._enabled = true;
            this.addHooks();
        },
        disable: function() {
            if (!this._enabled) {
                return;
            }
            this._enabled = false;
            this.removeHooks();
        },
        enabled: function() {
            return !!this._enabled;
        }
    });
    L.Map.mergeOptions({
        dragging: true,
        inertia: !L.Browser.android23,
        inertiaDeceleration: 3400,
        inertiaMaxSpeed: Infinity,
        inertiaThreshold: L.Browser.touch ? 32 : 18,
        easeLinearity: .25,
        worldCopyJump: false
    });
    L.Map.Drag = L.Handler.extend({
        addHooks: function() {
            if (!this._draggable) {
                var map = this._map;
                this._draggable = new L.Draggable(map._mapPane, map._container);
                this._draggable.on({
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this);
                if (map.options.worldCopyJump) {
                    this._draggable.on("predrag", this._onPreDrag, this);
                    map.on("viewreset", this._onViewReset, this);
                    map.whenReady(this._onViewReset, this);
                }
            }
            this._draggable.enable();
        },
        removeHooks: function() {
            this._draggable.disable();
        },
        moved: function() {
            return this._draggable && this._draggable._moved;
        },
        _onDragStart: function() {
            var map = this._map;
            if (map._panAnim) {
                map._panAnim.stop();
            }
            map.fire("movestart").fire("dragstart");
            if (map.options.inertia) {
                this._positions = [];
                this._times = [];
            }
        },
        _onDrag: function() {
            if (this._map.options.inertia) {
                var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._newPos;
                this._positions.push(pos);
                this._times.push(time);
                if (time - this._times[0] > 200) {
                    this._positions.shift();
                    this._times.shift();
                }
            }
            this._map.fire("move").fire("drag");
        },
        _onViewReset: function() {
            var pxCenter = this._map.getSize()._divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([ 0, 0 ]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.project([ 0, 180 ]).x;
        },
        _onPreDrag: function() {
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._newPos.x = newX;
        },
        _onDragEnd: function(e) {
            var map = this._map, options = map.options, delay = +new Date() - this._lastTime, noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];
            map.fire("dragend", e);
            if (noInertia) {
                map.fire("moveend");
            } else {
                var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime + delay - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([ 0, 0 ]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
                if (!offset.x || !offset.y) {
                    map.fire("moveend");
                } else {
                    offset = map._limitOffset(offset, map.options.maxBounds);
                    L.Util.requestAnimFrame(function() {
                        map.panBy(offset, {
                            duration: decelerationDuration,
                            easeLinearity: ease,
                            noMoveStart: true
                        });
                    });
                }
            }
        }
    });
    L.Map.addInitHook("addHandler", "dragging", L.Map.Drag);
    L.Map.mergeOptions({
        doubleClickZoom: true
    });
    L.Map.DoubleClickZoom = L.Handler.extend({
        addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(e) {
            var map = this._map, zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);
            if (map.options.doubleClickZoom === "center") {
                map.setZoom(zoom);
            } else {
                map.setZoomAround(e.containerPoint, zoom);
            }
        }
    });
    L.Map.addInitHook("addHandler", "doubleClickZoom", L.Map.DoubleClickZoom);
    L.Map.mergeOptions({
        scrollWheelZoom: true
    });
    L.Map.ScrollWheelZoom = L.Handler.extend({
        addHooks: function() {
            L.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this);
            L.DomEvent.on(this._map._container, "MozMousePixelScroll", L.DomEvent.preventDefault);
            this._delta = 0;
        },
        removeHooks: function() {
            L.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll);
            L.DomEvent.off(this._map._container, "MozMousePixelScroll", L.DomEvent.preventDefault);
        },
        _onWheelScroll: function(e) {
            var delta = L.DomEvent.getWheelDelta(e);
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) {
                this._startTime = +new Date();
            }
            var left = Math.max(40 - (+new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(L.bind(this._performZoom, this), left);
            L.DomEvent.preventDefault(e);
            L.DomEvent.stopPropagation(e);
        },
        _performZoom: function() {
            var map = this._map, delta = this._delta, zoom = map.getZoom();
            delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
            delta = Math.max(Math.min(delta, 4), -4);
            delta = map._limitZoom(zoom + delta) - zoom;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
                return;
            }
            if (map.options.scrollWheelZoom === "center") {
                map.setZoom(zoom + delta);
            } else {
                map.setZoomAround(this._lastMousePos, zoom + delta);
            }
        }
    });
    L.Map.addInitHook("addHandler", "scrollWheelZoom", L.Map.ScrollWheelZoom);
    L.extend(L.DomEvent, {
        _touchstart: L.Browser.msPointer ? "MSPointerDown" : L.Browser.pointer ? "pointerdown" : "touchstart",
        _touchend: L.Browser.msPointer ? "MSPointerUp" : L.Browser.pointer ? "pointerup" : "touchend",
        addDoubleTapListener: function(obj, handler, id) {
            var last, doubleTap = false, delay = 250, touch, pre = "_leaflet_", touchstart = this._touchstart, touchend = this._touchend, trackedTouches = [];
            function onTouchStart(e) {
                var count;
                if (L.Browser.pointer) {
                    trackedTouches.push(e.pointerId);
                    count = trackedTouches.length;
                } else {
                    count = e.touches.length;
                }
                if (count > 1) {
                    return;
                }
                var now = Date.now(), delta = now - (last || now);
                touch = e.touches ? e.touches[0] : e;
                doubleTap = delta > 0 && delta <= delay;
                last = now;
            }
            function onTouchEnd(e) {
                if (L.Browser.pointer) {
                    var idx = trackedTouches.indexOf(e.pointerId);
                    if (idx === -1) {
                        return;
                    }
                    trackedTouches.splice(idx, 1);
                }
                if (doubleTap) {
                    if (L.Browser.pointer) {
                        var newTouch = {}, prop;
                        for (var i in touch) {
                            prop = touch[i];
                            if (typeof prop === "function") {
                                newTouch[i] = prop.bind(touch);
                            } else {
                                newTouch[i] = prop;
                            }
                        }
                        touch = newTouch;
                    }
                    touch.type = "dblclick";
                    handler(touch);
                    last = null;
                }
            }
            obj[pre + touchstart + id] = onTouchStart;
            obj[pre + touchend + id] = onTouchEnd;
            var endElement = L.Browser.pointer ? document.documentElement : obj;
            obj.addEventListener(touchstart, onTouchStart, false);
            endElement.addEventListener(touchend, onTouchEnd, false);
            if (L.Browser.pointer) {
                endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
            }
            return this;
        },
        removeDoubleTapListener: function(obj, id) {
            var pre = "_leaflet_";
            obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
            (L.Browser.pointer ? document.documentElement : obj).removeEventListener(this._touchend, obj[pre + this._touchend + id], false);
            if (L.Browser.pointer) {
                document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id], false);
            }
            return this;
        }
    });
    L.extend(L.DomEvent, {
        POINTER_DOWN: L.Browser.msPointer ? "MSPointerDown" : "pointerdown",
        POINTER_MOVE: L.Browser.msPointer ? "MSPointerMove" : "pointermove",
        POINTER_UP: L.Browser.msPointer ? "MSPointerUp" : "pointerup",
        POINTER_CANCEL: L.Browser.msPointer ? "MSPointerCancel" : "pointercancel",
        _pointers: [],
        _pointerDocumentListener: false,
        addPointerListener: function(obj, type, handler, id) {
            switch (type) {
              case "touchstart":
                return this.addPointerListenerStart(obj, type, handler, id);

              case "touchend":
                return this.addPointerListenerEnd(obj, type, handler, id);

              case "touchmove":
                return this.addPointerListenerMove(obj, type, handler, id);

              default:
                throw "Unknown touch event type";
            }
        },
        addPointerListenerStart: function(obj, type, handler, id) {
            var pre = "_leaflet_", pointers = this._pointers;
            var cb = function(e) {
                L.DomEvent.preventDefault(e);
                var alreadyInArray = false;
                for (var i = 0; i < pointers.length; i++) {
                    if (pointers[i].pointerId === e.pointerId) {
                        alreadyInArray = true;
                        break;
                    }
                }
                if (!alreadyInArray) {
                    pointers.push(e);
                }
                e.touches = pointers.slice();
                e.changedTouches = [ e ];
                handler(e);
            };
            obj[pre + "touchstart" + id] = cb;
            obj.addEventListener(this.POINTER_DOWN, cb, false);
            if (!this._pointerDocumentListener) {
                var internalCb = function(e) {
                    for (var i = 0; i < pointers.length; i++) {
                        if (pointers[i].pointerId === e.pointerId) {
                            pointers.splice(i, 1);
                            break;
                        }
                    }
                };
                document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
                document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);
                this._pointerDocumentListener = true;
            }
            return this;
        },
        addPointerListenerMove: function(obj, type, handler, id) {
            var pre = "_leaflet_", touches = this._pointers;
            function cb(e) {
                if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === "mouse") && e.buttons === 0) {
                    return;
                }
                for (var i = 0; i < touches.length; i++) {
                    if (touches[i].pointerId === e.pointerId) {
                        touches[i] = e;
                        break;
                    }
                }
                e.touches = touches.slice();
                e.changedTouches = [ e ];
                handler(e);
            }
            obj[pre + "touchmove" + id] = cb;
            obj.addEventListener(this.POINTER_MOVE, cb, false);
            return this;
        },
        addPointerListenerEnd: function(obj, type, handler, id) {
            var pre = "_leaflet_", touches = this._pointers;
            var cb = function(e) {
                for (var i = 0; i < touches.length; i++) {
                    if (touches[i].pointerId === e.pointerId) {
                        touches.splice(i, 1);
                        break;
                    }
                }
                e.touches = touches.slice();
                e.changedTouches = [ e ];
                handler(e);
            };
            obj[pre + "touchend" + id] = cb;
            obj.addEventListener(this.POINTER_UP, cb, false);
            obj.addEventListener(this.POINTER_CANCEL, cb, false);
            return this;
        },
        removePointerListener: function(obj, type, id) {
            var pre = "_leaflet_", cb = obj[pre + type + id];
            switch (type) {
              case "touchstart":
                obj.removeEventListener(this.POINTER_DOWN, cb, false);
                break;

              case "touchmove":
                obj.removeEventListener(this.POINTER_MOVE, cb, false);
                break;

              case "touchend":
                obj.removeEventListener(this.POINTER_UP, cb, false);
                obj.removeEventListener(this.POINTER_CANCEL, cb, false);
                break;
            }
            return this;
        }
    });
    L.Map.mergeOptions({
        touchZoom: L.Browser.touch && !L.Browser.android23,
        bounceAtZoomLimits: true
    });
    L.Map.TouchZoom = L.Handler.extend({
        addHooks: function() {
            L.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
            L.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(e) {
            var map = this._map;
            if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
                return;
            }
            var p1 = map.mouseEventToLayerPoint(e.touches[0]), p2 = map.mouseEventToLayerPoint(e.touches[1]), viewCenter = map._getCenterLayerPoint();
            this._startCenter = p1.add(p2)._divideBy(2);
            this._startDist = p1.distanceTo(p2);
            this._moved = false;
            this._zooming = true;
            this._centerOffset = viewCenter.subtract(this._startCenter);
            if (map._panAnim) {
                map._panAnim.stop();
            }
            L.DomEvent.on(document, "touchmove", this._onTouchMove, this).on(document, "touchend", this._onTouchEnd, this);
            L.DomEvent.preventDefault(e);
        },
        _onTouchMove: function(e) {
            var map = this._map;
            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
                return;
            }
            var p1 = map.mouseEventToLayerPoint(e.touches[0]), p2 = map.mouseEventToLayerPoint(e.touches[1]);
            this._scale = p1.distanceTo(p2) / this._startDist;
            this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);
            if (this._scale === 1) {
                return;
            }
            if (!map.options.bounceAtZoomLimits) {
                if (map.getZoom() === map.getMinZoom() && this._scale < 1 || map.getZoom() === map.getMaxZoom() && this._scale > 1) {
                    return;
                }
            }
            if (!this._moved) {
                L.DomUtil.addClass(map._mapPane, "leaflet-touching");
                map.fire("movestart").fire("zoomstart");
                this._moved = true;
            }
            L.Util.cancelAnimFrame(this._animRequest);
            this._animRequest = L.Util.requestAnimFrame(this._updateOnMove, this, true, this._map._container);
            L.DomEvent.preventDefault(e);
        },
        _updateOnMove: function() {
            var map = this._map, origin = this._getScaleOrigin(), center = map.layerPointToLatLng(origin), zoom = map.getScaleZoom(this._scale);
            map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
        },
        _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
                this._zooming = false;
                return;
            }
            var map = this._map;
            this._zooming = false;
            L.DomUtil.removeClass(map._mapPane, "leaflet-touching");
            L.Util.cancelAnimFrame(this._animRequest);
            L.DomEvent.off(document, "touchmove", this._onTouchMove).off(document, "touchend", this._onTouchEnd);
            var origin = this._getScaleOrigin(), center = map.layerPointToLatLng(origin), oldZoom = map.getZoom(), floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom, roundZoomDelta = floatZoomDelta > 0 ? Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta), zoom = map._limitZoom(oldZoom + roundZoomDelta), scale = map.getZoomScale(zoom) / this._scale;
            map._animateZoom(center, zoom, origin, scale);
        },
        _getScaleOrigin: function() {
            var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
            return this._startCenter.add(centerOffset);
        }
    });
    L.Map.addInitHook("addHandler", "touchZoom", L.Map.TouchZoom);
    L.Map.mergeOptions({
        tap: true,
        tapTolerance: 15
    });
    L.Map.Tap = L.Handler.extend({
        addHooks: function() {
            L.DomEvent.on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
            L.DomEvent.off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(e) {
            if (!e.touches) {
                return;
            }
            L.DomEvent.preventDefault(e);
            this._fireClick = true;
            if (e.touches.length > 1) {
                this._fireClick = false;
                clearTimeout(this._holdTimeout);
                return;
            }
            var first = e.touches[0], el = first.target;
            this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);
            if (el.tagName && el.tagName.toLowerCase() === "a") {
                L.DomUtil.addClass(el, "leaflet-active");
            }
            this._holdTimeout = setTimeout(L.bind(function() {
                if (this._isTapValid()) {
                    this._fireClick = false;
                    this._onUp();
                    this._simulateEvent("contextmenu", first);
                }
            }, this), 1e3);
            L.DomEvent.on(document, "touchmove", this._onMove, this).on(document, "touchend", this._onUp, this);
        },
        _onUp: function(e) {
            clearTimeout(this._holdTimeout);
            L.DomEvent.off(document, "touchmove", this._onMove, this).off(document, "touchend", this._onUp, this);
            if (this._fireClick && e && e.changedTouches) {
                var first = e.changedTouches[0], el = first.target;
                if (el && el.tagName && el.tagName.toLowerCase() === "a") {
                    L.DomUtil.removeClass(el, "leaflet-active");
                }
                if (this._isTapValid()) {
                    this._simulateEvent("click", first);
                }
            }
        },
        _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _onMove: function(e) {
            var first = e.touches[0];
            this._newPos = new L.Point(first.clientX, first.clientY);
        },
        _simulateEvent: function(type, e) {
            var simulatedEvent = document.createEvent("MouseEvents");
            simulatedEvent._simulated = true;
            e.target._simulatedClick = true;
            simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
            e.target.dispatchEvent(simulatedEvent);
        }
    });
    if (L.Browser.touch && !L.Browser.pointer) {
        L.Map.addInitHook("addHandler", "tap", L.Map.Tap);
    }
    L.Map.mergeOptions({
        boxZoom: true
    });
    L.Map.BoxZoom = L.Handler.extend({
        initialize: function(map) {
            this._map = map;
            this._container = map._container;
            this._pane = map._panes.overlayPane;
            this._moved = false;
        },
        addHooks: function() {
            L.DomEvent.on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
            L.DomEvent.off(this._container, "mousedown", this._onMouseDown);
            this._moved = false;
        },
        moved: function() {
            return this._moved;
        },
        _onMouseDown: function(e) {
            this._moved = false;
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
                return false;
            }
            L.DomUtil.disableTextSelection();
            L.DomUtil.disableImageDrag();
            this._startLayerPoint = this._map.mouseEventToLayerPoint(e);
            L.DomEvent.on(document, "mousemove", this._onMouseMove, this).on(document, "mouseup", this._onMouseUp, this).on(document, "keydown", this._onKeyDown, this);
        },
        _onMouseMove: function(e) {
            if (!this._moved) {
                this._box = L.DomUtil.create("div", "leaflet-zoom-box", this._pane);
                L.DomUtil.setPosition(this._box, this._startLayerPoint);
                this._container.style.cursor = "crosshair";
                this._map.fire("boxzoomstart");
            }
            var startPoint = this._startLayerPoint, box = this._box, layerPoint = this._map.mouseEventToLayerPoint(e), offset = layerPoint.subtract(startPoint), newPos = new L.Point(Math.min(layerPoint.x, startPoint.x), Math.min(layerPoint.y, startPoint.y));
            L.DomUtil.setPosition(box, newPos);
            this._moved = true;
            box.style.width = Math.max(0, Math.abs(offset.x) - 4) + "px";
            box.style.height = Math.max(0, Math.abs(offset.y) - 4) + "px";
        },
        _finish: function() {
            if (this._moved) {
                this._pane.removeChild(this._box);
                this._container.style.cursor = "";
            }
            L.DomUtil.enableTextSelection();
            L.DomUtil.enableImageDrag();
            L.DomEvent.off(document, "mousemove", this._onMouseMove).off(document, "mouseup", this._onMouseUp).off(document, "keydown", this._onKeyDown);
        },
        _onMouseUp: function(e) {
            this._finish();
            var map = this._map, layerPoint = map.mouseEventToLayerPoint(e);
            if (this._startLayerPoint.equals(layerPoint)) {
                return;
            }
            var bounds = new L.LatLngBounds(map.layerPointToLatLng(this._startLayerPoint), map.layerPointToLatLng(layerPoint));
            map.fitBounds(bounds);
            map.fire("boxzoomend", {
                boxZoomBounds: bounds
            });
        },
        _onKeyDown: function(e) {
            if (e.keyCode === 27) {
                this._finish();
            }
        }
    });
    L.Map.addInitHook("addHandler", "boxZoom", L.Map.BoxZoom);
    L.Map.mergeOptions({
        keyboard: true,
        keyboardPanOffset: 80,
        keyboardZoomOffset: 1
    });
    L.Map.Keyboard = L.Handler.extend({
        keyCodes: {
            left: [ 37 ],
            right: [ 39 ],
            down: [ 40 ],
            up: [ 38 ],
            zoomIn: [ 187, 107, 61, 171 ],
            zoomOut: [ 189, 109, 173 ]
        },
        initialize: function(map) {
            this._map = map;
            this._setPanOffset(map.options.keyboardPanOffset);
            this._setZoomOffset(map.options.keyboardZoomOffset);
        },
        addHooks: function() {
            var container = this._map._container;
            if (container.tabIndex === -1) {
                container.tabIndex = "0";
            }
            L.DomEvent.on(container, "focus", this._onFocus, this).on(container, "blur", this._onBlur, this).on(container, "mousedown", this._onMouseDown, this);
            this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this);
        },
        removeHooks: function() {
            this._removeHooks();
            var container = this._map._container;
            L.DomEvent.off(container, "focus", this._onFocus, this).off(container, "blur", this._onBlur, this).off(container, "mousedown", this._onMouseDown, this);
            this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this);
        },
        _onMouseDown: function() {
            if (this._focused) {
                return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
        },
        _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
        },
        _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
        },
        _setPanOffset: function(pan) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.left.length; i < len; i++) {
                keys[codes.left[i]] = [ -1 * pan, 0 ];
            }
            for (i = 0, len = codes.right.length; i < len; i++) {
                keys[codes.right[i]] = [ pan, 0 ];
            }
            for (i = 0, len = codes.down.length; i < len; i++) {
                keys[codes.down[i]] = [ 0, pan ];
            }
            for (i = 0, len = codes.up.length; i < len; i++) {
                keys[codes.up[i]] = [ 0, -1 * pan ];
            }
        },
        _setZoomOffset: function(zoom) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.zoomIn.length; i < len; i++) {
                keys[codes.zoomIn[i]] = zoom;
            }
            for (i = 0, len = codes.zoomOut.length; i < len; i++) {
                keys[codes.zoomOut[i]] = -zoom;
            }
        },
        _addHooks: function() {
            L.DomEvent.on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
            L.DomEvent.off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(e) {
            var key = e.keyCode, map = this._map;
            if (key in this._panKeys) {
                if (map._panAnim && map._panAnim._inProgress) {
                    return;
                }
                map.panBy(this._panKeys[key]);
                if (map.options.maxBounds) {
                    map.panInsideBounds(map.options.maxBounds);
                }
            } else if (key in this._zoomKeys) {
                map.setZoom(map.getZoom() + this._zoomKeys[key]);
            } else {
                return;
            }
            L.DomEvent.stop(e);
        }
    });
    L.Map.addInitHook("addHandler", "keyboard", L.Map.Keyboard);
    L.Handler.MarkerDrag = L.Handler.extend({
        initialize: function(marker) {
            this._marker = marker;
        },
        addHooks: function() {
            var icon = this._marker._icon;
            if (!this._draggable) {
                this._draggable = new L.Draggable(icon, icon);
            }
            this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this);
            this._draggable.enable();
            L.DomUtil.addClass(this._marker._icon, "leaflet-marker-draggable");
        },
        removeHooks: function() {
            this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this);
            this._draggable.disable();
            L.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable");
        },
        moved: function() {
            return this._draggable && this._draggable._moved;
        },
        _onDragStart: function() {
            this._marker.closePopup().fire("movestart").fire("dragstart");
        },
        _onDrag: function() {
            var marker = this._marker, shadow = marker._shadow, iconPos = L.DomUtil.getPosition(marker._icon), latlng = marker._map.layerPointToLatLng(iconPos);
            if (shadow) {
                L.DomUtil.setPosition(shadow, iconPos);
            }
            marker._latlng = latlng;
            marker.fire("move", {
                latlng: latlng
            }).fire("drag");
        },
        _onDragEnd: function(e) {
            this._marker.fire("moveend").fire("dragend", e);
        }
    });
    L.Control = L.Class.extend({
        options: {
            position: "topright"
        },
        initialize: function(options) {
            L.setOptions(this, options);
        },
        getPosition: function() {
            return this.options.position;
        },
        setPosition: function(position) {
            var map = this._map;
            if (map) {
                map.removeControl(this);
            }
            this.options.position = position;
            if (map) {
                map.addControl(this);
            }
            return this;
        },
        getContainer: function() {
            return this._container;
        },
        addTo: function(map) {
            this._map = map;
            var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
            L.DomUtil.addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }
            return this;
        },
        removeFrom: function(map) {
            var pos = this.getPosition(), corner = map._controlCorners[pos];
            corner.removeChild(this._container);
            this._map = null;
            if (this.onRemove) {
                this.onRemove(map);
            }
            return this;
        },
        _refocusOnMap: function() {
            if (this._map) {
                this._map.getContainer().focus();
            }
        }
    });
    L.control = function(options) {
        return new L.Control(options);
    };
    L.Map.include({
        addControl: function(control) {
            control.addTo(this);
            return this;
        },
        removeControl: function(control) {
            control.removeFrom(this);
            return this;
        },
        _initControlPos: function() {
            var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = L.DomUtil.create("div", l + "control-container", this._container);
            function createCorner(vSide, hSide) {
                var className = l + vSide + " " + l + hSide;
                corners[vSide + hSide] = L.DomUtil.create("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
        },
        _clearControlPos: function() {
            this._container.removeChild(this._controlContainer);
        }
    });
    L.Control.Zoom = L.Control.extend({
        options: {
            position: "topleft",
            zoomInText: "+",
            zoomInTitle: "Zoom in",
            zoomOutText: "-",
            zoomOutTitle: "Zoom out"
        },
        onAdd: function(map) {
            var zoomName = "leaflet-control-zoom", container = L.DomUtil.create("div", zoomName + " leaflet-bar");
            this._map = map;
            this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, zoomName + "-in", container, this._zoomIn, this);
            this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, zoomName + "-out", container, this._zoomOut, this);
            this._updateDisabled();
            map.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
        },
        onRemove: function(map) {
            map.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        _zoomIn: function(e) {
            this._map.zoomIn(e.shiftKey ? 3 : 1);
        },
        _zoomOut: function(e) {
            this._map.zoomOut(e.shiftKey ? 3 : 1);
        },
        _createButton: function(html, title, className, container, fn, context) {
            var link = L.DomUtil.create("a", className, container);
            link.innerHTML = html;
            link.href = "#";
            link.title = title;
            var stop = L.DomEvent.stopPropagation;
            L.DomEvent.on(link, "click", stop).on(link, "mousedown", stop).on(link, "dblclick", stop).on(link, "click", L.DomEvent.preventDefault).on(link, "click", fn, context).on(link, "click", this._refocusOnMap, context);
            return link;
        },
        _updateDisabled: function() {
            var map = this._map, className = "leaflet-disabled";
            L.DomUtil.removeClass(this._zoomInButton, className);
            L.DomUtil.removeClass(this._zoomOutButton, className);
            if (map._zoom === map.getMinZoom()) {
                L.DomUtil.addClass(this._zoomOutButton, className);
            }
            if (map._zoom === map.getMaxZoom()) {
                L.DomUtil.addClass(this._zoomInButton, className);
            }
        }
    });
    L.Map.mergeOptions({
        zoomControl: true
    });
    L.Map.addInitHook(function() {
        if (this.options.zoomControl) {
            this.zoomControl = new L.Control.Zoom();
            this.addControl(this.zoomControl);
        }
    });
    L.control.zoom = function(options) {
        return new L.Control.Zoom(options);
    };
    L.Control.Attribution = L.Control.extend({
        options: {
            position: "bottomright",
            prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
        },
        initialize: function(options) {
            L.setOptions(this, options);
            this._attributions = {};
        },
        onAdd: function(map) {
            this._container = L.DomUtil.create("div", "leaflet-control-attribution");
            L.DomEvent.disableClickPropagation(this._container);
            for (var i in map._layers) {
                if (map._layers[i].getAttribution) {
                    this.addAttribution(map._layers[i].getAttribution());
                }
            }
            map.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this);
            this._update();
            return this._container;
        },
        onRemove: function(map) {
            map.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove);
        },
        setPrefix: function(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
        },
        addAttribution: function(text) {
            if (!text) {
                return;
            }
            if (!this._attributions[text]) {
                this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
        },
        removeAttribution: function(text) {
            if (!text) {
                return;
            }
            if (this._attributions[text]) {
                this._attributions[text]--;
                this._update();
            }
            return this;
        },
        _update: function() {
            if (!this._map) {
                return;
            }
            var attribs = [];
            for (var i in this._attributions) {
                if (this._attributions[i]) {
                    attribs.push(i);
                }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
                prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
                prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(" | ");
        },
        _onLayerAdd: function(e) {
            if (e.layer.getAttribution) {
                this.addAttribution(e.layer.getAttribution());
            }
        },
        _onLayerRemove: function(e) {
            if (e.layer.getAttribution) {
                this.removeAttribution(e.layer.getAttribution());
            }
        }
    });
    L.Map.mergeOptions({
        attributionControl: true
    });
    L.Map.addInitHook(function() {
        if (this.options.attributionControl) {
            this.attributionControl = new L.Control.Attribution().addTo(this);
        }
    });
    L.control.attribution = function(options) {
        return new L.Control.Attribution(options);
    };
    L.Control.Scale = L.Control.extend({
        options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: true,
            imperial: true,
            updateWhenIdle: false
        },
        onAdd: function(map) {
            this._map = map;
            var className = "leaflet-control-scale", container = L.DomUtil.create("div", className), options = this.options;
            this._addScales(options, className, container);
            map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map.whenReady(this._update, this);
            return container;
        },
        onRemove: function(map) {
            map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(options, className, container) {
            if (options.metric) {
                this._mScale = L.DomUtil.create("div", className + "-line", container);
            }
            if (options.imperial) {
                this._iScale = L.DomUtil.create("div", className + "-line", container);
            }
        },
        _update: function() {
            var bounds = this._map.getBounds(), centerLat = bounds.getCenter().lat, halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180), dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180, size = this._map.getSize(), options = this.options, maxMeters = 0;
            if (size.x > 0) {
                maxMeters = dist * (options.maxWidth / size.x);
            }
            this._updateScales(options, maxMeters);
        },
        _updateScales: function(options, maxMeters) {
            if (options.metric && maxMeters) {
                this._updateMetric(maxMeters);
            }
            if (options.imperial && maxMeters) {
                this._updateImperial(maxMeters);
            }
        },
        _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters);
            this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + "px";
            this._mScale.innerHTML = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
        },
        _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, scale = this._iScale, maxMiles, miles, feet;
            if (maxFeet > 5280) {
                maxMiles = maxFeet / 5280;
                miles = this._getRoundNum(maxMiles);
                scale.style.width = this._getScaleWidth(miles / maxMiles) + "px";
                scale.innerHTML = miles + " mi";
            } else {
                feet = this._getRoundNum(maxFeet);
                scale.style.width = this._getScaleWidth(feet / maxFeet) + "px";
                scale.innerHTML = feet + " ft";
            }
        },
        _getScaleWidth: function(ratio) {
            return Math.round(this.options.maxWidth * ratio) - 10;
        },
        _getRoundNum: function(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
            return pow10 * d;
        }
    });
    L.control.scale = function(options) {
        return new L.Control.Scale(options);
    };
    L.Control.Layers = L.Control.extend({
        options: {
            collapsed: true,
            position: "topright",
            autoZIndex: true
        },
        initialize: function(baseLayers, overlays, options) {
            L.setOptions(this, options);
            this._layers = {};
            this._lastZIndex = 0;
            this._handlingClick = false;
            for (var i in baseLayers) {
                this._addLayer(baseLayers[i], i);
            }
            for (i in overlays) {
                this._addLayer(overlays[i], i, true);
            }
        },
        onAdd: function(map) {
            this._initLayout();
            this._update();
            map.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this);
            return this._container;
        },
        onRemove: function(map) {
            map.off("layeradd", this._onLayerChange, this).off("layerremove", this._onLayerChange, this);
        },
        addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            this._update();
            return this;
        },
        addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            this._update();
            return this;
        },
        removeLayer: function(layer) {
            var id = L.stamp(layer);
            delete this._layers[id];
            this._update();
            return this;
        },
        _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = L.DomUtil.create("div", className);
            container.setAttribute("aria-haspopup", true);
            if (!L.Browser.touch) {
                L.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);
            } else {
                L.DomEvent.on(container, "click", L.DomEvent.stopPropagation);
            }
            var form = this._form = L.DomUtil.create("form", className + "-list");
            if (this.options.collapsed) {
                if (!L.Browser.android) {
                    L.DomEvent.on(container, "mouseover", this._expand, this).on(container, "mouseout", this._collapse, this);
                }
                var link = this._layersLink = L.DomUtil.create("a", className + "-toggle", container);
                link.href = "#";
                link.title = "Layers";
                if (L.Browser.touch) {
                    L.DomEvent.on(link, "click", L.DomEvent.stop).on(link, "click", this._expand, this);
                } else {
                    L.DomEvent.on(link, "focus", this._expand, this);
                }
                L.DomEvent.on(form, "click", function() {
                    setTimeout(L.bind(this._onInputClick, this), 0);
                }, this);
                this._map.on("click", this._collapse, this);
            } else {
                this._expand();
            }
            this._baseLayersList = L.DomUtil.create("div", className + "-base", form);
            this._separator = L.DomUtil.create("div", className + "-separator", form);
            this._overlaysList = L.DomUtil.create("div", className + "-overlays", form);
            container.appendChild(form);
        },
        _addLayer: function(layer, name, overlay) {
            var id = L.stamp(layer);
            this._layers[id] = {
                layer: layer,
                name: name,
                overlay: overlay
            };
            if (this.options.autoZIndex && layer.setZIndex) {
                this._lastZIndex++;
                layer.setZIndex(this._lastZIndex);
            }
        },
        _update: function() {
            if (!this._container) {
                return;
            }
            this._baseLayersList.innerHTML = "";
            this._overlaysList.innerHTML = "";
            var baseLayersPresent = false, overlaysPresent = false, i, obj;
            for (i in this._layers) {
                obj = this._layers[i];
                this._addItem(obj);
                overlaysPresent = overlaysPresent || obj.overlay;
                baseLayersPresent = baseLayersPresent || !obj.overlay;
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
        },
        _onLayerChange: function(e) {
            var obj = this._layers[L.stamp(e.layer)];
            if (!obj) {
                return;
            }
            if (!this._handlingClick) {
                this._update();
            }
            var type = obj.overlay ? e.type === "layeradd" ? "overlayadd" : "overlayremove" : e.type === "layeradd" ? "baselayerchange" : null;
            if (type) {
                this._map.fire(type, obj);
            }
        },
        _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
            if (checked) {
                radioHtml += ' checked="checked"';
            }
            radioHtml += "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
        },
        _addItem: function(obj) {
            var label = document.createElement("label"), input, checked = this._map.hasLayer(obj.layer);
            if (obj.overlay) {
                input = document.createElement("input");
                input.type = "checkbox";
                input.className = "leaflet-control-layers-selector";
                input.defaultChecked = checked;
            } else {
                input = this._createRadioElement("leaflet-base-layers", checked);
            }
            input.layerId = L.stamp(obj.layer);
            L.DomEvent.on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            label.appendChild(input);
            label.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            return label;
        },
        _onInputClick: function() {
            var i, input, obj, inputs = this._form.getElementsByTagName("input"), inputsLen = inputs.length;
            this._handlingClick = true;
            for (i = 0; i < inputsLen; i++) {
                input = inputs[i];
                obj = this._layers[input.layerId];
                if (input.checked && !this._map.hasLayer(obj.layer)) {
                    this._map.addLayer(obj.layer);
                } else if (!input.checked && this._map.hasLayer(obj.layer)) {
                    this._map.removeLayer(obj.layer);
                }
            }
            this._handlingClick = false;
            this._refocusOnMap();
        },
        _expand: function() {
            L.DomUtil.addClass(this._container, "leaflet-control-layers-expanded");
        },
        _collapse: function() {
            this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "");
        }
    });
    L.control.layers = function(baseLayers, overlays, options) {
        return new L.Control.Layers(baseLayers, overlays, options);
    };
    L.PosAnimation = L.Class.extend({
        includes: L.Mixin.Events,
        run: function(el, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._newPos = newPos;
            this.fire("start");
            el.style[L.DomUtil.TRANSITION] = "all " + (duration || .25) + "s cubic-bezier(0,0," + (easeLinearity || .5) + ",1)";
            L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            L.DomUtil.setPosition(el, newPos);
            L.Util.falseFn(el.offsetWidth);
            this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
        },
        stop: function() {
            if (!this._inProgress) {
                return;
            }
            L.DomUtil.setPosition(this._el, this._getPos());
            this._onTransitionEnd();
            L.Util.falseFn(this._el.offsetWidth);
        },
        _onStep: function() {
            var stepPos = this._getPos();
            if (!stepPos) {
                this._onTransitionEnd();
                return;
            }
            this._el._leaflet_pos = stepPos;
            this.fire("step");
        },
        _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
        _getPos: function() {
            var left, top, matches, el = this._el, style = window.getComputedStyle(el);
            if (L.Browser.any3d) {
                matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
                if (!matches) {
                    return;
                }
                left = parseFloat(matches[1]);
                top = parseFloat(matches[2]);
            } else {
                left = parseFloat(style.left);
                top = parseFloat(style.top);
            }
            return new L.Point(left, top, true);
        },
        _onTransitionEnd: function() {
            L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            if (!this._inProgress) {
                return;
            }
            this._inProgress = false;
            this._el.style[L.DomUtil.TRANSITION] = "";
            this._el._leaflet_pos = this._newPos;
            clearInterval(this._stepTimer);
            this.fire("step").fire("end");
        }
    });
    L.Map.include({
        setView: function(center, zoom, options) {
            zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
            center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
            options = options || {};
            if (this._panAnim) {
                this._panAnim.stop();
            }
            if (this._loaded && !options.reset && options !== true) {
                if (options.animate !== undefined) {
                    options.zoom = L.extend({
                        animate: options.animate
                    }, options.zoom);
                    options.pan = L.extend({
                        animate: options.animate
                    }, options.pan);
                }
                var animated = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);
                if (animated) {
                    clearTimeout(this._sizeTimer);
                    return this;
                }
            }
            this._resetView(center, zoom);
            return this;
        },
        panBy: function(offset, options) {
            offset = L.point(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) {
                return this;
            }
            if (!this._panAnim) {
                this._panAnim = new L.PosAnimation();
                this._panAnim.on({
                    step: this._onPanTransitionStep,
                    end: this._onPanTransitionEnd
                }, this);
            }
            if (!options.noMoveStart) {
                this.fire("movestart");
            }
            if (options.animate !== false) {
                L.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
                var newPos = this._getMapPanePos().subtract(offset);
                this._panAnim.run(this._mapPane, newPos, options.duration || .25, options.easeLinearity);
            } else {
                this._rawPanBy(offset);
                this.fire("move").fire("moveend");
            }
            return this;
        },
        _onPanTransitionStep: function() {
            this.fire("move");
        },
        _onPanTransitionEnd: function() {
            L.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
        },
        _tryAnimatedPan: function(center, options) {
            var offset = this._getCenterOffset(center)._floor();
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
                return false;
            }
            this.panBy(offset, options);
            return true;
        }
    });
    L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({
        run: function(el, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration || .25;
            this._easeOutPower = 1 / Math.max(easeLinearity || .5, .2);
            this._startPos = L.DomUtil.getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();
            this.fire("start");
            this._animate();
        },
        stop: function() {
            if (!this._inProgress) {
                return;
            }
            this._step();
            this._complete();
        },
        _animate: function() {
            this._animId = L.Util.requestAnimFrame(this._animate, this);
            this._step();
        },
        _step: function() {
            var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
            if (elapsed < duration) {
                this._runFrame(this._easeOut(elapsed / duration));
            } else {
                this._runFrame(1);
                this._complete();
            }
        },
        _runFrame: function(progress) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            L.DomUtil.setPosition(this._el, pos);
            this.fire("step");
        },
        _complete: function() {
            L.Util.cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
        },
        _easeOut: function(t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
        }
    });
    L.Map.mergeOptions({
        zoomAnimation: true,
        zoomAnimationThreshold: 4
    });
    if (L.DomUtil.TRANSITION) {
        L.Map.addInitHook(function() {
            this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;
            if (this._zoomAnimated) {
                L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
            }
        });
    }
    L.Map.include(!L.DomUtil.TRANSITION ? {} : {
        _catchTransitionEnd: function(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
                this._onZoomTransitionEnd();
            }
        },
        _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(center, zoom, options) {
            if (this._animatingZoom) {
                return true;
            }
            options = options || {};
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
                return false;
            }
            var scale = this.getZoomScale(zoom), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale), origin = this._getCenterLayerPoint()._add(offset);
            if (options.animate !== true && !this.getSize().contains(offset)) {
                return false;
            }
            this.fire("movestart").fire("zoomstart");
            this._animateZoom(center, zoom, origin, scale, null, true);
            return true;
        },
        _animateZoom: function(center, zoom, origin, scale, delta, backwards, forTouchZoom) {
            if (!forTouchZoom) {
                this._animatingZoom = true;
            }
            L.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim");
            this._animateToCenter = center;
            this._animateToZoom = zoom;
            if (L.Draggable) {
                L.Draggable._disabled = true;
            }
            L.Util.requestAnimFrame(function() {
                this.fire("zoomanim", {
                    center: center,
                    zoom: zoom,
                    origin: origin,
                    scale: scale,
                    delta: delta,
                    backwards: backwards
                });
            }, this);
        },
        _onZoomTransitionEnd: function() {
            this._animatingZoom = false;
            L.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim");
            this._resetView(this._animateToCenter, this._animateToZoom, true, true);
            if (L.Draggable) {
                L.Draggable._disabled = false;
            }
        }
    });
    L.TileLayer.include({
        _animateZoom: function(e) {
            if (!this._animating) {
                this._animating = true;
                this._prepareBgBuffer();
            }
            var bg = this._bgBuffer, transform = L.DomUtil.TRANSFORM, initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform], scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);
            bg.style[transform] = e.backwards ? scaleStr + " " + initialTransform : initialTransform + " " + scaleStr;
        },
        _endZoomAnim: function() {
            var front = this._tileContainer, bg = this._bgBuffer;
            front.style.visibility = "";
            front.parentNode.appendChild(front);
            L.Util.falseFn(bg.offsetWidth);
            this._animating = false;
        },
        _clearBgBuffer: function() {
            var map = this._map;
            if (map && !map._animatingZoom && !map.touchZoom._zooming) {
                this._bgBuffer.innerHTML = "";
                this._bgBuffer.style[L.DomUtil.TRANSFORM] = "";
            }
        },
        _prepareBgBuffer: function() {
            var front = this._tileContainer, bg = this._bgBuffer;
            var bgLoaded = this._getLoadedTilesPercentage(bg), frontLoaded = this._getLoadedTilesPercentage(front);
            if (bg && bgLoaded > .5 && frontLoaded < .5) {
                front.style.visibility = "hidden";
                this._stopLoadingImages(front);
                return;
            }
            bg.style.visibility = "hidden";
            bg.style[L.DomUtil.TRANSFORM] = "";
            this._tileContainer = bg;
            bg = this._bgBuffer = front;
            this._stopLoadingImages(bg);
            clearTimeout(this._clearBgBufferTimer);
        },
        _getLoadedTilesPercentage: function(container) {
            var tiles = container.getElementsByTagName("img"), i, len, count = 0;
            for (i = 0, len = tiles.length; i < len; i++) {
                if (tiles[i].complete) {
                    count++;
                }
            }
            return count / len;
        },
        _stopLoadingImages: function(container) {
            var tiles = Array.prototype.slice.call(container.getElementsByTagName("img")), i, len, tile;
            for (i = 0, len = tiles.length; i < len; i++) {
                tile = tiles[i];
                if (!tile.complete) {
                    tile.onload = L.Util.falseFn;
                    tile.onerror = L.Util.falseFn;
                    tile.src = L.Util.emptyImageUrl;
                    tile.parentNode.removeChild(tile);
                }
            }
        }
    });
    L.Map.include({
        _defaultLocateOptions: {
            watch: false,
            setView: false,
            maxZoom: Infinity,
            timeout: 1e4,
            maximumAge: 0,
            enableHighAccuracy: false
        },
        locate: function(options) {
            options = this._locateOptions = L.extend(this._defaultLocateOptions, options);
            if (!navigator.geolocation) {
                this._handleGeolocationError({
                    code: 0,
                    message: "Geolocation not supported."
                });
                return this;
            }
            var onResponse = L.bind(this._handleGeolocationResponse, this), onError = L.bind(this._handleGeolocationError, this);
            if (options.watch) {
                this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
                navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
        },
        stopLocate: function() {
            if (navigator.geolocation) {
                navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
                this._locateOptions.setView = false;
            }
            return this;
        },
        _handleGeolocationError: function(error) {
            var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
                this.fitWorld();
            }
            this.fire("locationerror", {
                code: c,
                message: "Geolocation error: " + message + "."
            });
        },
        _handleGeolocationResponse: function(pos) {
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new L.LatLng(lat, lng), latAccuracy = 180 * pos.coords.accuracy / 40075017, lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat), bounds = L.latLngBounds([ lat - latAccuracy, lng - lngAccuracy ], [ lat + latAccuracy, lng + lngAccuracy ]), options = this._locateOptions;
            if (options.setView) {
                var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
                this.setView(latlng, zoom);
            }
            var data = {
                latlng: latlng,
                bounds: bounds,
                timestamp: pos.timestamp
            };
            for (var i in pos.coords) {
                if (typeof pos.coords[i] === "number") {
                    data[i] = pos.coords[i];
                }
            }
            this.fire("locationfound", data);
        }
    });
})(window, document);

(function(a) {
    a.lvector = {
        VERSION: "1.5.1",
        noConflict: function() {
            a.lvector = this._originallvector;
            return this;
        },
        _originallvector: a.lvector
    };
})(this);

lvector.Layer = L.Class.extend({
    options: {
        fields: "",
        scaleRange: null,
        map: null,
        uniqueField: null,
        visibleAtScale: true,
        dynamic: false,
        autoUpdate: false,
        autoUpdateInterval: null,
        popupTemplate: null,
        popupOptions: {},
        singlePopup: false,
        symbology: null,
        showAll: false
    },
    initialize: function(options) {
        L.Util.setOptions(this, options);
    },
    setMap: function(map) {
        if (map && this.options.map) {
            return;
        }
        if (map) {
            this.options.map = map;
            if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
                var z = this.options.map.getZoom();
                var sr = this.options.scaleRange;
                this.options.visibleAtScale = z >= sr[0] && z <= sr[1];
            }
            this._show();
        } else if (this.options.map) {
            this._hide();
            this.options.map = map;
        }
    },
    getMap: function() {
        return this.options.map;
    },
    setOptions: function(o) {},
    _show: function() {
        this._addIdleListener();
        if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
            this._addZoomChangeListener();
        }
        if (this.options.visibleAtScale) {
            if (this.options.autoUpdate && this.options.autoUpdateInterval) {
                var me = this;
                this._autoUpdateInterval = setInterval(function() {
                    me._getFeatures();
                }, this.options.autoUpdateInterval);
            }
            this.options.map.fire("moveend").fire("zoomend");
        }
    },
    _hide: function() {
        if (this._idleListener) {
            this.options.map.off("moveend", this._idleListener);
        }
        if (this._zoomChangeListener) {
            this.options.map.off("zoomend", this._zoomChangeListener);
        }
        if (this._autoUpdateInterval) {
            clearInterval(this._autoUpdateInterval);
        }
        this._clearFeatures();
        this._lastQueriedBounds = null;
        if (this._gotAll) {
            this._gotAll = false;
        }
    },
    _hideVectors: function() {
        for (var i = 0; i < this._vectors.length; i++) {
            if (this._vectors[i].vector) {
                this.options.map.removeLayer(this._vectors[i].vector);
                if (this._vectors[i].popup) {
                    this.options.map.removeLayer(this._vectors[i].popup);
                } else if (this.popup && this.popup.associatedFeature && this.popup.associatedFeature == this._vectors[i]) {
                    this.options.map.removeLayer(this.popup);
                    this.popup = null;
                }
            }
            if (this._vectors[i].vectors && this._vectors[i].vectors.length) {
                for (var i2 = 0; i2 < this._vectors[i].vectors.length; i2++) {
                    this.options.map.removeLayer(this._vectors[i].vectors[i2]);
                    if (this._vectors[i].vectors[i2].popup) {
                        this.options.map.removeLayer(this._vectors[i].vectors[i2].popup);
                    } else if (this.popup && this.popup.associatedFeature && this.popup.associatedFeature == this._vectors[i]) {
                        this.options.map.removeLayer(this.popup);
                        this.popup = null;
                    }
                }
            }
        }
    },
    _showVectors: function() {
        for (var i = 0; i < this._vectors.length; i++) {
            if (this._vectors[i].vector) {
                this.options.map.addLayer(this._vectors[i].vector);
            }
            if (this._vectors[i].vectors && this._vectors[i].vectors.length) {
                for (var i2 = 0; i2 < this._vectors[i].vectors.length; i2++) {
                    this.options.map.addLayer(this._vectors[i].vectors[i2]);
                }
            }
        }
    },
    _clearFeatures: function() {
        this._hideVectors();
        this._vectors = [];
    },
    _addZoomChangeListener: function() {
        var me = this;
        me._zoomChangeListener = me._zoomChangeListenerTemplate();
        this.options.map.on("zoomend", me._zoomChangeListener, me);
    },
    _zoomChangeListenerTemplate: function() {
        var me = this;
        return function() {
            me._checkLayerVisibility();
        };
    },
    _idleListenerTemplate: function() {
        var me = this;
        return function() {
            if (me.options.visibleAtScale) {
                if (me.options.showAll) {
                    if (!me._gotAll) {
                        me._getFeatures();
                        me._gotAll = true;
                    }
                } else {
                    me._getFeatures();
                }
            }
        };
    },
    _addIdleListener: function() {
        var me = this;
        me._idleListener = me._idleListenerTemplate();
        this.options.map.on("moveend", me._idleListener, me);
    },
    _checkLayerVisibility: function() {
        var visibilityBefore = this.options.visibleAtScale;
        var z = this.options.map.getZoom();
        var sr = this.options.scaleRange;
        this.options.visibleAtScale = z >= sr[0] && z <= sr[1];
        if (visibilityBefore !== this.options.visibleAtScale) {
            this[this.options.visibleAtScale ? "_showVectors" : "_hideVectors"]();
        }
        if (visibilityBefore && !this.options.visibleAtScale && this._autoUpdateInterval) {
            clearInterval(this._autoUpdateInterval);
        } else if (!visibilityBefore && this.options.autoUpdate && this.options.autoUpdateInterval) {
            var me = this;
            this._autoUpdateInterval = setInterval(function() {
                me._getFeatures();
            }, this.options.autoUpdateInterval);
        }
    },
    _setPopupContent: function(feature) {
        var previousContent = feature.popupContent;
        var atts = feature.attributes || feature.properties;
        var popupContent;
        if (typeof this.options.popupTemplate == "string") {
            popupContent = this.options.popupTemplate;
            for (var prop in atts) {
                var re = new RegExp("{" + prop + "}", "g");
                popupContent = popupContent.replace(re, atts[prop]);
            }
        } else if (typeof this.options.popupTemplate == "function") {
            popupContent = this.options.popupTemplate(atts);
        } else {
            return;
        }
        feature.popupContent = popupContent;
        if (feature.popup) {
            if (feature.popupContent !== previousContent) {
                feature.popup.setContent(feature.popupContent);
            }
        } else if (this.popup && this.popup.associatedFeature == feature) {
            if (feature.popupContent !== previousContent) {
                this.popup.setContent(feature.popupContent);
            }
        }
    },
    _showPopup: function(feature, event) {
        var isLineOrPolygon = event.latlng;
        if (!isLineOrPolygon) {
            L.Util.extend(this.options.popupOptions, {
                offset: event.target.options.icon.options.popupAnchor
            });
        }
        var ownsPopup;
        if (!this.options.singlePopup) {
            feature.popup = new L.Popup(this.options.popupOptions, feature.vector);
            ownsPopup = feature;
        } else {
            if (this.popup) {
                this.options.map.removeLayer(this.popup);
                this.popup = null;
            }
            this.popup = new L.Popup(this.options.popupOptions, feature.vector);
            this.popup.associatedFeature = feature;
            ownsPopup = this;
        }
        ownsPopup.popup.setLatLng(isLineOrPolygon ? event.latlng : event.target.getLatLng());
        ownsPopup.popup.setContent(feature.popupContent);
        this.options.map.addLayer(ownsPopup.popup);
    },
    _fireClickEvent: function(feature, event) {
        this.options.clickEvent(feature, event);
    },
    _fireMouseoverEvent: function(feature, event) {
        this.options.mouseoverEvent(feature, event);
    },
    _fireMouseoutEvent: function(feature, event) {
        this.options.mouseoutEvent(feature, event);
    },
    _getFeatureVectorOptions: function(feature) {
        var vectorOptions = {};
        var atts = feature.attributes || feature.properties;
        if (this.options.symbology) {
            switch (this.options.symbology.type) {
              case "single":
                for (var key in this.options.symbology.vectorOptions) {
                    vectorOptions[key] = this.options.symbology.vectorOptions[key];
                    if (vectorOptions.title) {
                        for (var prop in atts) {
                            var re = new RegExp("{" + prop + "}", "g");
                            vectorOptions.title = vectorOptions.title.replace(re, atts[prop]);
                        }
                    }
                }
                break;

              case "unique":
                var att = this.options.symbology.property;
                for (var i = 0, len = this.options.symbology.values.length; i < len; i++) {
                    if (atts[att] == this.options.symbology.values[i].value) {
                        for (var key in this.options.symbology.values[i].vectorOptions) {
                            vectorOptions[key] = this.options.symbology.values[i].vectorOptions[key];
                            if (vectorOptions.title) {
                                for (var prop in atts) {
                                    var re = new RegExp("{" + prop + "}", "g");
                                    vectorOptions.title = vectorOptions.title.replace(re, atts[prop]);
                                }
                            }
                        }
                    }
                }
                break;

              case "range":
                var att = this.options.symbology.property;
                for (var i = 0, len = this.options.symbology.ranges.length; i < len; i++) {
                    if (atts[att] >= this.options.symbology.ranges[i].range[0] && atts[att] <= this.options.symbology.ranges[i].range[1]) {
                        for (var key in this.options.symbology.ranges[i].vectorOptions) {
                            vectorOptions[key] = this.options.symbology.ranges[i].vectorOptions[key];
                            if (vectorOptions.title) {
                                for (var prop in atts) {
                                    var re = new RegExp("{" + prop + "}", "g");
                                    vectorOptions.title = vectorOptions.title.replace(re, atts[prop]);
                                }
                            }
                        }
                    }
                }
                break;
            }
        }
        return vectorOptions;
    },
    _getPropertiesChanged: function(oldAtts, newAtts) {
        var changed = false;
        for (var key in oldAtts) {
            if (oldAtts[key] != newAtts[key]) {
                changed = true;
            }
        }
        return changed;
    },
    _getPropertyChanged: function(oldAtts, newAtts, property) {
        return !(oldAtts[property] == newAtts[property]);
    },
    _getGeometryChanged: function(oldGeom, newGeom) {
        var changed = false;
        if (oldGeom.coordinates && oldGeom.coordinates instanceof Array) {
            if (!(oldGeom.coordinates[0] == newGeom.coordinates[0] && oldGeom.coordinates[1] == newGeom.coordinates[1])) {
                changed = true;
            }
        } else {
            if (!(oldGeom.x == newGeom.x && oldGeom.y == newGeom.y)) {
                changed = true;
            }
        }
        return changed;
    },
    _makeJsonpRequest: function(url) {
        var head = document.getElementsByTagName("head")[0];
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        head.appendChild(script);
    },
    _processFeatures: function(data) {
        if (!this.options.map) {
            return;
        }
        var bounds = this.options.map.getBounds();
        if (this._lastQueriedBounds && this._lastQueriedBounds.equals(bounds) && !this.options.autoUpdate) {
            return;
        }
        this._lastQueriedBounds = bounds;
        if (this instanceof lvector.PRWSF) {
            data.features = data.rows;
            delete data.rows;
            for (var i = 0, len = data.features.length; i < len; i++) {
                data.features[i].type = "Feature";
                data.features[i].properties = {};
                for (var prop in data.features[i].row) {
                    if (prop == "geojson") {
                        data.features[i].geometry = data.features[i].row.geojson;
                    } else {
                        data.features[i].properties[prop] = data.features[i].row[prop];
                    }
                }
                delete data.features[i].row;
            }
        }
        if (this instanceof lvector.GISCloud) {
            data.features = data.data;
            delete data.data;
            for (var i = 0, len = data.features.length; i < len; i++) {
                data.features[i].type = "Feature";
                data.features[i].properties = data.features[i].data;
                data.features[i].properties.id = data.features[i].__id;
                delete data.features[i].data;
                data.features[i].geometry = data.features[i].__geometry;
                delete data.features[i].__geometry;
            }
        }
        if (data && data.features && data.features.length) {
            for (var i = 0; i < data.features.length; i++) {
                if (this instanceof lvector.EsriJSONLayer) {
                    data.features[i].properties = data.features[i].attributes;
                    delete data.features[i].attributes;
                }
                var onMap = false;
                if (this.options.uniqueField) {
                    for (var i2 = 0; i2 < this._vectors.length; i2++) {
                        if (data.features[i].properties[this.options.uniqueField] == this._vectors[i2].properties[this.options.uniqueField]) {
                            onMap = true;
                            if (this.options.dynamic) {
                                if (this._getGeometryChanged(this._vectors[i2].geometry, data.features[i].geometry)) {
                                    if (!isNaN(data.features[i].geometry.coordinates[0]) && !isNaN(data.features[i].geometry.coordinates[1])) {
                                        this._vectors[i2].geometry = data.features[i].geometry;
                                        this._vectors[i2].vector.setLatLng(new L.LatLng(this._vectors[i2].geometry.coordinates[1], this._vectors[i2].geometry.coordinates[0]));
                                    }
                                }
                                var propertiesChanged = this._getPropertiesChanged(this._vectors[i2].properties, data.features[i].properties);
                                if (propertiesChanged) {
                                    var symbologyPropertyChanged = this._getPropertyChanged(this._vectors[i2].properties, data.features[i].properties, this.options.symbology.property);
                                    this._vectors[i2].properties = data.features[i].properties;
                                    if (this.options.popupTemplate) {
                                        this._setPopupContent(this._vectors[i2]);
                                    }
                                    if (this.options.symbology && this.options.symbology.type != "single" && symbologyPropertyChanged) {
                                        if (this._vectors[i2].vectors) {
                                            for (var i3 = 0, len3 = this._vectors[i2].vectors.length; i3 < len3; i3++) {
                                                if (this._vectors[i2].vectors[i3].setStyle) {
                                                    this._vectors[i2].vectors[i3].setStyle(this._getFeatureVectorOptions(this._vectors[i2]));
                                                } else if (this._vectors[i2].vectors[i3].setIcon) {
                                                    this._vectors[i2].vectors[i3].setIcon(this._getFeatureVectorOptions(this._vectors[i2]).icon);
                                                }
                                            }
                                        } else if (this._vectors[i2].vector) {
                                            if (this._vectors[i2].vector.setStyle) {
                                                this._vectors[i2].vector.setStyle(this._getFeatureVectorOptions(this._vectors[i2]));
                                            } else if (this._vectors[i2].vector.setIcon) {
                                                this._vectors[i2].vector.setIcon(this._getFeatureVectorOptions(this._vectors[i2]).icon);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (!onMap || !this.options.uniqueField) {
                    if (this instanceof lvector.GeoJSONLayer) {
                        var vector_or_vectors = this._geoJsonGeometryToLeaflet(data.features[i].geometry, this._getFeatureVectorOptions(data.features[i]));
                        data.features[i][vector_or_vectors instanceof Array ? "vectors" : "vector"] = vector_or_vectors;
                    } else if (this instanceof lvector.EsriJSONLayer) {
                        var vector_or_vectors = this._esriJsonGeometryToLeaflet(data.features[i].geometry, this._getFeatureVectorOptions(data.features[i]));
                        data.features[i][vector_or_vectors instanceof Array ? "vectors" : "vector"] = vector_or_vectors;
                    }
                    if (data.features[i].vector) {
                        this.options.map.addLayer(data.features[i].vector);
                    } else if (data.features[i].vectors && data.features[i].vectors.length) {
                        for (var i3 = 0; i3 < data.features[i].vectors.length; i3++) {
                            this.options.map.addLayer(data.features[i].vectors[i3]);
                        }
                    }
                    this._vectors.push(data.features[i]);
                    if (this.options.popupTemplate) {
                        var me = this;
                        var feature = data.features[i];
                        this._setPopupContent(feature);
                        (function(feature) {
                            if (feature.vector) {
                                feature.vector.on("click", function(event) {
                                    me._showPopup(feature, event);
                                });
                            } else if (feature.vectors) {
                                for (var i3 = 0, len = feature.vectors.length; i3 < len; i3++) {
                                    feature.vectors[i3].on("click", function(event) {
                                        me._showPopup(feature, event);
                                    });
                                }
                            }
                        })(feature);
                    }
                    if (this.options.clickEvent) {
                        var me = this;
                        var feature = data.features[i];
                        (function(feature) {
                            if (feature.vector) {
                                feature.vector.on("click", function(event) {
                                    me._fireClickEvent(feature, event);
                                });
                            } else if (feature.vectors) {
                                for (var i3 = 0, len = feature.vectors.length; i3 < len; i3++) {
                                    feature.vectors[i3].on("click", function(event) {
                                        me._fireClickEvent(feature, event);
                                    });
                                }
                            }
                        })(feature);
                    }
                    if (this.options.mouseoverEvent) {
                        var me = this;
                        var feature = data.features[i];
                        (function(feature) {
                            if (feature.vector) {
                                feature.vector.on("mouseover", function(event) {
                                    me._fireMouseoverEvent(feature, event);
                                });
                            } else if (feature.vectors) {
                                for (var i3 = 0, len = feature.vectors.length; i3 < len; i3++) {
                                    feature.vectors[i3].on("mouseover", function(event) {
                                        me._fireMouseoverEvent(feature, event);
                                    });
                                }
                            }
                        })(feature);
                    }
                    if (this.options.mouseoutEvent) {
                        var me = this;
                        var feature = data.features[i];
                        (function(feature) {
                            if (feature.vector) {
                                feature.vector.on("mouseout", function(event) {
                                    me._fireMouseoutEvent(feature, event);
                                });
                            } else if (feature.vectors) {
                                for (var i3 = 0, len = feature.vectors.length; i3 < len; i3++) {
                                    feature.vectors[i3].on("mouseout", function(event) {
                                        me._fireMouseoutEvent(feature, event);
                                    });
                                }
                            }
                        })(feature);
                    }
                }
            }
        }
    }
});

lvector.LayerOUT = L.Class.extend({
    options: {
        fields: "",
        scaleRange: null,
        map: null,
        uniqueField: null,
        visibleAtScale: !0,
        dynamic: !1,
        autoUpdate: !1,
        autoUpdateInterval: null,
        popupTemplate: null,
        popupOptions: {},
        singlePopup: !1,
        symbology: null,
        showAll: !1
    },
    initialize: function(a) {
        L.Util.setOptions(this, a);
    },
    setMap: function(a) {
        if (!a || !this.options.map) if (a) {
            this.options.map = a;
            if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
                var a = this.options.map.getZoom(), b = this.options.scaleRange;
                this.options.visibleAtScale = a >= b[0] && a <= b[1];
            }
            this._show();
        } else if (this.options.map) this._hide(), this.options.map = a;
    },
    getMap: function() {
        return this.options.map;
    },
    setOptions: function() {},
    _show: function() {
        this._addIdleListener();
        this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2 && this._addZoomChangeListener();
        if (this.options.visibleAtScale) {
            if (this.options.autoUpdate && this.options.autoUpdateInterval) {
                var a = this;
                this._autoUpdateInterval = setInterval(function() {
                    a._getFeatures();
                }, this.options.autoUpdateInterval);
            }
            this.options.map.fire("moveend").fire("zoomend");
        }
    },
    _hide: function() {
        this._idleListener && this.options.map.off("moveend", this._idleListener);
        this._zoomChangeListener && this.options.map.off("zoomend", this._zoomChangeListener);
        this._autoUpdateInterval && clearInterval(this._autoUpdateInterval);
        this._clearFeatures();
        this._lastQueriedBounds = null;
        if (this._gotAll) this._gotAll = !1;
    },
    _hideVectors: function() {
        for (var a = 0; a < this._vectors.length; a++) {
            if (this._vectors[a].vector) if (this.options.map.removeLayer(this._vectors[a].vector), 
            this._vectors[a].popup) this.options.map.removeLayer(this._vectors[a].popup); else if (this.popup && this.popup.associatedFeature && this.popup.associatedFeature == this._vectors[a]) this.options.map.removeLayer(this.popup), 
            this.popup = null;
            if (this._vectors[a].vectors && this._vectors[a].vectors.length) for (var b = 0; b < this._vectors[a].vectors.length; b++) if (this.options.map.removeLayer(this._vectors[a].vectors[b]), 
            this._vectors[a].vectors[b].popup) this.options.map.removeLayer(this._vectors[a].vectors[b].popup); else if (this.popup && this.popup.associatedFeature && this.popup.associatedFeature == this._vectors[a]) this.options.map.removeLayer(this.popup), 
            this.popup = null;
        }
    },
    _showVectors: function() {
        for (var a = 0; a < this._vectors.length; a++) if (this._vectors[a].vector && this.options.map.addLayer(this._vectors[a].vector), 
        this._vectors[a].vectors && this._vectors[a].vectors.length) for (var b = 0; b < this._vectors[a].vectors.length; b++) this.options.map.addLayer(this._vectors[a].vectors[b]);
    },
    _clearFeatures: function() {
        this._hideVectors();
        this._vectors = [];
    },
    _addZoomChangeListener: function() {
        this._zoomChangeListener = this._zoomChangeListenerTemplate();
        this.options.map.on("zoomend", this._zoomChangeListener, this);
    },
    _zoomChangeListenerTemplate: function() {
        var a = this;
        return function() {
            a._checkLayerVisibility();
        };
    },
    _idleListenerTemplate: function() {
        var a = this;
        return function() {
            if (a.options.visibleAtScale) if (a.options.showAll) {
                if (!a._gotAll) a._getFeatures(), a._gotAll = !0;
            } else a._getFeatures();
        };
    },
    _addIdleListener: function() {
        this._idleListener = this._idleListenerTemplate();
        this.options.map.on("moveend", this._idleListener, this);
    },
    _checkLayerVisibility: function() {
        var a = this.options.visibleAtScale, b = this.options.map.getZoom(), d = this.options.scaleRange;
        this.options.visibleAtScale = b >= d[0] && b <= d[1];
        if (a !== this.options.visibleAtScale) this[this.options.visibleAtScale ? "_showVectors" : "_hideVectors"]();
        if (a && !this.options.visibleAtScale && this._autoUpdateInterval) clearInterval(this._autoUpdateInterval); else if (!a && this.options.autoUpdate && this.options.autoUpdateInterval) {
            var e = this;
            this._autoUpdateInterval = setInterval(function() {
                e._getFeatures();
            }, this.options.autoUpdateInterval);
        }
    },
    _setPopupContent: function(a) {
        var b = a.popupContent, d = a.attributes || a.properties, e;
        if (typeof this.options.popupTemplate == "string") {
            e = this.options.popupTemplate;
            for (var c in d) e = e.replace(RegExp("{" + c + "}", "g"), d[c]);
        } else if (typeof this.options.popupTemplate == "function") e = this.options.popupTemplate(d); else return;
        a.popupContent = e;
        a.popup ? a.popupContent !== b && a.popup.setContent(a.popupContent) : this.popup && this.popup.associatedFeature == a && a.popupContent !== b && this.popup.setContent(a.popupContent);
    },
    _showPopup: function(a, b) {
        var d = b.latlng;
        d || L.Util.extend(this.options.popupOptions, {
            offset: b.target.options.icon.options.popupAnchor
        });
        var e;
        if (this.options.singlePopup) {
            if (this.popup) this.options.map.removeLayer(this.popup), this.popup = null;
            this.popup = new L.Popup(this.options.popupOptions, a.vector);
            this.popup.associatedFeature = a;
            e = this;
        } else a.popup = new L.Popup(this.options.popupOptions, a.vector), e = a;
        e.popup.setLatLng(d ? b.latlng : b.target.getLatLng());
        e.popup.setContent(a.popupContent);
        this.options.map.addLayer(e.popup);
    },
    _fireClickEvent: function(a, b) {
        this.options.clickEvent(a, b);
    },
    _getFeatureVectorOptions: function(a) {
        var b = {}, a = a.attributes || a.properties;
        if (this.options.symbology) switch (this.options.symbology.type) {
          case "single":
            for (var d in this.options.symbology.vectorOptions) if (b[d] = this.options.symbology.vectorOptions[d], 
            b.title) for (var e in a) {
                var c = RegExp("{" + e + "}", "g");
                b.title = b.title.replace(c, a[e]);
            }
            break;

          case "unique":
            for (var f = this.options.symbology.property, g = 0, h = this.options.symbology.values.length; g < h; g++) if (a[f] == this.options.symbology.values[g].value) for (d in this.options.symbology.values[g].vectorOptions) if (b[d] = this.options.symbology.values[g].vectorOptions[d], 
            b.title) for (e in a) c = RegExp("{" + e + "}", "g"), b.title = b.title.replace(c, a[e]);
            break;

          case "range":
            f = this.options.symbology.property;
            g = 0;
            for (h = this.options.symbology.ranges.length; g < h; g++) if (a[f] >= this.options.symbology.ranges[g].range[0] && a[f] <= this.options.symbology.ranges[g].range[1]) for (d in this.options.symbology.ranges[g].vectorOptions) if (b[d] = this.options.symbology.ranges[g].vectorOptions[d], 
            b.title) for (e in a) c = RegExp("{" + e + "}", "g"), b.title = b.title.replace(c, a[e]);
        }
        return b;
    },
    _getPropertiesChanged: function(a, b) {
        var d = !1, e;
        for (e in a) a[e] != b[e] && (d = !0);
        return d;
    },
    _getPropertyChanged: function(a, b, d) {
        return a[d] != b[d];
    },
    _getGeometryChanged: function(a, b) {
        var d = !1;
        a.coordinates && a.coordinates instanceof Array ? a.coordinates[0] == b.coordinates[0] && a.coordinates[1] == b.coordinates[1] || (d = !0) : a.x == b.x && a.y == b.y || (d = !0);
        return d;
    },
    _makeJsonpRequest: function(a) {
        var b = document.getElementsByTagName("head")[0], d = document.createElement("script");
        d.type = "text/javascript";
        d.src = a;
        b.appendChild(d);
    },
    _processFeatures: function(a) {
        if (this.options.map) {
            var b = this.options.map.getBounds();
            if (!this._lastQueriedBounds || !this._lastQueriedBounds.equals(b) || this.options.autoUpdate) {
                this._lastQueriedBounds = b;
                featuresHaveIds = a.features && a.features.length && a.features[0].id ? !0 : !1;
                !this.options.uniqueField && !featuresHaveIds && this._clearFeatures();
                if (this instanceof lvector.PRWSF) {
                    a.features = a.rows;
                    delete a.rows;
                    for (var b = 0, d = a.features.length; b < d; b++) {
                        a.features[b].type = "Feature";
                        a.features[b].properties = {};
                        for (var e in a.features[b].row) e == "geojson" ? a.features[b].geometry = a.features[b].row.geojson : a.features[b].properties[e] = a.features[b].row[e];
                        delete a.features[b].row;
                    }
                }
                if (this instanceof lvector.GISCloud) {
                    a.features = a.data;
                    delete a.data;
                    b = 0;
                    for (d = a.features.length; b < d; b++) a.features[b].type = "Feature", a.features[b].properties = a.features[b].data, 
                    a.features[b].properties.id = a.features[b].__id, delete a.features[b].data, a.features[b].geometry = a.features[b].__geometry, 
                    delete a.features[b].__geometry;
                }
                if (a && a.features && a.features.length) for (b = 0; b < a.features.length; b++) {
                    if (this instanceof lvector.EsriJSONLayer) a.features[b].properties = a.features[b].attributes, 
                    delete a.features[b].attributes;
                    e = !1;
                    d = a.features[b].id ? !0 : !1;
                    if (this.options.uniqueField || d) for (var c = 0; c < this._vectors.length; c++) {
                        var f = this._vectors[c].id ? !0 : !1;
                        if (d && f && a.features[b].id == this._vectors[c].id || this.options.uniqueField && a.features[b].properties[this.options.uniqueField] == this._vectors[c].properties[this.options.uniqueField]) if (e = !0, 
                        this.options.dynamic) {
                            if (this._getGeometryChanged(this._vectors[c].geometry, a.features[b].geometry) && !isNaN(a.features[b].geometry.coordinates[0]) && !isNaN(a.features[b].geometry.coordinates[1])) this._vectors[c].geometry = a.features[b].geometry, 
                            this._vectors[c].vector.setLatLng(new L.LatLng(this._vectors[c].geometry.coordinates[1], this._vectors[c].geometry.coordinates[0]));
                            if (this._getPropertiesChanged(this._vectors[c].properties, a.features[b].properties) && (f = this._getPropertyChanged(this._vectors[c].properties, a.features[b].properties, this.options.symbology.property), 
                            this._vectors[c].properties = a.features[b].properties, this.options.popupTemplate && this._setPopupContent(this._vectors[c]), 
                            this.options.symbology && this.options.symbology.type != "single" && f)) if (this._vectors[c].vectors) for (var f = 0, g = this._vectors[c].vectors.length; f < g; f++) this._vectors[c].vectors[f].setStyle ? this._vectors[c].vectors[f].setStyle(this._getFeatureVectorOptions(this._vectors[c])) : this._vectors[c].vectors[f].setIcon && this._vectors[c].vectors[f].setIcon(this._getFeatureVectorOptions(this._vectors[c]).icon); else this._vectors[c].vector && (this._vectors[c].vector.setStyle ? this._vectors[c].vector.setStyle(this._getFeatureVectorOptions(this._vectors[c])) : this._vectors[c].vector.setIcon && this._vectors[c].vector.setIcon(this._getFeatureVectorOptions(this._vectors[c]).icon));
                        }
                    }
                    if (!e) {
                        this instanceof lvector.GeoJSONLayer ? (e = this._geoJsonGeometryToLeaflet(a.features[b].geometry, this._getFeatureVectorOptions(a.features[b])), 
                        a.features[b][e instanceof Array ? "vectors" : "vector"] = e) : this instanceof lvector.EsriJSONLayer && (e = this._esriJsonGeometryToLeaflet(a.features[b].geometry, this._getFeatureVectorOptions(a.features[b])), 
                        a.features[b][e instanceof Array ? "vectors" : "vector"] = e);
                        if (a.features[b].vector) this.options.map.addLayer(a.features[b].vector); else if (a.features[b].vectors && a.features[b].vectors.length) for (f = 0; f < a.features[b].vectors.length; f++) this.options.map.addLayer(a.features[b].vectors[f]);
                        this._vectors.push(a.features[b]);
                        if (this.options.popupTemplate) {
                            var h = this;
                            e = a.features[b];
                            this._setPopupContent(e);
                            (function(a) {
                                if (a.vector) a.vector.on("click", function(b) {
                                    console.log(h);
                                    h._showPopup(a, b);
                                }); else if (a.vectors) for (var b = 0, c = a.vectors.length; b < c; b++) a.vectors[b].on("click", function(b) {
                                    h._showPopup(a, b);
                                });
                            })(e);
                        }
                        this.options.clickEvent && (h = this, e = a.features[b], function(a) {
                            if (a.vector) a.vector.on("click", function(b) {
                                h._fireClickEvent(a, b);
                            }); else if (a.vectors) for (var b = 0, c = a.vectors.length; b < c; b++) a.vectors[b].on("click", function(b) {
                                h._fireClickEvent(a, b);
                            });
                        }(e));
                    }
                }
            }
        }
    }
});

lvector.GeoJSONLayer = lvector.Layer.extend({
    _geoJsonGeometryToLeaflet: function(a, b) {
        var d, e;
        switch (a.type) {
          case "Point":
            d = b.circleMarker ? new L.CircleMarker(new L.LatLng(a.coordinates[1], a.coordinates[0]), b) : new L.Marker(new L.LatLng(a.coordinates[1], a.coordinates[0]), b);
            break;

          case "MultiPoint":
            e = [];
            for (var c = 0, f = a.coordinates.length; c < f; c++) e.push(new L.Marker(new L.LatLng(a.coordinates[c][1], a.coordinates[c][0]), b));
            break;

          case "LineString":
            for (var g = [], c = 0, f = a.coordinates.length; c < f; c++) g.push(new L.LatLng(a.coordinates[c][1], a.coordinates[c][0]));
            d = new L.Polyline(g, b);
            break;

          case "MultiLineString":
            e = [];
            c = 0;
            for (f = a.coordinates.length; c < f; c++) {
                for (var g = [], h = 0, j = a.coordinates[c].length; h < j; h++) g.push(new L.LatLng(a.coordinates[c][h][1], a.coordinates[c][h][0]));
                e.push(new L.Polyline(g, b));
            }
            break;

          case "Polygon":
            for (var i = [], c = 0, f = a.coordinates.length; c < f; c++) {
                g = [];
                h = 0;
                for (j = a.coordinates[c].length; h < j; h++) g.push(new L.LatLng(a.coordinates[c][h][1], a.coordinates[c][h][0]));
                i.push(g);
            }
            d = new L.Polygon(i, b);
            break;

          case "MultiPolygon":
            e = [];
            c = 0;
            for (f = a.coordinates.length; c < f; c++) {
                i = [];
                h = 0;
                for (j = a.coordinates[c].length; h < j; h++) {
                    for (var g = [], k = 0, l = a.coordinates[c][h].length; k < l; k++) g.push(new L.LatLng(a.coordinates[c][h][k][1], a.coordinates[c][h][k][0]));
                    i.push(g);
                }
                e.push(new L.Polygon(i, b));
            }
            break;

          case "GeometryCollection":
            e = [];
            c = 0;
            for (f = a.geometries.length; c < f; c++) e.push(this._geoJsonGeometryToLeaflet(a.geometries[c], b));
        }
        return d || e;
    }
});

lvector.EsriJSONLayer = lvector.Layer.extend({
    _esriJsonGeometryToLeaflet: function(a, b) {
        var d, e;
        if (a.x && a.y) d = new L.Marker(new L.LatLng(a.y, a.x), b); else if (a.points) {
            e = [];
            for (var c = 0, f = a.points.length; c < f; c++) e.push(new L.Marker(new L.LatLng(a.points[c].y, a.points[c].x), b));
        } else if (a.paths) if (a.paths.length > 1) {
            e = [];
            c = 0;
            for (f = a.paths.length; c < f; c++) {
                for (var g = [], h = 0, j = a.paths[c].length; h < j; h++) g.push(new L.LatLng(a.paths[c][h][1], a.paths[c][h][0]));
                e.push(new L.Polyline(g, b));
            }
        } else {
            g = [];
            c = 0;
            for (f = a.paths[0].length; c < f; c++) g.push(new L.LatLng(a.paths[0][c][1], a.paths[0][c][0]));
            d = new L.Polyline(g, b);
        } else if (a.rings) if (a.rings.length > 1) {
            e = [];
            c = 0;
            for (f = a.rings.length; c < f; c++) {
                for (var i = [], g = [], h = 0, j = a.rings[c].length; h < j; h++) g.push(new L.LatLng(a.rings[c][h][1], a.rings[c][h][0]));
                i.push(g);
                e.push(new L.Polygon(i, b));
            }
        } else {
            i = [];
            g = [];
            c = 0;
            for (f = a.rings[0].length; c < f; c++) g.push(new L.LatLng(a.rings[0][c][1], a.rings[0][c][0]));
            i.push(g);
            d = new L.Polygon(i, b);
        }
        return d || e;
    }
});

lvector.AGS = lvector.EsriJSONLayer.extend({
    initialize: function(a) {
        for (var b = 0, d = this._requiredParams.length; b < d; b++) if (!a[this._requiredParams[b]]) throw Error('No "' + this._requiredParams[b] + '" parameter found.');
        this._globalPointer = "AGS_" + Math.floor(Math.random() * 1e5);
        window[this._globalPointer] = this;
        a.url.substr(a.url.length - 1, 1) !== "/" && (a.url += "/");
        this._originalOptions = L.Util.extend({}, a);
        if (a.esriOptions) if (typeof a.esriOptions == "object") L.Util.extend(a, this._convertEsriOptions(a.esriOptions)); else {
            this._getEsriOptions();
            return;
        }
        lvector.Layer.prototype.initialize.call(this, a);
        if (this.options.where) this.options.where = encodeURIComponent(this.options.where);
        this._vectors = [];
        if (this.options.map) {
            if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) a = this.options.map.getZoom(), 
            b = this.options.scaleRange, this.options.visibleAtScale = a >= b[0] && a <= b[1];
            this._show();
        }
    },
    options: {
        where: "1=1",
        url: null,
        useEsriOptions: !1
    },
    _requiredParams: [ "url" ],
    _convertEsriOptions: function(a) {
        var b = {};
        if (!(a.minScale == void 0 || a.maxScale == void 0)) {
            var d = this._scaleToLevel(a.minScale), e = this._scaleToLevel(a.maxScale);
            e == 0 && (e = 20);
            b.scaleRange = [ d, e ];
        }
        if (a.drawingInfo && a.drawingInfo.renderer) b.symbology = this._renderOptionsToSymbology(a.drawingInfo.renderer);
        return b;
    },
    _getEsriOptions: function() {
        this._makeJsonpRequest(this._originalOptions.url + "?f=json&callback=" + this._globalPointer + "._processEsriOptions");
    },
    _processEsriOptions: function(a) {
        var b = this._originalOptions;
        b.esriOptions = a;
        this.initialize(b);
    },
    _scaleToLevel: function(a) {
        var b = [ 591657527.591555, 295828763.795777, 147914381.897889, 73957190.948944, 36978595.474472, 18489297.737236, 9244648.868618, 4622324.434309, 2311162.217155, 1155581.108577, 577790.554289, 288895.277144, 144447.638572, 72223.819286, 36111.909643, 18055.954822, 9027.977411, 4513.988705, 2256.994353, 1128.497176, 564.248588, 282.124294 ];
        if (a == 0) return 0;
        for (var d = 0, e = 0; e < b.length - 1; e++) {
            var c = b[e + 1];
            if (a <= b[e] && a > c) {
                d = e;
                break;
            }
        }
        return d;
    },
    _renderOptionsToSymbology: function(a) {
        symbology = {};
        switch (a.type) {
          case "simple":
            symbology.type = "single";
            symbology.vectorOptions = this._parseSymbology(a.symbol);
            break;

          case "uniqueValue":
            symbology.type = "unique";
            symbology.property = a.field1;
            for (var b = [], d = 0; d < a.uniqueValueInfos.length; d++) {
                var e = a.uniqueValueInfos[d], c = {};
                c.value = e.value;
                c.vectorOptions = this._parseSymbology(e.symbol);
                c.label = e.label;
                b.push(c);
            }
            symbology.values = b;
            break;

          case "classBreaks":
            symbology.type = "range";
            symbology.property = rend.field;
            b = [];
            e = a.minValue;
            for (d = 0; d < a.classBreakInfos.length; d++) {
                var c = a.classBreakInfos[d], f = {};
                f.range = [ e, c.classMaxValue ];
                e = c.classMaxValue;
                f.vectorOptions = this._parseSymbology(c.symbol);
                f.label = c.label;
                b.push(f);
            }
            symbology.ranges = b;
        }
        return symbology;
    },
    _parseSymbology: function(a) {
        var b = {};
        switch (a.type) {
          case "esriSMS":
          case "esriPMS":
            a = L.icon({
                iconUrl: "data:" + a.contentType + ";base64," + a.imageData,
                shadowUrl: null,
                iconSize: new L.Point(a.width, a.height),
                iconAnchor: new L.Point(a.width / 2 + a.xoffset, a.height / 2 + a.yoffset),
                popupAnchor: new L.Point(0, -(a.height / 2))
            });
            b.icon = a;
            break;

          case "esriSLS":
            b.weight = a.width;
            b.color = this._parseColor(a.color);
            b.opacity = this._parseAlpha(a.color[3]);
            break;

          case "esriSFS":
            a.outline ? (b.weight = a.outline.width, b.color = this._parseColor(a.outline.color), 
            b.opacity = this._parseAlpha(a.outline.color[3])) : (b.weight = 0, b.color = "#000000", 
            b.opacity = 0), a.style != "esriSFSNull" ? (b.fillColor = this._parseColor(a.color), 
            b.fillOpacity = this._parseAlpha(a.color[3])) : (b.fillColor = "#000000", b.fillOpacity = 0);
        }
        return b;
    },
    _parseColor: function(a) {
        red = this._normalize(a[0]);
        green = this._normalize(a[1]);
        blue = this._normalize(a[2]);
        return "#" + this._pad(red.toString(16)) + this._pad(green.toString(16)) + this._pad(blue.toString(16));
    },
    _normalize: function(a) {
        return a < 1 && a > 0 ? Math.floor(a * 255) : a;
    },
    _pad: function(a) {
        return a.length > 1 ? a.toUpperCase() : "0" + a.toUpperCase();
    },
    _parseAlpha: function(a) {
        return a / 255;
    },
    _getFeatures: function() {
        var a = this.options.url + "query?returnGeometry=true&outSR=4326&f=json&outFields=" + this.options.fields + "&where=" + this.options.where + "&callback=" + this._globalPointer + "._processFeatures";
        this.options.showAll || (a += "&inSR=4326&spatialRel=esriSpatialRelIntersects&geometryType=esriGeometryEnvelope&geometry=" + this.options.map.getBounds().toBBoxString());
        this._makeJsonpRequest(a);
    }
});

lvector.A2E = lvector.AGS.extend({
    initialize: function(a) {
        for (var b = 0, d = this._requiredParams.length; b < d; b++) if (!a[this._requiredParams[b]]) throw Error('No "' + this._requiredParams[b] + '" parameter found.');
        this._globalPointer = "A2E_" + Math.floor(Math.random() * 1e5);
        window[this._globalPointer] = this;
        a.url.substr(a.url.length - 1, 1) !== "/" && (a.url += "/");
        this._originalOptions = L.Util.extend({}, a);
        if (a.esriOptions) if (typeof a.esriOptions == "object") L.Util.extend(a, this._convertEsriOptions(a.esriOptions)); else {
            this._getEsriOptions();
            return;
        }
        lvector.Layer.prototype.initialize.call(this, a);
        if (this.options.where) this.options.where = encodeURIComponent(this.options.where);
        this._vectors = [];
        if (this.options.map) {
            if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) a = this.options.map.getZoom(), 
            b = this.options.scaleRange, this.options.visibleAtScale = a >= b[0] && a <= b[1];
            this._show();
        }
        if (this.options.autoUpdate && this.options.esriOptions.editFeedInfo) {
            this._makeJsonpRequest("http://cdn.pubnub.com/pubnub-3.1.min.js");
            var e = this;
            this._pubNubScriptLoaderInterval = setInterval(function() {
                window.PUBNUB && e._pubNubScriptLoaded();
            }, 200);
        }
    },
    _pubNubScriptLoaded: function() {
        clearInterval(this._pubNubScriptLoaderInterval);
        this.pubNub = PUBNUB.init({
            subscribe_key: this.options.esriOptions.editFeedInfo.pubnubSubscribeKey,
            ssl: !1,
            origin: "pubsub.pubnub.com"
        });
        var a = this;
        this.pubNub.subscribe({
            channel: this.options.esriOptions.editFeedInfo.pubnubChannel,
            callback: function() {
                a._getFeatures();
            },
            error: function() {}
        });
    }
});

lvector.GeoIQ = lvector.GeoJSONLayer.extend({
    initialize: function(a) {
        for (var b = 0, d = this._requiredParams.length; b < d; b++) if (!a[this._requiredParams[b]]) throw Error('No "' + this._requiredParams[b] + '" parameter found.');
        lvector.Layer.prototype.initialize.call(this, a);
        this._globalPointer = "GeoIQ_" + Math.floor(Math.random() * 1e5);
        window[this._globalPointer] = this;
        this._vectors = [];
        if (this.options.map) {
            if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) a = this.options.map.getZoom(), 
            b = this.options.scaleRange, this.options.visibleAtScale = a >= b[0] && a <= b[1];
            this._show();
        }
    },
    options: {
        dataset: null
    },
    _requiredParams: [ "dataset" ],
    _getFeatures: function() {
        var a = "http://geocommons.com/datasets/" + this.options.dataset + "/features.json?geojson=1&callback=" + this._globalPointer + "._processFeatures&limit=999";
        this.options.showAll || (a += "&bbox=" + this.options.map.getBounds().toBBoxString() + "&intersect=full");
        this._makeJsonpRequest(a);
    }
});

lvector.CartoDB = lvector.GeoJSONLayer.extend({
    initialize: function(a) {
        for (var b = 0, d = this._requiredParams.length; b < d; b++) if (!a[this._requiredParams[b]]) throw Error('No "' + this._requiredParams[b] + '" parameter found.');
        lvector.Layer.prototype.initialize.call(this, a);
        this._globalPointer = "CartoDB_" + Math.floor(Math.random() * 1e5);
        window[this._globalPointer] = this;
        this._vectors = [];
        if (this.options.map) {
            if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) a = this.options.map.getZoom(), 
            b = this.options.scaleRange, this.options.visibleAtScale = a >= b[0] && a <= b[1];
            this._show();
        }
    },
    options: {
        version: 1,
        user: null,
        table: null,
        fields: "*",
        where: null,
        limit: null,
        uniqueField: "cartodb_id"
    },
    _requiredParams: [ "user", "table" ],
    _getFeatures: function() {
        var a = this.options.where || "";
        if (!this.options.showAll) for (var b = this.options.map.getBounds(), d = b.getSouthWest(), b = b.getNorthEast(), e = this.options.table.split(",").length, c = 0; c < e; c++) a += (a.length ? " AND " : "") + (e > 1 ? this.options.table.split(",")[c].split(".")[0] + ".the_geom" : "the_geom") + " && st_setsrid(st_makebox2d(st_point(" + d.lng + "," + d.lat + "),st_point(" + b.lng + "," + b.lat + ")),4326)";
        this.options.limit && (a += (a.length ? " " : "") + "limit " + this.options.limit);
        a = a.length ? " " + a : "";
        this._makeJsonpRequest("http://" + this.options.user + ".cartodb.com/api/v" + this.options.version + "/sql?q=" + encodeURIComponent("SELECT " + this.options.fields + " FROM " + this.options.table + (a.length ? " WHERE " + a : "")) + "&format=geojson&callback=" + this._globalPointer + "._processFeatures");
    }
});

lvector.PRWSF = lvector.GeoJSONLayer.extend({
    initialize: function(a) {
        for (var b = 0, d = this._requiredParams.length; b < d; b++) if (!a[this._requiredParams[b]]) throw Error('No "' + this._requiredParams[b] + '" parameter found.');
        a.url.substr(a.url.length - 1, 1) !== "/" && (a.url += "/");
        lvector.Layer.prototype.initialize.call(this, a);
        this._globalPointer = "PRWSF_" + Math.floor(Math.random() * 1e5);
        window[this._globalPointer] = this;
        this._vectors = [];
        if (this.options.map) {
            if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) a = this.options.map.getZoom(), 
            b = this.options.scaleRange, this.options.visibleAtScale = a >= b[0] && a <= b[1];
            this._show();
        }
    },
    options: {
        geotable: null,
        srid: null,
        geomFieldName: "the_geom",
        geomPrecision: "",
        fields: "",
        where: null,
        limit: null,
        uniqueField: null
    },
    _requiredParams: [ "url", "geotable" ],
    _getFeatures: function() {
        var a = this.options.where || "";
        if (!this.options.showAll) {
            var b = this.options.map.getBounds(), d = b.getSouthWest(), b = b.getNorthEast();
            a += a.length ? " AND " : "";
            a += this.options.srid ? this.options.geomFieldName + " && transform(st_setsrid(st_makebox2d(st_point(" + d.lng + "," + d.lat + "),st_point(" + b.lng + "," + b.lat + ")),4326)," + this.options.srid + ")" : "transform(" + this.options.geomFieldName + ",4326) && st_setsrid(st_makebox2d(st_point(" + d.lng + "," + d.lat + "),st_point(" + b.lng + "," + b.lat + ")),4326)";
        }
        this.options.limit && (a += (a.length ? " " : "") + "limit " + this.options.limit);
        d = (this.options.fields.length ? this.options.fields + "," : "") + "st_asgeojson(transform(" + this.options.geomFieldName + ",4326)" + (this.options.geomPrecision ? "," + this.options.geomPrecision : "") + ") as geojson";
        this._makeJsonpRequest(this.options.url + "v1/ws_geo_attributequery.php?parameters=" + encodeURIComponent(a) + "&geotable=" + this.options.geotable + "&fields=" + encodeURIComponent(d) + "&format=json&callback=" + this._globalPointer + "._processFeatures");
    }
});

lvector.GISCloud = lvector.GeoJSONLayer.extend({
    initialize: function(a) {
        for (var b = 0, d = this._requiredParams.length; b < d; b++) if (!a[this._requiredParams[b]]) throw Error('No "' + this._requiredParams[b] + '" parameter found.');
        lvector.Layer.prototype.initialize.call(this, a);
        this._globalPointer = "GISCloud_" + Math.floor(Math.random() * 1e5);
        window[this._globalPointer] = this;
        this._vectors = [];
        if (this.options.map) {
            if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) a = this.options.map.getZoom(), 
            b = this.options.scaleRange, this.options.visibleAtScale = a >= b[0] && a <= b[1];
            this._show();
        }
    },
    options: {
        mapID: null,
        layerID: null,
        uniqueField: "id"
    },
    _requiredParams: [ "mapID", "layerID" ],
    _getFeatures: function() {
        var a = "http://api.giscloud.com/1/maps/" + this.options.mapID + "/layers/" + this.options.layerID + "/features.json?geometry=geojson&epsg=4326&callback=" + this._globalPointer + "._processFeatures";
        this.options.showAll || (a += "&bounds=" + this.options.map.getBounds().toBBoxString());
        this.options.where && (a += "&where=" + encodeURIComponent(this.options.where));
        this._makeJsonpRequest(a);
    }
});

lvector.GitSpatial = lvector.GeoJSONLayer.extend({
    initialize: function(a) {
        for (var b = 0, d = this._requiredParams.length; b < d; b++) if (!a[this._requiredParams[b]]) throw Error('No "' + this._requiredParams[b] + '" parameter found.');
        lvector.Layer.prototype.initialize.call(this, a);
        this._globalPointer = "GitSpatial_" + Math.floor(Math.random() * 1e5);
        window[this._globalPointer] = this;
        this._vectors = [];
        if (this.options.map) {
            if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) a = this.options.map.getZoom(), 
            b = this.options.scaleRange, this.options.visibleAtScale = a >= b[0] && a <= b[1];
            this._show();
        }
    },
    options: {},
    _requiredParams: [ "user", "repo", "featureSet" ],
    _getFeatures: function() {
        var a = "http://gitspatial.com/api/v1/" + this.options.user + "/" + this.options.repo + "/" + this.options.featureSet + "?callback=" + this._globalPointer + "._processFeatures";
        this.options.showAll || (a += "&bbox=" + this.options.map.getBounds().toBBoxString());
        this._makeJsonpRequest(a);
    }
});

(function(window, document, undefined) {
    L.MarkerClusterGroup = L.FeatureGroup.extend({
        options: {
            maxClusterRadius: 80,
            iconCreateFunction: null,
            spiderfyOnMaxZoom: true,
            showCoverageOnHover: true,
            zoomToBoundsOnClick: true,
            singleMarkerMode: false,
            disableClusteringAtZoom: null,
            removeOutsideVisibleBounds: true,
            animateAddingMarkers: false,
            spiderfyDistanceMultiplier: 1,
            chunkedLoading: false,
            chunkInterval: 200,
            chunkDelay: 50,
            chunkProgress: null,
            polygonOptions: {}
        },
        initialize: function(options) {
            L.Util.setOptions(this, options);
            if (!this.options.iconCreateFunction) {
                this.options.iconCreateFunction = this._defaultIconCreateFunction;
            }
            this._featureGroup = L.featureGroup();
            this._featureGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
            this._nonPointGroup = L.featureGroup();
            this._nonPointGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
            this._inZoomAnimation = 0;
            this._needsClustering = [];
            this._needsRemoving = [];
            this._currentShownBounds = null;
            this._queue = [];
        },
        addLayer: function(layer) {
            if (layer instanceof L.LayerGroup) {
                var array = [];
                for (var i in layer._layers) {
                    array.push(layer._layers[i]);
                }
                return this.addLayers(array);
            }
            if (!layer.getLatLng) {
                this._nonPointGroup.addLayer(layer);
                return this;
            }
            if (!this._map) {
                this._needsClustering.push(layer);
                return this;
            }
            if (this.hasLayer(layer)) {
                return this;
            }
            if (this._unspiderfy) {
                this._unspiderfy();
            }
            this._addLayer(layer, this._maxZoom);
            var visibleLayer = layer, currentZoom = this._map.getZoom();
            if (layer.__parent) {
                while (visibleLayer.__parent._zoom >= currentZoom) {
                    visibleLayer = visibleLayer.__parent;
                }
            }
            if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
                if (this.options.animateAddingMarkers) {
                    this._animationAddLayer(layer, visibleLayer);
                } else {
                    this._animationAddLayerNonAnimated(layer, visibleLayer);
                }
            }
            return this;
        },
        removeLayer: function(layer) {
            if (layer instanceof L.LayerGroup) {
                var array = [];
                for (var i in layer._layers) {
                    array.push(layer._layers[i]);
                }
                return this.removeLayers(array);
            }
            if (!layer.getLatLng) {
                this._nonPointGroup.removeLayer(layer);
                return this;
            }
            if (!this._map) {
                if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
                    this._needsRemoving.push(layer);
                }
                return this;
            }
            if (!layer.__parent) {
                return this;
            }
            if (this._unspiderfy) {
                this._unspiderfy();
                this._unspiderfyLayer(layer);
            }
            this._removeLayer(layer, true);
            if (this._featureGroup.hasLayer(layer)) {
                this._featureGroup.removeLayer(layer);
                if (layer.setOpacity) {
                    layer.setOpacity(1);
                }
            }
            return this;
        },
        addLayers: function(layersArray) {
            var fg = this._featureGroup, npg = this._nonPointGroup, chunked = this.options.chunkedLoading, chunkInterval = this.options.chunkInterval, chunkProgress = this.options.chunkProgress, newMarkers, i, l, m;
            if (this._map) {
                var offset = 0, started = new Date().getTime();
                var process = L.bind(function() {
                    var start = new Date().getTime();
                    for (;offset < layersArray.length; offset++) {
                        if (chunked && offset % 200 === 0) {
                            var elapsed = new Date().getTime() - start;
                            if (elapsed > chunkInterval) {
                                break;
                            }
                        }
                        m = layersArray[offset];
                        if (!m.getLatLng) {
                            npg.addLayer(m);
                            continue;
                        }
                        if (this.hasLayer(m)) {
                            continue;
                        }
                        this._addLayer(m, this._maxZoom);
                        if (m.__parent) {
                            if (m.__parent.getChildCount() === 2) {
                                var markers = m.__parent.getAllChildMarkers(), otherMarker = markers[0] === m ? markers[1] : markers[0];
                                fg.removeLayer(otherMarker);
                            }
                        }
                    }
                    if (chunkProgress) {
                        chunkProgress(offset, layersArray.length, new Date().getTime() - started);
                    }
                    if (offset === layersArray.length) {
                        this._featureGroup.eachLayer(function(c) {
                            if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
                                c._updateIcon();
                            }
                        });
                        this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
                    } else {
                        setTimeout(process, this.options.chunkDelay);
                    }
                }, this);
                process();
            } else {
                newMarkers = [];
                for (i = 0, l = layersArray.length; i < l; i++) {
                    m = layersArray[i];
                    if (!m.getLatLng) {
                        npg.addLayer(m);
                        continue;
                    }
                    if (this.hasLayer(m)) {
                        continue;
                    }
                    newMarkers.push(m);
                }
                this._needsClustering = this._needsClustering.concat(newMarkers);
            }
            return this;
        },
        removeLayers: function(layersArray) {
            var i, l, m, fg = this._featureGroup, npg = this._nonPointGroup;
            if (!this._map) {
                for (i = 0, l = layersArray.length; i < l; i++) {
                    m = layersArray[i];
                    this._arraySplice(this._needsClustering, m);
                    npg.removeLayer(m);
                }
                return this;
            }
            for (i = 0, l = layersArray.length; i < l; i++) {
                m = layersArray[i];
                if (!m.__parent) {
                    npg.removeLayer(m);
                    continue;
                }
                this._removeLayer(m, true, true);
                if (fg.hasLayer(m)) {
                    fg.removeLayer(m);
                    if (m.setOpacity) {
                        m.setOpacity(1);
                    }
                }
            }
            this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
            fg.eachLayer(function(c) {
                if (c instanceof L.MarkerCluster) {
                    c._updateIcon();
                }
            });
            return this;
        },
        clearLayers: function() {
            if (!this._map) {
                this._needsClustering = [];
                delete this._gridClusters;
                delete this._gridUnclustered;
            }
            if (this._noanimationUnspiderfy) {
                this._noanimationUnspiderfy();
            }
            this._featureGroup.clearLayers();
            this._nonPointGroup.clearLayers();
            this.eachLayer(function(marker) {
                delete marker.__parent;
            });
            if (this._map) {
                this._generateInitialClusters();
            }
            return this;
        },
        getBounds: function() {
            var bounds = new L.LatLngBounds();
            if (this._topClusterLevel) {
                bounds.extend(this._topClusterLevel._bounds);
            }
            for (var i = this._needsClustering.length - 1; i >= 0; i--) {
                bounds.extend(this._needsClustering[i].getLatLng());
            }
            bounds.extend(this._nonPointGroup.getBounds());
            return bounds;
        },
        eachLayer: function(method, context) {
            var markers = this._needsClustering.slice(), i;
            if (this._topClusterLevel) {
                this._topClusterLevel.getAllChildMarkers(markers);
            }
            for (i = markers.length - 1; i >= 0; i--) {
                method.call(context, markers[i]);
            }
            this._nonPointGroup.eachLayer(method, context);
        },
        getLayers: function() {
            var layers = [];
            this.eachLayer(function(l) {
                layers.push(l);
            });
            return layers;
        },
        getLayer: function(id) {
            var result = null;
            this.eachLayer(function(l) {
                if (L.stamp(l) === id) {
                    result = l;
                }
            });
            return result;
        },
        hasLayer: function(layer) {
            if (!layer) {
                return false;
            }
            var i, anArray = this._needsClustering;
            for (i = anArray.length - 1; i >= 0; i--) {
                if (anArray[i] === layer) {
                    return true;
                }
            }
            anArray = this._needsRemoving;
            for (i = anArray.length - 1; i >= 0; i--) {
                if (anArray[i] === layer) {
                    return false;
                }
            }
            return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
        },
        zoomToShowLayer: function(layer, callback) {
            var showMarker = function() {
                if ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {
                    this._map.off("moveend", showMarker, this);
                    this.off("animationend", showMarker, this);
                    if (layer._icon) {
                        callback();
                    } else if (layer.__parent._icon) {
                        var afterSpiderfy = function() {
                            this.off("spiderfied", afterSpiderfy, this);
                            callback();
                        };
                        this.on("spiderfied", afterSpiderfy, this);
                        layer.__parent.spiderfy();
                    }
                }
            };
            if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
                callback();
            } else if (layer.__parent._zoom < this._map.getZoom()) {
                this._map.on("moveend", showMarker, this);
                this._map.panTo(layer.getLatLng());
            } else {
                var moveStart = function() {
                    this._map.off("movestart", moveStart, this);
                    moveStart = null;
                };
                this._map.on("movestart", moveStart, this);
                this._map.on("moveend", showMarker, this);
                this.on("animationend", showMarker, this);
                layer.__parent.zoomToBounds();
                if (moveStart) {
                    showMarker.call(this);
                }
            }
        },
        onAdd: function(map) {
            this._map = map;
            var i, l, layer;
            if (!isFinite(this._map.getMaxZoom())) {
                throw "Map has no maxZoom specified";
            }
            this._featureGroup.onAdd(map);
            this._nonPointGroup.onAdd(map);
            if (!this._gridClusters) {
                this._generateInitialClusters();
            }
            for (i = 0, l = this._needsRemoving.length; i < l; i++) {
                layer = this._needsRemoving[i];
                this._removeLayer(layer, true);
            }
            this._needsRemoving = [];
            this._zoom = this._map.getZoom();
            this._currentShownBounds = this._getExpandedVisibleBounds();
            this._map.on("zoomend", this._zoomEnd, this);
            this._map.on("moveend", this._moveEnd, this);
            if (this._spiderfierOnAdd) {
                this._spiderfierOnAdd();
            }
            this._bindEvents();
            l = this._needsClustering;
            this._needsClustering = [];
            this.addLayers(l);
        },
        onRemove: function(map) {
            map.off("zoomend", this._zoomEnd, this);
            map.off("moveend", this._moveEnd, this);
            this._unbindEvents();
            this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "");
            if (this._spiderfierOnRemove) {
                this._spiderfierOnRemove();
            }
            this._hideCoverage();
            this._featureGroup.onRemove(map);
            this._nonPointGroup.onRemove(map);
            this._featureGroup.clearLayers();
            this._map = null;
        },
        getVisibleParent: function(marker) {
            var vMarker = marker;
            while (vMarker && !vMarker._icon) {
                vMarker = vMarker.__parent;
            }
            return vMarker || null;
        },
        _arraySplice: function(anArray, obj) {
            for (var i = anArray.length - 1; i >= 0; i--) {
                if (anArray[i] === obj) {
                    anArray.splice(i, 1);
                    return true;
                }
            }
        },
        _removeLayer: function(marker, removeFromDistanceGrid, dontUpdateMap) {
            var gridClusters = this._gridClusters, gridUnclustered = this._gridUnclustered, fg = this._featureGroup, map = this._map;
            if (removeFromDistanceGrid) {
                for (var z = this._maxZoom; z >= 0; z--) {
                    if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
                        break;
                    }
                }
            }
            var cluster = marker.__parent, markers = cluster._markers, otherMarker;
            this._arraySplice(markers, marker);
            while (cluster) {
                cluster._childCount--;
                if (cluster._zoom < 0) {
                    break;
                } else if (removeFromDistanceGrid && cluster._childCount <= 1) {
                    otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];
                    gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
                    gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));
                    this._arraySplice(cluster.__parent._childClusters, cluster);
                    cluster.__parent._markers.push(otherMarker);
                    otherMarker.__parent = cluster.__parent;
                    if (cluster._icon) {
                        fg.removeLayer(cluster);
                        if (!dontUpdateMap) {
                            fg.addLayer(otherMarker);
                        }
                    }
                } else {
                    cluster._recalculateBounds();
                    if (!dontUpdateMap || !cluster._icon) {
                        cluster._updateIcon();
                    }
                }
                cluster = cluster.__parent;
            }
            delete marker.__parent;
        },
        _isOrIsParent: function(el, oel) {
            while (oel) {
                if (el === oel) {
                    return true;
                }
                oel = oel.parentNode;
            }
            return false;
        },
        _propagateEvent: function(e) {
            if (e.layer instanceof L.MarkerCluster) {
                if (e.originalEvent && this._isOrIsParent(e.layer._icon, e.originalEvent.relatedTarget)) {
                    return;
                }
                e.type = "cluster" + e.type;
            }
            this.fire(e.type, e);
        },
        _defaultIconCreateFunction: function(cluster) {
            var childCount = cluster.getChildCount();
            var c = " marker-cluster-";
            if (childCount < 10) {
                c += "small";
            } else if (childCount < 100) {
                c += "medium";
            } else {
                c += "large";
            }
            return new L.DivIcon({
                html: "<div><span>" + childCount + "</span></div>",
                className: "marker-cluster" + c,
                iconSize: new L.Point(40, 40)
            });
        },
        _bindEvents: function() {
            var map = this._map, spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom, showCoverageOnHover = this.options.showCoverageOnHover, zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;
            if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
                this.on("clusterclick", this._zoomOrSpiderfy, this);
            }
            if (showCoverageOnHover) {
                this.on("clustermouseover", this._showCoverage, this);
                this.on("clustermouseout", this._hideCoverage, this);
                map.on("zoomend", this._hideCoverage, this);
            }
        },
        _zoomOrSpiderfy: function(e) {
            var map = this._map;
            if (map.getMaxZoom() === map.getZoom()) {
                if (this.options.spiderfyOnMaxZoom) {
                    e.layer.spiderfy();
                }
            } else if (this.options.zoomToBoundsOnClick) {
                e.layer.zoomToBounds();
            }
            if (e.originalEvent && e.originalEvent.keyCode === 13) {
                map._container.focus();
            }
        },
        _showCoverage: function(e) {
            var map = this._map;
            if (this._inZoomAnimation) {
                return;
            }
            if (this._shownPolygon) {
                map.removeLayer(this._shownPolygon);
            }
            if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
                this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
                map.addLayer(this._shownPolygon);
            }
        },
        _hideCoverage: function() {
            if (this._shownPolygon) {
                this._map.removeLayer(this._shownPolygon);
                this._shownPolygon = null;
            }
        },
        _unbindEvents: function() {
            var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom, showCoverageOnHover = this.options.showCoverageOnHover, zoomToBoundsOnClick = this.options.zoomToBoundsOnClick, map = this._map;
            if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
                this.off("clusterclick", this._zoomOrSpiderfy, this);
            }
            if (showCoverageOnHover) {
                this.off("clustermouseover", this._showCoverage, this);
                this.off("clustermouseout", this._hideCoverage, this);
                map.off("zoomend", this._hideCoverage, this);
            }
        },
        _zoomEnd: function() {
            if (!this._map) {
                return;
            }
            this._mergeSplitClusters();
            this._zoom = this._map._zoom;
            this._currentShownBounds = this._getExpandedVisibleBounds();
        },
        _moveEnd: function() {
            if (this._inZoomAnimation) {
                return;
            }
            var newBounds = this._getExpandedVisibleBounds();
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, newBounds);
            this._topClusterLevel._recursivelyAddChildrenToMap(null, this._map._zoom, newBounds);
            this._currentShownBounds = newBounds;
            return;
        },
        _generateInitialClusters: function() {
            var maxZoom = this._map.getMaxZoom(), radius = this.options.maxClusterRadius, radiusFn = radius;
            if (typeof radius !== "function") {
                radiusFn = function() {
                    return radius;
                };
            }
            if (this.options.disableClusteringAtZoom) {
                maxZoom = this.options.disableClusteringAtZoom - 1;
            }
            this._maxZoom = maxZoom;
            this._gridClusters = {};
            this._gridUnclustered = {};
            for (var zoom = maxZoom; zoom >= 0; zoom--) {
                this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));
                this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
            }
            this._topClusterLevel = new L.MarkerCluster(this, -1);
        },
        _addLayer: function(layer, zoom) {
            var gridClusters = this._gridClusters, gridUnclustered = this._gridUnclustered, markerPoint, z;
            if (this.options.singleMarkerMode) {
                layer.options.icon = this.options.iconCreateFunction({
                    getChildCount: function() {
                        return 1;
                    },
                    getAllChildMarkers: function() {
                        return [ layer ];
                    }
                });
            }
            for (;zoom >= 0; zoom--) {
                markerPoint = this._map.project(layer.getLatLng(), zoom);
                var closest = gridClusters[zoom].getNearObject(markerPoint);
                if (closest) {
                    closest._addChild(layer);
                    layer.__parent = closest;
                    return;
                }
                closest = gridUnclustered[zoom].getNearObject(markerPoint);
                if (closest) {
                    var parent = closest.__parent;
                    if (parent) {
                        this._removeLayer(closest, false);
                    }
                    var newCluster = new L.MarkerCluster(this, zoom, closest, layer);
                    gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
                    closest.__parent = newCluster;
                    layer.__parent = newCluster;
                    var lastParent = newCluster;
                    for (z = zoom - 1; z > parent._zoom; z--) {
                        lastParent = new L.MarkerCluster(this, z, lastParent);
                        gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
                    }
                    parent._addChild(lastParent);
                    for (z = zoom; z >= 0; z--) {
                        if (!gridUnclustered[z].removeObject(closest, this._map.project(closest.getLatLng(), z))) {
                            break;
                        }
                    }
                    return;
                }
                gridUnclustered[zoom].addObject(layer, markerPoint);
            }
            this._topClusterLevel._addChild(layer);
            layer.__parent = this._topClusterLevel;
            return;
        },
        _enqueue: function(fn) {
            this._queue.push(fn);
            if (!this._queueTimeout) {
                this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
            }
        },
        _processQueue: function() {
            for (var i = 0; i < this._queue.length; i++) {
                this._queue[i].call(this);
            }
            this._queue.length = 0;
            clearTimeout(this._queueTimeout);
            this._queueTimeout = null;
        },
        _mergeSplitClusters: function() {
            this._processQueue();
            if (this._zoom < this._map._zoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) {
                this._animationStart();
                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, this._getExpandedVisibleBounds());
                this._animationZoomIn(this._zoom, this._map._zoom);
            } else if (this._zoom > this._map._zoom) {
                this._animationStart();
                this._animationZoomOut(this._zoom, this._map._zoom);
            } else {
                this._moveEnd();
            }
        },
        _getExpandedVisibleBounds: function() {
            if (!this.options.removeOutsideVisibleBounds) {
                return this.getBounds();
            }
            var map = this._map, bounds = map.getBounds(), sw = bounds._southWest, ne = bounds._northEast, latDiff = L.Browser.mobile ? 0 : Math.abs(sw.lat - ne.lat), lngDiff = L.Browser.mobile ? 0 : Math.abs(sw.lng - ne.lng);
            return new L.LatLngBounds(new L.LatLng(sw.lat - latDiff, sw.lng - lngDiff, true), new L.LatLng(ne.lat + latDiff, ne.lng + lngDiff, true));
        },
        _animationAddLayerNonAnimated: function(layer, newCluster) {
            if (newCluster === layer) {
                this._featureGroup.addLayer(layer);
            } else if (newCluster._childCount === 2) {
                newCluster._addToMap();
                var markers = newCluster.getAllChildMarkers();
                this._featureGroup.removeLayer(markers[0]);
                this._featureGroup.removeLayer(markers[1]);
            } else {
                newCluster._updateIcon();
            }
        }
    });
    L.MarkerClusterGroup.include(!L.DomUtil.TRANSITION ? {
        _animationStart: function() {},
        _animationZoomIn: function(previousZoomLevel, newZoomLevel) {
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
            this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
            this.fire("animationend");
        },
        _animationZoomOut: function(previousZoomLevel, newZoomLevel) {
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
            this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
            this.fire("animationend");
        },
        _animationAddLayer: function(layer, newCluster) {
            this._animationAddLayerNonAnimated(layer, newCluster);
        }
    } : {
        _animationStart: function() {
            this._map._mapPane.className += " leaflet-cluster-anim";
            this._inZoomAnimation++;
        },
        _animationEnd: function() {
            if (this._map) {
                this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "");
            }
            this._inZoomAnimation--;
            this.fire("animationend");
        },
        _animationZoomIn: function(previousZoomLevel, newZoomLevel) {
            var bounds = this._getExpandedVisibleBounds(), fg = this._featureGroup, i;
            this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function(c) {
                var startPos = c._latlng, markers = c._markers, m;
                if (!bounds.contains(startPos)) {
                    startPos = null;
                }
                if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) {
                    fg.removeLayer(c);
                    c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
                } else {
                    c.setOpacity(0);
                    c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
                }
                for (i = markers.length - 1; i >= 0; i--) {
                    m = markers[i];
                    if (!bounds.contains(m._latlng)) {
                        fg.removeLayer(m);
                    }
                }
            });
            this._forceLayout();
            this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
            fg.eachLayer(function(n) {
                if (!(n instanceof L.MarkerCluster) && n._icon) {
                    n.setOpacity(1);
                }
            });
            this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function(c) {
                c._recursivelyRestoreChildPositions(newZoomLevel);
            });
            this._enqueue(function() {
                this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function(c) {
                    fg.removeLayer(c);
                    c.setOpacity(1);
                });
                this._animationEnd();
            });
        },
        _animationZoomOut: function(previousZoomLevel, newZoomLevel) {
            this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);
            this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel, this._getExpandedVisibleBounds());
        },
        _animationZoomOutSingle: function(cluster, previousZoomLevel, newZoomLevel) {
            var bounds = this._getExpandedVisibleBounds();
            cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, previousZoomLevel + 1, newZoomLevel);
            var me = this;
            this._forceLayout();
            cluster._recursivelyBecomeVisible(bounds, newZoomLevel);
            this._enqueue(function() {
                if (cluster._childCount === 1) {
                    var m = cluster._markers[0];
                    m.setLatLng(m.getLatLng());
                    if (m.setOpacity) {
                        m.setOpacity(1);
                    }
                } else {
                    cluster._recursively(bounds, newZoomLevel, 0, function(c) {
                        c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel + 1);
                    });
                }
                me._animationEnd();
            });
        },
        _animationAddLayer: function(layer, newCluster) {
            var me = this, fg = this._featureGroup;
            fg.addLayer(layer);
            if (newCluster !== layer) {
                if (newCluster._childCount > 2) {
                    newCluster._updateIcon();
                    this._forceLayout();
                    this._animationStart();
                    layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
                    layer.setOpacity(0);
                    this._enqueue(function() {
                        fg.removeLayer(layer);
                        layer.setOpacity(1);
                        me._animationEnd();
                    });
                } else {
                    this._forceLayout();
                    me._animationStart();
                    me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._map.getZoom());
                }
            }
        },
        _forceLayout: function() {
            L.Util.falseFn(document.body.offsetWidth);
        }
    });
    L.markerClusterGroup = function(options) {
        return new L.MarkerClusterGroup(options);
    };
    L.MarkerCluster = L.Marker.extend({
        initialize: function(group, zoom, a, b) {
            L.Marker.prototype.initialize.call(this, a ? a._cLatLng || a.getLatLng() : new L.LatLng(0, 0), {
                icon: this
            });
            this._group = group;
            this._zoom = zoom;
            this._markers = [];
            this._childClusters = [];
            this._childCount = 0;
            this._iconNeedsUpdate = true;
            this._bounds = new L.LatLngBounds();
            if (a) {
                this._addChild(a);
            }
            if (b) {
                this._addChild(b);
            }
        },
        getAllChildMarkers: function(storageArray) {
            storageArray = storageArray || [];
            for (var i = this._childClusters.length - 1; i >= 0; i--) {
                this._childClusters[i].getAllChildMarkers(storageArray);
            }
            for (var j = this._markers.length - 1; j >= 0; j--) {
                storageArray.push(this._markers[j]);
            }
            return storageArray;
        },
        getChildCount: function() {
            return this._childCount;
        },
        zoomToBounds: function() {
            var childClusters = this._childClusters.slice(), map = this._group._map, boundsZoom = map.getBoundsZoom(this._bounds), zoom = this._zoom + 1, mapZoom = map.getZoom(), i;
            while (childClusters.length > 0 && boundsZoom > zoom) {
                zoom++;
                var newClusters = [];
                for (i = 0; i < childClusters.length; i++) {
                    newClusters = newClusters.concat(childClusters[i]._childClusters);
                }
                childClusters = newClusters;
            }
            if (boundsZoom > zoom) {
                this._group._map.setView(this._latlng, zoom);
            } else if (boundsZoom <= mapZoom) {
                this._group._map.setView(this._latlng, mapZoom + 1);
            } else {
                this._group._map.fitBounds(this._bounds);
            }
        },
        getBounds: function() {
            var bounds = new L.LatLngBounds();
            bounds.extend(this._bounds);
            return bounds;
        },
        _updateIcon: function() {
            this._iconNeedsUpdate = true;
            if (this._icon) {
                this.setIcon(this);
            }
        },
        createIcon: function() {
            if (this._iconNeedsUpdate) {
                this._iconObj = this._group.options.iconCreateFunction(this);
                this._iconNeedsUpdate = false;
            }
            return this._iconObj.createIcon();
        },
        createShadow: function() {
            return this._iconObj.createShadow();
        },
        _addChild: function(new1, isNotificationFromChild) {
            this._iconNeedsUpdate = true;
            this._expandBounds(new1);
            if (new1 instanceof L.MarkerCluster) {
                if (!isNotificationFromChild) {
                    this._childClusters.push(new1);
                    new1.__parent = this;
                }
                this._childCount += new1._childCount;
            } else {
                if (!isNotificationFromChild) {
                    this._markers.push(new1);
                }
                this._childCount++;
            }
            if (this.__parent) {
                this.__parent._addChild(new1, true);
            }
        },
        _expandBounds: function(marker) {
            var addedCount, addedLatLng = marker._wLatLng || marker._latlng;
            if (marker instanceof L.MarkerCluster) {
                this._bounds.extend(marker._bounds);
                addedCount = marker._childCount;
            } else {
                this._bounds.extend(addedLatLng);
                addedCount = 1;
            }
            if (!this._cLatLng) {
                this._cLatLng = marker._cLatLng || addedLatLng;
            }
            var totalCount = this._childCount + addedCount;
            if (!this._wLatLng) {
                this._latlng = this._wLatLng = new L.LatLng(addedLatLng.lat, addedLatLng.lng);
            } else {
                this._wLatLng.lat = (addedLatLng.lat * addedCount + this._wLatLng.lat * this._childCount) / totalCount;
                this._wLatLng.lng = (addedLatLng.lng * addedCount + this._wLatLng.lng * this._childCount) / totalCount;
            }
        },
        _addToMap: function(startPos) {
            if (startPos) {
                this._backupLatlng = this._latlng;
                this.setLatLng(startPos);
            }
            this._group._featureGroup.addLayer(this);
        },
        _recursivelyAnimateChildrenIn: function(bounds, center, maxZoom) {
            this._recursively(bounds, 0, maxZoom - 1, function(c) {
                var markers = c._markers, i, m;
                for (i = markers.length - 1; i >= 0; i--) {
                    m = markers[i];
                    if (m._icon) {
                        m._setPos(center);
                        m.setOpacity(0);
                    }
                }
            }, function(c) {
                var childClusters = c._childClusters, j, cm;
                for (j = childClusters.length - 1; j >= 0; j--) {
                    cm = childClusters[j];
                    if (cm._icon) {
                        cm._setPos(center);
                        cm.setOpacity(0);
                    }
                }
            });
        },
        _recursivelyAnimateChildrenInAndAddSelfToMap: function(bounds, previousZoomLevel, newZoomLevel) {
            this._recursively(bounds, newZoomLevel, 0, function(c) {
                c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);
                if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
                    c.setOpacity(1);
                    c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel);
                } else {
                    c.setOpacity(0);
                }
                c._addToMap();
            });
        },
        _recursivelyBecomeVisible: function(bounds, zoomLevel) {
            this._recursively(bounds, 0, zoomLevel, null, function(c) {
                c.setOpacity(1);
            });
        },
        _recursivelyAddChildrenToMap: function(startPos, zoomLevel, bounds) {
            this._recursively(bounds, -1, zoomLevel, function(c) {
                if (zoomLevel === c._zoom) {
                    return;
                }
                for (var i = c._markers.length - 1; i >= 0; i--) {
                    var nm = c._markers[i];
                    if (!bounds.contains(nm._latlng)) {
                        continue;
                    }
                    if (startPos) {
                        nm._backupLatlng = nm.getLatLng();
                        nm.setLatLng(startPos);
                        if (nm.setOpacity) {
                            nm.setOpacity(0);
                        }
                    }
                    c._group._featureGroup.addLayer(nm);
                }
            }, function(c) {
                c._addToMap(startPos);
            });
        },
        _recursivelyRestoreChildPositions: function(zoomLevel) {
            for (var i = this._markers.length - 1; i >= 0; i--) {
                var nm = this._markers[i];
                if (nm._backupLatlng) {
                    nm.setLatLng(nm._backupLatlng);
                    delete nm._backupLatlng;
                }
            }
            if (zoomLevel - 1 === this._zoom) {
                for (var j = this._childClusters.length - 1; j >= 0; j--) {
                    this._childClusters[j]._restorePosition();
                }
            } else {
                for (var k = this._childClusters.length - 1; k >= 0; k--) {
                    this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
                }
            }
        },
        _restorePosition: function() {
            if (this._backupLatlng) {
                this.setLatLng(this._backupLatlng);
                delete this._backupLatlng;
            }
        },
        _recursivelyRemoveChildrenFromMap: function(previousBounds, zoomLevel, exceptBounds) {
            var m, i;
            this._recursively(previousBounds, -1, zoomLevel - 1, function(c) {
                for (i = c._markers.length - 1; i >= 0; i--) {
                    m = c._markers[i];
                    if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
                        c._group._featureGroup.removeLayer(m);
                        if (m.setOpacity) {
                            m.setOpacity(1);
                        }
                    }
                }
            }, function(c) {
                for (i = c._childClusters.length - 1; i >= 0; i--) {
                    m = c._childClusters[i];
                    if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
                        c._group._featureGroup.removeLayer(m);
                        if (m.setOpacity) {
                            m.setOpacity(1);
                        }
                    }
                }
            });
        },
        _recursively: function(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
            var childClusters = this._childClusters, zoom = this._zoom, i, c;
            if (zoomLevelToStart > zoom) {
                for (i = childClusters.length - 1; i >= 0; i--) {
                    c = childClusters[i];
                    if (boundsToApplyTo.intersects(c._bounds)) {
                        c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
                    }
                }
            } else {
                if (runAtEveryLevel) {
                    runAtEveryLevel(this);
                }
                if (runAtBottomLevel && this._zoom === zoomLevelToStop) {
                    runAtBottomLevel(this);
                }
                if (zoomLevelToStop > zoom) {
                    for (i = childClusters.length - 1; i >= 0; i--) {
                        c = childClusters[i];
                        if (boundsToApplyTo.intersects(c._bounds)) {
                            c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
                        }
                    }
                }
            }
        },
        _recalculateBounds: function() {
            var markers = this._markers, childClusters = this._childClusters, i;
            this._bounds = new L.LatLngBounds();
            delete this._wLatLng;
            for (i = markers.length - 1; i >= 0; i--) {
                this._expandBounds(markers[i]);
            }
            for (i = childClusters.length - 1; i >= 0; i--) {
                this._expandBounds(childClusters[i]);
            }
        },
        _isSingleParent: function() {
            return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
        }
    });
    L.DistanceGrid = function(cellSize) {
        this._cellSize = cellSize;
        this._sqCellSize = cellSize * cellSize;
        this._grid = {};
        this._objectPoint = {};
    };
    L.DistanceGrid.prototype = {
        addObject: function(obj, point) {
            var x = this._getCoord(point.x), y = this._getCoord(point.y), grid = this._grid, row = grid[y] = grid[y] || {}, cell = row[x] = row[x] || [], stamp = L.Util.stamp(obj);
            this._objectPoint[stamp] = point;
            cell.push(obj);
        },
        updateObject: function(obj, point) {
            this.removeObject(obj);
            this.addObject(obj, point);
        },
        removeObject: function(obj, point) {
            var x = this._getCoord(point.x), y = this._getCoord(point.y), grid = this._grid, row = grid[y] = grid[y] || {}, cell = row[x] = row[x] || [], i, len;
            delete this._objectPoint[L.Util.stamp(obj)];
            for (i = 0, len = cell.length; i < len; i++) {
                if (cell[i] === obj) {
                    cell.splice(i, 1);
                    if (len === 1) {
                        delete row[x];
                    }
                    return true;
                }
            }
        },
        eachObject: function(fn, context) {
            var i, j, k, len, row, cell, removed, grid = this._grid;
            for (i in grid) {
                row = grid[i];
                for (j in row) {
                    cell = row[j];
                    for (k = 0, len = cell.length; k < len; k++) {
                        removed = fn.call(context, cell[k]);
                        if (removed) {
                            k--;
                            len--;
                        }
                    }
                }
            }
        },
        getNearObject: function(point) {
            var x = this._getCoord(point.x), y = this._getCoord(point.y), i, j, k, row, cell, len, obj, dist, objectPoint = this._objectPoint, closestDistSq = this._sqCellSize, closest = null;
            for (i = y - 1; i <= y + 1; i++) {
                row = this._grid[i];
                if (row) {
                    for (j = x - 1; j <= x + 1; j++) {
                        cell = row[j];
                        if (cell) {
                            for (k = 0, len = cell.length; k < len; k++) {
                                obj = cell[k];
                                dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
                                if (dist < closestDistSq) {
                                    closestDistSq = dist;
                                    closest = obj;
                                }
                            }
                        }
                    }
                }
            }
            return closest;
        },
        _getCoord: function(x) {
            return Math.floor(x / this._cellSize);
        },
        _sqDist: function(p, p2) {
            var dx = p2.x - p.x, dy = p2.y - p.y;
            return dx * dx + dy * dy;
        }
    };
    (function() {
        L.QuickHull = {
            getDistant: function(cpt, bl) {
                var vY = bl[1].lat - bl[0].lat, vX = bl[0].lng - bl[1].lng;
                return vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng);
            },
            findMostDistantPointFromBaseLine: function(baseLine, latLngs) {
                var maxD = 0, maxPt = null, newPoints = [], i, pt, d;
                for (i = latLngs.length - 1; i >= 0; i--) {
                    pt = latLngs[i];
                    d = this.getDistant(pt, baseLine);
                    if (d > 0) {
                        newPoints.push(pt);
                    } else {
                        continue;
                    }
                    if (d > maxD) {
                        maxD = d;
                        maxPt = pt;
                    }
                }
                return {
                    maxPoint: maxPt,
                    newPoints: newPoints
                };
            },
            buildConvexHull: function(baseLine, latLngs) {
                var convexHullBaseLines = [], t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);
                if (t.maxPoint) {
                    convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([ baseLine[0], t.maxPoint ], t.newPoints));
                    convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([ t.maxPoint, baseLine[1] ], t.newPoints));
                    return convexHullBaseLines;
                } else {
                    return [ baseLine[0] ];
                }
            },
            getConvexHull: function(latLngs) {
                var maxLat = false, minLat = false, maxPt = null, minPt = null, i;
                for (i = latLngs.length - 1; i >= 0; i--) {
                    var pt = latLngs[i];
                    if (maxLat === false || pt.lat > maxLat) {
                        maxPt = pt;
                        maxLat = pt.lat;
                    }
                    if (minLat === false || pt.lat < minLat) {
                        minPt = pt;
                        minLat = pt.lat;
                    }
                }
                var ch = [].concat(this.buildConvexHull([ minPt, maxPt ], latLngs), this.buildConvexHull([ maxPt, minPt ], latLngs));
                return ch;
            }
        };
    })();
    L.MarkerCluster.include({
        getConvexHull: function() {
            var childMarkers = this.getAllChildMarkers(), points = [], p, i;
            for (i = childMarkers.length - 1; i >= 0; i--) {
                p = childMarkers[i].getLatLng();
                points.push(p);
            }
            return L.QuickHull.getConvexHull(points);
        }
    });
    L.MarkerCluster.include({
        _2PI: Math.PI * 2,
        _circleFootSeparation: 25,
        _circleStartAngle: Math.PI / 6,
        _spiralFootSeparation: 28,
        _spiralLengthStart: 11,
        _spiralLengthFactor: 5,
        _circleSpiralSwitchover: 9,
        spiderfy: function() {
            if (this._group._spiderfied === this || this._group._inZoomAnimation) {
                return;
            }
            var childMarkers = this.getAllChildMarkers(), group = this._group, map = group._map, center = map.latLngToLayerPoint(this._latlng), positions;
            this._group._unspiderfy();
            this._group._spiderfied = this;
            if (childMarkers.length >= this._circleSpiralSwitchover) {
                positions = this._generatePointsSpiral(childMarkers.length, center);
            } else {
                center.y += 10;
                positions = this._generatePointsCircle(childMarkers.length, center);
            }
            this._animationSpiderfy(childMarkers, positions);
        },
        unspiderfy: function(zoomDetails) {
            if (this._group._inZoomAnimation) {
                return;
            }
            this._animationUnspiderfy(zoomDetails);
            this._group._spiderfied = null;
        },
        _generatePointsCircle: function(count, centerPt) {
            var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count), legLength = circumference / this._2PI, angleStep = this._2PI / count, res = [], i, angle;
            res.length = count;
            for (i = count - 1; i >= 0; i--) {
                angle = this._circleStartAngle + i * angleStep;
                res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
            }
            return res;
        },
        _generatePointsSpiral: function(count, centerPt) {
            var legLength = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthStart, separation = this._group.options.spiderfyDistanceMultiplier * this._spiralFootSeparation, lengthFactor = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthFactor, angle = 0, res = [], i;
            res.length = count;
            for (i = count - 1; i >= 0; i--) {
                angle += separation / legLength + i * 5e-4;
                res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
                legLength += this._2PI * lengthFactor / angle;
            }
            return res;
        },
        _noanimationUnspiderfy: function() {
            var group = this._group, map = group._map, fg = group._featureGroup, childMarkers = this.getAllChildMarkers(), m, i;
            this.setOpacity(1);
            for (i = childMarkers.length - 1; i >= 0; i--) {
                m = childMarkers[i];
                fg.removeLayer(m);
                if (m._preSpiderfyLatlng) {
                    m.setLatLng(m._preSpiderfyLatlng);
                    delete m._preSpiderfyLatlng;
                }
                if (m.setZIndexOffset) {
                    m.setZIndexOffset(0);
                }
                if (m._spiderLeg) {
                    map.removeLayer(m._spiderLeg);
                    delete m._spiderLeg;
                }
            }
            group._spiderfied = null;
        }
    });
    L.MarkerCluster.include(!L.DomUtil.TRANSITION ? {
        _animationSpiderfy: function(childMarkers, positions) {
            var group = this._group, map = group._map, fg = group._featureGroup, i, m, leg, newPos;
            for (i = childMarkers.length - 1; i >= 0; i--) {
                newPos = map.layerPointToLatLng(positions[i]);
                m = childMarkers[i];
                m._preSpiderfyLatlng = m._latlng;
                m.setLatLng(newPos);
                if (m.setZIndexOffset) {
                    m.setZIndexOffset(1e6);
                }
                fg.addLayer(m);
                leg = new L.Polyline([ this._latlng, newPos ], {
                    weight: 1.5,
                    color: "#222"
                });
                map.addLayer(leg);
                m._spiderLeg = leg;
            }
            this.setOpacity(.3);
            group.fire("spiderfied");
        },
        _animationUnspiderfy: function() {
            this._noanimationUnspiderfy();
        }
    } : {
        SVG_ANIMATION: function() {
            return document.createElementNS("http://www.w3.org/2000/svg", "animate").toString().indexOf("SVGAnimate") > -1;
        }(),
        _animationSpiderfy: function(childMarkers, positions) {
            var me = this, group = this._group, map = group._map, fg = group._featureGroup, thisLayerPos = map.latLngToLayerPoint(this._latlng), i, m, leg, newPos;
            for (i = childMarkers.length - 1; i >= 0; i--) {
                m = childMarkers[i];
                if (m.setOpacity) {
                    m.setZIndexOffset(1e6);
                    m.setOpacity(0);
                    fg.addLayer(m);
                    m._setPos(thisLayerPos);
                } else {
                    fg.addLayer(m);
                }
            }
            group._forceLayout();
            group._animationStart();
            var initialLegOpacity = L.Path.SVG ? 0 : .3, xmlns = L.Path.SVG_NS;
            for (i = childMarkers.length - 1; i >= 0; i--) {
                newPos = map.layerPointToLatLng(positions[i]);
                m = childMarkers[i];
                m._preSpiderfyLatlng = m._latlng;
                m.setLatLng(newPos);
                if (m.setOpacity) {
                    m.setOpacity(1);
                }
                leg = new L.Polyline([ me._latlng, newPos ], {
                    weight: 1.5,
                    color: "#222",
                    opacity: initialLegOpacity
                });
                map.addLayer(leg);
                m._spiderLeg = leg;
                if (!L.Path.SVG || !this.SVG_ANIMATION) {
                    continue;
                }
                var length = leg._path.getTotalLength();
                leg._path.setAttribute("stroke-dasharray", length + "," + length);
                var anim = document.createElementNS(xmlns, "animate");
                anim.setAttribute("attributeName", "stroke-dashoffset");
                anim.setAttribute("begin", "indefinite");
                anim.setAttribute("from", length);
                anim.setAttribute("to", 0);
                anim.setAttribute("dur", .25);
                leg._path.appendChild(anim);
                anim.beginElement();
                anim = document.createElementNS(xmlns, "animate");
                anim.setAttribute("attributeName", "stroke-opacity");
                anim.setAttribute("attributeName", "stroke-opacity");
                anim.setAttribute("begin", "indefinite");
                anim.setAttribute("from", 0);
                anim.setAttribute("to", .5);
                anim.setAttribute("dur", .25);
                leg._path.appendChild(anim);
                anim.beginElement();
            }
            me.setOpacity(.3);
            if (L.Path.SVG) {
                this._group._forceLayout();
                for (i = childMarkers.length - 1; i >= 0; i--) {
                    m = childMarkers[i]._spiderLeg;
                    m.options.opacity = .5;
                    m._path.setAttribute("stroke-opacity", .5);
                }
            }
            setTimeout(function() {
                group._animationEnd();
                group.fire("spiderfied");
            }, 200);
        },
        _animationUnspiderfy: function(zoomDetails) {
            var group = this._group, map = group._map, fg = group._featureGroup, thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng), childMarkers = this.getAllChildMarkers(), svg = L.Path.SVG && this.SVG_ANIMATION, m, i, a;
            group._animationStart();
            this.setOpacity(1);
            for (i = childMarkers.length - 1; i >= 0; i--) {
                m = childMarkers[i];
                if (!m._preSpiderfyLatlng) {
                    continue;
                }
                m.setLatLng(m._preSpiderfyLatlng);
                delete m._preSpiderfyLatlng;
                if (m.setOpacity) {
                    m._setPos(thisLayerPos);
                    m.setOpacity(0);
                } else {
                    fg.removeLayer(m);
                }
                if (svg) {
                    a = m._spiderLeg._path.childNodes[0];
                    a.setAttribute("to", a.getAttribute("from"));
                    a.setAttribute("from", 0);
                    a.beginElement();
                    a = m._spiderLeg._path.childNodes[1];
                    a.setAttribute("from", .5);
                    a.setAttribute("to", 0);
                    a.setAttribute("stroke-opacity", 0);
                    a.beginElement();
                    m._spiderLeg._path.setAttribute("stroke-opacity", 0);
                }
            }
            setTimeout(function() {
                var stillThereChildCount = 0;
                for (i = childMarkers.length - 1; i >= 0; i--) {
                    m = childMarkers[i];
                    if (m._spiderLeg) {
                        stillThereChildCount++;
                    }
                }
                for (i = childMarkers.length - 1; i >= 0; i--) {
                    m = childMarkers[i];
                    if (!m._spiderLeg) {
                        continue;
                    }
                    if (m.setOpacity) {
                        m.setOpacity(1);
                        m.setZIndexOffset(0);
                    }
                    if (stillThereChildCount > 1) {
                        fg.removeLayer(m);
                    }
                    map.removeLayer(m._spiderLeg);
                    delete m._spiderLeg;
                }
                group._animationEnd();
            }, 200);
        }
    });
    L.MarkerClusterGroup.include({
        _spiderfied: null,
        _spiderfierOnAdd: function() {
            this._map.on("click", this._unspiderfyWrapper, this);
            if (this._map.options.zoomAnimation) {
                this._map.on("zoomstart", this._unspiderfyZoomStart, this);
            }
            this._map.on("zoomend", this._noanimationUnspiderfy, this);
            if (L.Path.SVG && !L.Browser.touch) {
                this._map._initPathRoot();
            }
        },
        _spiderfierOnRemove: function() {
            this._map.off("click", this._unspiderfyWrapper, this);
            this._map.off("zoomstart", this._unspiderfyZoomStart, this);
            this._map.off("zoomanim", this._unspiderfyZoomAnim, this);
            this._unspiderfy();
        },
        _unspiderfyZoomStart: function() {
            if (!this._map) {
                return;
            }
            this._map.on("zoomanim", this._unspiderfyZoomAnim, this);
        },
        _unspiderfyZoomAnim: function(zoomDetails) {
            if (L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching")) {
                return;
            }
            this._map.off("zoomanim", this._unspiderfyZoomAnim, this);
            this._unspiderfy(zoomDetails);
        },
        _unspiderfyWrapper: function() {
            this._unspiderfy();
        },
        _unspiderfy: function(zoomDetails) {
            if (this._spiderfied) {
                this._spiderfied.unspiderfy(zoomDetails);
            }
        },
        _noanimationUnspiderfy: function() {
            if (this._spiderfied) {
                this._spiderfied._noanimationUnspiderfy();
            }
        },
        _unspiderfyLayer: function(layer) {
            if (layer._spiderLeg) {
                this._featureGroup.removeLayer(layer);
                layer.setOpacity(1);
                layer.setZIndexOffset(0);
                this._map.removeLayer(layer._spiderLeg);
                delete layer._spiderLeg;
            }
        }
    });
})(window, document);

(function() {
    L.Control.FullScreen = L.Control.extend({
        options: {
            position: "topleft",
            title: "Full Screen",
            forceSeparateButton: false,
            forcePseudoFullscreen: false
        },
        onAdd: function(map) {
            var className = "leaflet-control-zoom-fullscreen", container;
            if (map.zoomControl && !this.options.forceSeparateButton) {
                container = map.zoomControl._container;
            } else {
                container = L.DomUtil.create("div", "leaflet-bar");
            }
            this._createButton(this.options.title, className, container, this.toggleFullScreen, map);
            return container;
        },
        _createButton: function(title, className, container, fn, context) {
            var link = L.DomUtil.create("a", className, container);
            link.href = "#";
            link.title = title;
            L.DomEvent.addListener(link, "click", L.DomEvent.stopPropagation).addListener(link, "click", L.DomEvent.preventDefault).addListener(link, "click", fn, context);
            L.DomEvent.addListener(container, fullScreenApi.fullScreenEventName, L.DomEvent.stopPropagation).addListener(container, fullScreenApi.fullScreenEventName, L.DomEvent.preventDefault).addListener(container, fullScreenApi.fullScreenEventName, this._handleEscKey, context);
            L.DomEvent.addListener(document, fullScreenApi.fullScreenEventName, L.DomEvent.stopPropagation).addListener(document, fullScreenApi.fullScreenEventName, L.DomEvent.preventDefault).addListener(document, fullScreenApi.fullScreenEventName, this._handleEscKey, context);
            return link;
        },
        toggleFullScreen: function() {
            this._exitFired = false;
            var container = this._container;
            if (this._isFullscreen) {
                if (fullScreenApi.supportsFullScreen && !this.options.forcePseudoFullscreen) {
                    fullScreenApi.cancelFullScreen(container);
                } else {
                    L.DomUtil.removeClass(container, "leaflet-pseudo-fullscreen");
                }
                this.invalidateSize();
                this.fire("exitFullscreen");
                this._exitFired = true;
                this._isFullscreen = false;
            } else {
                if (fullScreenApi.supportsFullScreen && !this.options.forcePseudoFullscreen) {
                    fullScreenApi.requestFullScreen(container);
                } else {
                    L.DomUtil.addClass(container, "leaflet-pseudo-fullscreen");
                }
                this.invalidateSize();
                this.fire("enterFullscreen");
                this._isFullscreen = true;
            }
        },
        _handleEscKey: function() {
            if (!fullScreenApi.isFullScreen(this) && !this._exitFired) {
                this.fire("exitFullscreen");
                this._exitFired = true;
                this._isFullscreen = false;
            }
        }
    });
    L.Map.addInitHook(function() {
        if (this.options.fullscreenControl) {
            this.fullscreenControl = L.control.fullscreen(this.options.fullscreenControlOptions);
            this.addControl(this.fullscreenControl);
        }
    });
    L.control.fullscreen = function(options) {
        return new L.Control.FullScreen(options);
    };
    var fullScreenApi = {
        supportsFullScreen: false,
        isFullScreen: function() {
            return false;
        },
        requestFullScreen: function() {},
        cancelFullScreen: function() {},
        fullScreenEventName: "",
        prefix: ""
    }, browserPrefixes = "webkit moz o ms khtml".split(" ");
    if (typeof document.exitFullscreen !== "undefined") {
        fullScreenApi.supportsFullScreen = true;
    } else {
        for (var i = 0, il = browserPrefixes.length; i < il; i++) {
            fullScreenApi.prefix = browserPrefixes[i];
            if (typeof document[fullScreenApi.prefix + "CancelFullScreen"] !== "undefined") {
                fullScreenApi.supportsFullScreen = true;
                break;
            }
        }
    }
    if (fullScreenApi.supportsFullScreen) {
        fullScreenApi.fullScreenEventName = fullScreenApi.prefix + "fullscreenchange";
        fullScreenApi.isFullScreen = function() {
            switch (this.prefix) {
              case "":
                return document.fullScreen;

              case "webkit":
                return document.webkitIsFullScreen;

              default:
                return document[this.prefix + "FullScreen"];
            }
        };
        fullScreenApi.requestFullScreen = function(el) {
            return this.prefix === "" ? el.requestFullscreen() : el[this.prefix + "RequestFullScreen"]();
        };
        fullScreenApi.cancelFullScreen = function(el) {
            return this.prefix === "" ? document.exitFullscreen() : document[this.prefix + "CancelFullScreen"]();
        };
    }
    if (typeof jQuery !== "undefined") {
        jQuery.fn.requestFullScreen = function() {
            return this.each(function() {
                var el = jQuery(this);
                if (fullScreenApi.supportsFullScreen) {
                    fullScreenApi.requestFullScreen(el);
                }
            });
        };
    }
    window.fullScreenApi = fullScreenApi;
})();

(function(window, document, undefined) {
    var L = window.L;
    L.labelVersion = "0.2.2-dev";
    L.Label = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            className: "",
            clickable: false,
            direction: "right",
            noHide: false,
            offset: [ 12, -15 ],
            opacity: 1,
            zoomAnimation: true
        },
        initialize: function(options, source) {
            L.setOptions(this, options);
            this._source = source;
            this._animated = L.Browser.any3d && this.options.zoomAnimation;
            this._isOpen = false;
        },
        onAdd: function(map) {
            this._map = map;
            this._pane = this.options.pane ? map._panes[this.options.pane] : this._source instanceof L.Marker ? map._panes.markerPane : map._panes.popupPane;
            if (!this._container) {
                this._initLayout();
            }
            this._pane.appendChild(this._container);
            this._initInteraction();
            this._update();
            this.setOpacity(this.options.opacity);
            map.on("moveend", this._onMoveEnd, this).on("viewreset", this._onViewReset, this);
            if (this._animated) {
                map.on("zoomanim", this._zoomAnimation, this);
            }
            if (L.Browser.touch && !this.options.noHide) {
                L.DomEvent.on(this._container, "click", this.close, this);
                map.on("click", this.close, this);
            }
        },
        onRemove: function(map) {
            this._pane.removeChild(this._container);
            map.off({
                zoomanim: this._zoomAnimation,
                moveend: this._onMoveEnd,
                viewreset: this._onViewReset
            }, this);
            this._removeInteraction();
            this._map = null;
        },
        setLatLng: function(latlng) {
            this._latlng = L.latLng(latlng);
            if (this._map) {
                this._updatePosition();
            }
            return this;
        },
        setContent: function(content) {
            this._previousContent = this._content;
            this._content = content;
            this._updateContent();
            return this;
        },
        close: function() {
            var map = this._map;
            if (map) {
                if (L.Browser.touch && !this.options.noHide) {
                    L.DomEvent.off(this._container, "click", this.close);
                    map.off("click", this.close, this);
                }
                map.removeLayer(this);
            }
        },
        updateZIndex: function(zIndex) {
            this._zIndex = zIndex;
            if (this._container && this._zIndex) {
                this._container.style.zIndex = zIndex;
            }
        },
        setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._container) {
                L.DomUtil.setOpacity(this._container, opacity);
            }
        },
        _initLayout: function() {
            this._container = L.DomUtil.create("div", "leaflet-label " + this.options.className + " leaflet-zoom-animated");
            this.updateZIndex(this._zIndex);
        },
        _update: function() {
            if (!this._map) {
                return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updatePosition();
            this._container.style.visibility = "";
        },
        _updateContent: function() {
            if (!this._content || !this._map || this._prevContent === this._content) {
                return;
            }
            if (typeof this._content === "string") {
                this._container.innerHTML = this._content;
                this._prevContent = this._content;
                this._labelWidth = this._container.offsetWidth;
            }
        },
        _updatePosition: function() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
        },
        _setPosition: function(pos) {
            var map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), labelPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, labelWidth = this._labelWidth, offset = L.point(this.options.offset);
            if (direction === "right" || direction === "auto" && labelPoint.x < centerPoint.x) {
                L.DomUtil.addClass(container, "leaflet-label-right");
                L.DomUtil.removeClass(container, "leaflet-label-left");
                pos = pos.add(offset);
            } else {
                L.DomUtil.addClass(container, "leaflet-label-left");
                L.DomUtil.removeClass(container, "leaflet-label-right");
                pos = pos.add(L.point(-offset.x - labelWidth, offset.y));
            }
            L.DomUtil.setPosition(container, pos);
        },
        _zoomAnimation: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPosition(pos);
        },
        _onMoveEnd: function() {
            if (!this._animated || this.options.direction === "auto") {
                this._updatePosition();
            }
        },
        _onViewReset: function(e) {
            if (e && e.hard) {
                this._update();
            }
        },
        _initInteraction: function() {
            if (!this.options.clickable) {
                return;
            }
            var container = this._container, events = [ "dblclick", "mousedown", "mouseover", "mouseout", "contextmenu" ];
            L.DomUtil.addClass(container, "leaflet-clickable");
            L.DomEvent.on(container, "click", this._onMouseClick, this);
            for (var i = 0; i < events.length; i++) {
                L.DomEvent.on(container, events[i], this._fireMouseEvent, this);
            }
        },
        _removeInteraction: function() {
            if (!this.options.clickable) {
                return;
            }
            var container = this._container, events = [ "dblclick", "mousedown", "mouseover", "mouseout", "contextmenu" ];
            L.DomUtil.removeClass(container, "leaflet-clickable");
            L.DomEvent.off(container, "click", this._onMouseClick, this);
            for (var i = 0; i < events.length; i++) {
                L.DomEvent.off(container, events[i], this._fireMouseEvent, this);
            }
        },
        _onMouseClick: function(e) {
            if (this.hasEventListeners(e.type)) {
                L.DomEvent.stopPropagation(e);
            }
            this.fire(e.type, {
                originalEvent: e
            });
        },
        _fireMouseEvent: function(e) {
            this.fire(e.type, {
                originalEvent: e
            });
            if (e.type === "contextmenu" && this.hasEventListeners(e.type)) {
                L.DomEvent.preventDefault(e);
            }
            if (e.type !== "mousedown") {
                L.DomEvent.stopPropagation(e);
            } else {
                L.DomEvent.preventDefault(e);
            }
        }
    });
    L.BaseMarkerMethods = {
        showLabel: function() {
            if (this.label && this._map) {
                this.label.setLatLng(this._latlng);
                this._map.showLabel(this.label);
            }
            return this;
        },
        hideLabel: function() {
            if (this.label) {
                this.label.close();
            }
            return this;
        },
        setLabelNoHide: function(noHide) {
            if (this._labelNoHide === noHide) {
                return;
            }
            this._labelNoHide = noHide;
            if (noHide) {
                this._removeLabelRevealHandlers();
                this.showLabel();
            } else {
                this._addLabelRevealHandlers();
                this.hideLabel();
            }
        },
        bindLabel: function(content, options) {
            var labelAnchor = this.options.icon ? this.options.icon.options.labelAnchor : this.options.labelAnchor, anchor = L.point(labelAnchor) || L.point(0, 0);
            anchor = anchor.add(L.Label.prototype.options.offset);
            if (options && options.offset) {
                anchor = anchor.add(options.offset);
            }
            options = L.Util.extend({
                offset: anchor
            }, options);
            this._labelNoHide = options.noHide;
            if (!this.label) {
                if (!this._labelNoHide) {
                    this._addLabelRevealHandlers();
                }
                this.on("remove", this.hideLabel, this).on("move", this._moveLabel, this).on("add", this._onMarkerAdd, this);
                this._hasLabelHandlers = true;
            }
            this.label = new L.Label(options, this).setContent(content);
            return this;
        },
        unbindLabel: function() {
            if (this.label) {
                this.hideLabel();
                this.label = null;
                if (this._hasLabelHandlers) {
                    if (!this._labelNoHide) {
                        this._removeLabelRevealHandlers();
                    }
                    this.off("remove", this.hideLabel, this).off("move", this._moveLabel, this).off("add", this._onMarkerAdd, this);
                }
                this._hasLabelHandlers = false;
            }
            return this;
        },
        updateLabelContent: function(content) {
            if (this.label) {
                this.label.setContent(content);
            }
        },
        getLabel: function() {
            return this.label;
        },
        _onMarkerAdd: function() {
            if (this._labelNoHide) {
                this.showLabel();
            }
        },
        _addLabelRevealHandlers: function() {
            this.on("mouseover", this.showLabel, this).on("mouseout", this.hideLabel, this);
            if (L.Browser.touch) {
                this.on("click", this.showLabel, this);
            }
        },
        _removeLabelRevealHandlers: function() {
            this.off("mouseover", this.showLabel, this).off("mouseout", this.hideLabel, this);
            if (L.Browser.touch) {
                this.off("click", this.showLabel, this);
            }
        },
        _moveLabel: function(e) {
            this.label.setLatLng(e.latlng);
        }
    };
    L.Icon.Default.mergeOptions({
        labelAnchor: new L.Point(9, -20)
    });
    L.Marker.mergeOptions({
        icon: new L.Icon.Default()
    });
    L.Marker.include(L.BaseMarkerMethods);
    L.Marker.include({
        _originalUpdateZIndex: L.Marker.prototype._updateZIndex,
        _updateZIndex: function(offset) {
            var zIndex = this._zIndex + offset;
            this._originalUpdateZIndex(offset);
            if (this.label) {
                this.label.updateZIndex(zIndex);
            }
        },
        _originalSetOpacity: L.Marker.prototype.setOpacity,
        setOpacity: function(opacity, labelHasSemiTransparency) {
            this.options.labelHasSemiTransparency = labelHasSemiTransparency;
            this._originalSetOpacity(opacity);
        },
        _originalUpdateOpacity: L.Marker.prototype._updateOpacity,
        _updateOpacity: function() {
            var absoluteOpacity = this.options.opacity === 0 ? 0 : 1;
            this._originalUpdateOpacity();
            if (this.label) {
                this.label.setOpacity(this.options.labelHasSemiTransparency ? this.options.opacity : absoluteOpacity);
            }
        },
        _originalSetLatLng: L.Marker.prototype.setLatLng,
        setLatLng: function(latlng) {
            if (this.label && !this._labelNoHide) {
                this.hideLabel();
            }
            return this._originalSetLatLng(latlng);
        }
    });
    L.CircleMarker.mergeOptions({
        labelAnchor: new L.Point(0, 0)
    });
    L.CircleMarker.include(L.BaseMarkerMethods);
    L.Path.include({
        bindLabel: function(content, options) {
            if (!this.label || this.label.options !== options) {
                this.label = new L.Label(options, this);
            }
            this.label.setContent(content);
            if (!this._showLabelAdded) {
                this.on("mouseover", this._showLabel, this).on("mousemove", this._moveLabel, this).on("mouseout remove", this._hideLabel, this);
                if (L.Browser.touch) {
                    this.on("click", this._showLabel, this);
                }
                this._showLabelAdded = true;
            }
            return this;
        },
        unbindLabel: function() {
            if (this.label) {
                this._hideLabel();
                this.label = null;
                this._showLabelAdded = false;
                this.off("mouseover", this._showLabel, this).off("mousemove", this._moveLabel, this).off("mouseout remove", this._hideLabel, this);
            }
            return this;
        },
        updateLabelContent: function(content) {
            if (this.label) {
                this.label.setContent(content);
            }
        },
        _showLabel: function(e) {
            this.label.setLatLng(e.latlng);
            this._map.showLabel(this.label);
        },
        _moveLabel: function(e) {
            this.label.setLatLng(e.latlng);
        },
        _hideLabel: function() {
            this.label.close();
        }
    });
    L.Map.include({
        showLabel: function(label) {
            return this.addLayer(label);
        }
    });
    L.FeatureGroup.include({
        clearLayers: function() {
            this.unbindLabel();
            this.eachLayer(this.removeLayer, this);
            return this;
        },
        bindLabel: function(content, options) {
            return this.invoke("bindLabel", content, options);
        },
        unbindLabel: function() {
            return this.invoke("unbindLabel");
        },
        updateLabelContent: function(content) {
            this.invoke("updateLabelContent", content);
        }
    });
})(this, document);

(function(window, document, undefined) {
    L.drawVersion = "0.2.4-dev";
    L.drawLocal = {
        draw: {
            toolbar: {
                actions: {
                    title: "Cancel drawing",
                    text: "Cancel"
                },
                undo: {
                    title: "Delete last point drawn",
                    text: "Delete last point"
                },
                buttons: {
                    polyline: "Draw a polyline",
                    polygon: "Draw a polygon",
                    rectangle: "Draw a rectangle",
                    circle: "Draw a circle",
                    marker: "Draw a marker"
                }
            },
            handlers: {
                circle: {
                    tooltip: {
                        start: "Click and drag to draw circle."
                    }
                },
                marker: {
                    tooltip: {
                        start: "Click map to place marker."
                    }
                },
                polygon: {
                    tooltip: {
                        start: "Click to start drawing shape.",
                        cont: "Click to continue drawing shape.",
                        end: "Click first point to close this shape."
                    }
                },
                polyline: {
                    error: "<strong>Error:</strong> shape edges cannot cross!",
                    tooltip: {
                        start: "Click to start drawing line.",
                        cont: "Click to continue drawing line.",
                        end: "Click last point to finish line."
                    }
                },
                rectangle: {
                    tooltip: {
                        start: "Click and drag to draw rectangle."
                    }
                },
                simpleshape: {
                    tooltip: {
                        end: "Release mouse to finish drawing."
                    }
                }
            }
        },
        edit: {
            toolbar: {
                actions: {
                    save: {
                        title: "Save changes.",
                        text: "Save"
                    },
                    cancel: {
                        title: "Cancel editing, discards all changes.",
                        text: "Cancel"
                    }
                },
                buttons: {
                    edit: "Edit layers.",
                    editDisabled: "No layers to edit.",
                    remove: "Delete layers.",
                    removeDisabled: "No layers to delete."
                }
            },
            handlers: {
                edit: {
                    tooltip: {
                        text: "Drag handles, or marker to edit feature.",
                        subtext: "Click cancel to undo changes."
                    }
                },
                remove: {
                    tooltip: {
                        text: "Click on a feature to remove"
                    }
                }
            }
        }
    };
    L.Draw = {};
    L.Draw.Feature = L.Handler.extend({
        includes: L.Mixin.Events,
        initialize: function(map, options) {
            this._map = map;
            this._container = map._container;
            this._overlayPane = map._panes.overlayPane;
            this._popupPane = map._panes.popupPane;
            if (options && options.shapeOptions) {
                options.shapeOptions = L.Util.extend({}, this.options.shapeOptions, options.shapeOptions);
            }
            L.setOptions(this, options);
        },
        enable: function() {
            if (this._enabled) {
                return;
            }
            L.Handler.prototype.enable.call(this);
            this.fire("enabled", {
                handler: this.type
            });
            this._map.fire("draw:drawstart", {
                layerType: this.type
            });
        },
        disable: function() {
            if (!this._enabled) {
                return;
            }
            L.Handler.prototype.disable.call(this);
            this._map.fire("draw:drawstop", {
                layerType: this.type
            });
            this.fire("disabled", {
                handler: this.type
            });
        },
        addHooks: function() {
            var map = this._map;
            if (map) {
                L.DomUtil.disableTextSelection();
                map.getContainer().focus();
                this._tooltip = new L.Tooltip(this._map);
                L.DomEvent.on(this._container, "keyup", this._cancelDrawing, this);
            }
        },
        removeHooks: function() {
            if (this._map) {
                L.DomUtil.enableTextSelection();
                this._tooltip.dispose();
                this._tooltip = null;
                L.DomEvent.off(this._container, "keyup", this._cancelDrawing, this);
            }
        },
        setOptions: function(options) {
            L.setOptions(this, options);
        },
        _fireCreatedEvent: function(layer) {
            this._map.fire("draw:created", {
                layer: layer,
                layerType: this.type
            });
        },
        _cancelDrawing: function(e) {
            if (e.keyCode === 27) {
                this.disable();
            }
        }
    });
    L.Draw.Polyline = L.Draw.Feature.extend({
        statics: {
            TYPE: "polyline"
        },
        Poly: L.Polyline,
        options: {
            allowIntersection: true,
            repeatMode: false,
            drawError: {
                color: "#b00b00",
                timeout: 2500
            },
            icon: new L.DivIcon({
                iconSize: new L.Point(8, 8),
                className: "leaflet-div-icon leaflet-editing-icon"
            }),
            guidelineDistance: 20,
            maxGuideLineLength: 4e3,
            shapeOptions: {
                stroke: true,
                color: "#f06eaa",
                weight: 4,
                opacity: .5,
                fill: false,
                clickable: true
            },
            metric: true,
            showLength: true,
            zIndexOffset: 2e3
        },
        initialize: function(map, options) {
            this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;
            if (options && options.drawError) {
                options.drawError = L.Util.extend({}, this.options.drawError, options.drawError);
            }
            this.type = L.Draw.Polyline.TYPE;
            L.Draw.Feature.prototype.initialize.call(this, map, options);
        },
        addHooks: function() {
            L.Draw.Feature.prototype.addHooks.call(this);
            if (this._map) {
                this._markers = [];
                this._markerGroup = new L.LayerGroup();
                this._map.addLayer(this._markerGroup);
                this._poly = new L.Polyline([], this.options.shapeOptions);
                this._tooltip.updateContent(this._getTooltipText());
                if (!this._mouseMarker) {
                    this._mouseMarker = L.marker(this._map.getCenter(), {
                        icon: L.divIcon({
                            className: "leaflet-mouse-marker",
                            iconAnchor: [ 20, 20 ],
                            iconSize: [ 40, 40 ]
                        }),
                        opacity: 0,
                        zIndexOffset: this.options.zIndexOffset
                    });
                }
                this._mouseMarker.on("mousedown", this._onMouseDown, this).addTo(this._map);
                this._map.on("mousemove", this._onMouseMove, this).on("mouseup", this._onMouseUp, this).on("zoomend", this._onZoomEnd, this);
            }
        },
        removeHooks: function() {
            L.Draw.Feature.prototype.removeHooks.call(this);
            this._clearHideErrorTimeout();
            this._cleanUpShape();
            this._map.removeLayer(this._markerGroup);
            delete this._markerGroup;
            delete this._markers;
            this._map.removeLayer(this._poly);
            delete this._poly;
            this._mouseMarker.off("mousedown", this._onMouseDown, this).off("mouseup", this._onMouseUp, this);
            this._map.removeLayer(this._mouseMarker);
            delete this._mouseMarker;
            this._clearGuides();
            this._map.off("mousemove", this._onMouseMove, this).off("zoomend", this._onZoomEnd, this);
        },
        deleteLastVertex: function() {
            if (this._markers.length <= 1) {
                return;
            }
            var lastMarker = this._markers.pop(), poly = this._poly, latlng = this._poly.spliceLatLngs(poly.getLatLngs().length - 1, 1)[0];
            this._markerGroup.removeLayer(lastMarker);
            if (poly.getLatLngs().length < 2) {
                this._map.removeLayer(poly);
            }
            this._vertexChanged(latlng, false);
        },
        addVertex: function(latlng) {
            var markersLength = this._markers.length;
            if (markersLength > 0 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {
                this._showErrorTooltip();
                return;
            } else if (this._errorShown) {
                this._hideErrorTooltip();
            }
            this._markers.push(this._createMarker(latlng));
            this._poly.addLatLng(latlng);
            if (this._poly.getLatLngs().length === 2) {
                this._map.addLayer(this._poly);
            }
            this._vertexChanged(latlng, true);
        },
        _finishShape: function() {
            var intersects = this._poly.newLatLngIntersects(this._poly.getLatLngs()[0], true);
            if (!this.options.allowIntersection && intersects || !this._shapeIsValid()) {
                this._showErrorTooltip();
                return;
            }
            this._fireCreatedEvent();
            this.disable();
            if (this.options.repeatMode) {
                this.enable();
            }
        },
        _shapeIsValid: function() {
            return true;
        },
        _onZoomEnd: function() {
            this._updateGuide();
        },
        _onMouseMove: function(e) {
            var newPos = e.layerPoint, latlng = e.latlng;
            this._currentLatLng = latlng;
            this._updateTooltip(latlng);
            this._updateGuide(newPos);
            this._mouseMarker.setLatLng(latlng);
            L.DomEvent.preventDefault(e.originalEvent);
        },
        _vertexChanged: function(latlng, added) {
            this._updateFinishHandler();
            this._updateRunningMeasure(latlng, added);
            this._clearGuides();
            this._updateTooltip();
        },
        _onMouseDown: function(e) {
            var originalEvent = e.originalEvent;
            this._mouseDownOrigin = L.point(originalEvent.clientX, originalEvent.clientY);
        },
        _onMouseUp: function(e) {
            if (this._mouseDownOrigin) {
                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(this._mouseDownOrigin);
                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) {
                    this.addVertex(e.latlng);
                }
            }
            this._mouseDownOrigin = null;
        },
        _updateFinishHandler: function() {
            var markerCount = this._markers.length;
            if (markerCount > 1) {
                this._markers[markerCount - 1].on("click", this._finishShape, this);
            }
            if (markerCount > 2) {
                this._markers[markerCount - 2].off("click", this._finishShape, this);
            }
        },
        _createMarker: function(latlng) {
            var marker = new L.Marker(latlng, {
                icon: this.options.icon,
                zIndexOffset: this.options.zIndexOffset * 2
            });
            this._markerGroup.addLayer(marker);
            return marker;
        },
        _updateGuide: function(newPos) {
            var markerCount = this._markers.length;
            if (markerCount > 0) {
                newPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng);
                this._clearGuides();
                this._drawGuide(this._map.latLngToLayerPoint(this._markers[markerCount - 1].getLatLng()), newPos);
            }
        },
        _updateTooltip: function(latLng) {
            var text = this._getTooltipText();
            if (latLng) {
                this._tooltip.updatePosition(latLng);
            }
            if (!this._errorShown) {
                this._tooltip.updateContent(text);
            }
        },
        _drawGuide: function(pointA, pointB) {
            var length = Math.floor(Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2))), guidelineDistance = this.options.guidelineDistance, maxGuideLineLength = this.options.maxGuideLineLength, i = length > maxGuideLineLength ? length - maxGuideLineLength : guidelineDistance, fraction, dashPoint, dash;
            if (!this._guidesContainer) {
                this._guidesContainer = L.DomUtil.create("div", "leaflet-draw-guides", this._overlayPane);
            }
            for (;i < length; i += this.options.guidelineDistance) {
                fraction = i / length;
                dashPoint = {
                    x: Math.floor(pointA.x * (1 - fraction) + fraction * pointB.x),
                    y: Math.floor(pointA.y * (1 - fraction) + fraction * pointB.y)
                };
                dash = L.DomUtil.create("div", "leaflet-draw-guide-dash", this._guidesContainer);
                dash.style.backgroundColor = !this._errorShown ? this.options.shapeOptions.color : this.options.drawError.color;
                L.DomUtil.setPosition(dash, dashPoint);
            }
        },
        _updateGuideColor: function(color) {
            if (this._guidesContainer) {
                for (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {
                    this._guidesContainer.childNodes[i].style.backgroundColor = color;
                }
            }
        },
        _clearGuides: function() {
            if (this._guidesContainer) {
                while (this._guidesContainer.firstChild) {
                    this._guidesContainer.removeChild(this._guidesContainer.firstChild);
                }
            }
        },
        _getTooltipText: function() {
            var showLength = this.options.showLength, labelText, distanceStr;
            if (this._markers.length === 0) {
                labelText = {
                    text: L.drawLocal.draw.handlers.polyline.tooltip.start
                };
            } else {
                distanceStr = showLength ? this._getMeasurementString() : "";
                if (this._markers.length === 1) {
                    labelText = {
                        text: L.drawLocal.draw.handlers.polyline.tooltip.cont,
                        subtext: distanceStr
                    };
                } else {
                    labelText = {
                        text: L.drawLocal.draw.handlers.polyline.tooltip.end,
                        subtext: distanceStr
                    };
                }
            }
            return labelText;
        },
        _updateRunningMeasure: function(latlng, added) {
            var markersLength = this._markers.length, previousMarkerIndex, distance;
            if (this._markers.length === 1) {
                this._measurementRunningTotal = 0;
            } else {
                previousMarkerIndex = markersLength - (added ? 2 : 1);
                distance = latlng.distanceTo(this._markers[previousMarkerIndex].getLatLng());
                this._measurementRunningTotal += distance * (added ? 1 : -1);
            }
        },
        _getMeasurementString: function() {
            var currentLatLng = this._currentLatLng, previousLatLng = this._markers[this._markers.length - 1].getLatLng(), distance;
            distance = this._measurementRunningTotal + currentLatLng.distanceTo(previousLatLng);
            return L.GeometryUtil.readableDistance(distance, this.options.metric);
        },
        _showErrorTooltip: function() {
            this._errorShown = true;
            this._tooltip.showAsError().updateContent({
                text: this.options.drawError.message
            });
            this._updateGuideColor(this.options.drawError.color);
            this._poly.setStyle({
                color: this.options.drawError.color
            });
            this._clearHideErrorTimeout();
            this._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);
        },
        _hideErrorTooltip: function() {
            this._errorShown = false;
            this._clearHideErrorTimeout();
            this._tooltip.removeError().updateContent(this._getTooltipText());
            this._updateGuideColor(this.options.shapeOptions.color);
            this._poly.setStyle({
                color: this.options.shapeOptions.color
            });
        },
        _clearHideErrorTimeout: function() {
            if (this._hideErrorTimeout) {
                clearTimeout(this._hideErrorTimeout);
                this._hideErrorTimeout = null;
            }
        },
        _cleanUpShape: function() {
            if (this._markers.length > 1) {
                this._markers[this._markers.length - 1].off("click", this._finishShape, this);
            }
        },
        _fireCreatedEvent: function() {
            var poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);
            L.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);
        }
    });
    L.Draw.Polygon = L.Draw.Polyline.extend({
        statics: {
            TYPE: "polygon"
        },
        Poly: L.Polygon,
        options: {
            showArea: false,
            shapeOptions: {
                stroke: true,
                color: "#f06eaa",
                weight: 4,
                opacity: .5,
                fill: true,
                fillColor: null,
                fillOpacity: .2,
                clickable: true
            }
        },
        initialize: function(map, options) {
            L.Draw.Polyline.prototype.initialize.call(this, map, options);
            this.type = L.Draw.Polygon.TYPE;
        },
        _updateFinishHandler: function() {
            var markerCount = this._markers.length;
            if (markerCount === 1) {
                this._markers[0].on("click", this._finishShape, this);
            }
            if (markerCount > 2) {
                this._markers[markerCount - 1].on("dblclick", this._finishShape, this);
                if (markerCount > 3) {
                    this._markers[markerCount - 2].off("dblclick", this._finishShape, this);
                }
            }
        },
        _getTooltipText: function() {
            var text, subtext;
            if (this._markers.length === 0) {
                text = L.drawLocal.draw.handlers.polygon.tooltip.start;
            } else if (this._markers.length < 3) {
                text = L.drawLocal.draw.handlers.polygon.tooltip.cont;
            } else {
                text = L.drawLocal.draw.handlers.polygon.tooltip.end;
                subtext = this._getMeasurementString();
            }
            return {
                text: text,
                subtext: subtext
            };
        },
        _getMeasurementString: function() {
            var area = this._area;
            if (!area) {
                return null;
            }
            return L.GeometryUtil.readableArea(area, this.options.metric);
        },
        _shapeIsValid: function() {
            return this._markers.length >= 3;
        },
        _vertexChanged: function(latlng, added) {
            var latLngs;
            if (!this.options.allowIntersection && this.options.showArea) {
                latLngs = this._poly.getLatLngs();
                this._area = L.GeometryUtil.geodesicArea(latLngs);
            }
            L.Draw.Polyline.prototype._vertexChanged.call(this, latlng, added);
        },
        _cleanUpShape: function() {
            var markerCount = this._markers.length;
            if (markerCount > 0) {
                this._markers[0].off("click", this._finishShape, this);
                if (markerCount > 2) {
                    this._markers[markerCount - 1].off("dblclick", this._finishShape, this);
                }
            }
        }
    });
    L.SimpleShape = {};
    L.Draw.SimpleShape = L.Draw.Feature.extend({
        options: {
            repeatMode: false
        },
        initialize: function(map, options) {
            this._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end;
            L.Draw.Feature.prototype.initialize.call(this, map, options);
        },
        addHooks: function() {
            L.Draw.Feature.prototype.addHooks.call(this);
            if (this._map) {
                this._mapDraggable = this._map.dragging.enabled();
                if (this._mapDraggable) {
                    this._map.dragging.disable();
                }
                this._container.style.cursor = "crosshair";
                this._tooltip.updateContent({
                    text: this._initialLabelText
                });
                this._map.on("mousedown", this._onMouseDown, this).on("mousemove", this._onMouseMove, this);
            }
        },
        removeHooks: function() {
            L.Draw.Feature.prototype.removeHooks.call(this);
            if (this._map) {
                if (this._mapDraggable) {
                    this._map.dragging.enable();
                }
                this._container.style.cursor = "";
                this._map.off("mousedown", this._onMouseDown, this).off("mousemove", this._onMouseMove, this);
                L.DomEvent.off(document, "mouseup", this._onMouseUp, this);
                if (this._shape) {
                    this._map.removeLayer(this._shape);
                    delete this._shape;
                }
            }
            this._isDrawing = false;
        },
        _onMouseDown: function(e) {
            this._isDrawing = true;
            this._startLatLng = e.latlng;
            L.DomEvent.on(document, "mouseup", this._onMouseUp, this).preventDefault(e.originalEvent);
        },
        _onMouseMove: function(e) {
            var latlng = e.latlng;
            this._tooltip.updatePosition(latlng);
            if (this._isDrawing) {
                this._tooltip.updateContent({
                    text: this._endLabelText
                });
                this._drawShape(latlng);
            }
        },
        _onMouseUp: function() {
            if (this._shape) {
                this._fireCreatedEvent();
            }
            this.disable();
            if (this.options.repeatMode) {
                this.enable();
            }
        }
    });
    L.Draw.Rectangle = L.Draw.SimpleShape.extend({
        statics: {
            TYPE: "rectangle"
        },
        options: {
            shapeOptions: {
                stroke: true,
                color: "#f06eaa",
                weight: 4,
                opacity: .5,
                fill: true,
                fillColor: null,
                fillOpacity: .2,
                clickable: true
            }
        },
        initialize: function(map, options) {
            this.type = L.Draw.Rectangle.TYPE;
            this._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start;
            L.Draw.SimpleShape.prototype.initialize.call(this, map, options);
        },
        _drawShape: function(latlng) {
            if (!this._shape) {
                this._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, latlng), this.options.shapeOptions);
                this._map.addLayer(this._shape);
            } else {
                this._shape.setBounds(new L.LatLngBounds(this._startLatLng, latlng));
            }
        },
        _fireCreatedEvent: function() {
            var rectangle = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);
            L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, rectangle);
        }
    });
    L.Draw.Circle = L.Draw.SimpleShape.extend({
        statics: {
            TYPE: "circle"
        },
        options: {
            shapeOptions: {
                stroke: true,
                color: "#f06eaa",
                weight: 4,
                opacity: .5,
                fill: true,
                fillColor: null,
                fillOpacity: .2,
                clickable: true
            },
            showRadius: true,
            metric: true
        },
        initialize: function(map, options) {
            this.type = L.Draw.Circle.TYPE;
            this._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start;
            L.Draw.SimpleShape.prototype.initialize.call(this, map, options);
        },
        _drawShape: function(latlng) {
            if (!this._shape) {
                this._shape = new L.Circle(this._startLatLng, this._startLatLng.distanceTo(latlng), this.options.shapeOptions);
                this._map.addLayer(this._shape);
            } else {
                this._shape.setRadius(this._startLatLng.distanceTo(latlng));
            }
        },
        _fireCreatedEvent: function() {
            var circle = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);
            L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);
        },
        _onMouseMove: function(e) {
            var latlng = e.latlng, showRadius = this.options.showRadius, useMetric = this.options.metric, radius;
            this._tooltip.updatePosition(latlng);
            if (this._isDrawing) {
                this._drawShape(latlng);
                radius = this._shape.getRadius().toFixed(1);
                this._tooltip.updateContent({
                    text: this._endLabelText,
                    subtext: showRadius ? "Radius: " + L.GeometryUtil.readableDistance(radius, useMetric) : ""
                });
            }
        }
    });
    L.Draw.Marker = L.Draw.Feature.extend({
        statics: {
            TYPE: "marker"
        },
        options: {
            icon: new L.Icon.Default(),
            repeatMode: false,
            zIndexOffset: 2e3
        },
        initialize: function(map, options) {
            this.type = L.Draw.Marker.TYPE;
            L.Draw.Feature.prototype.initialize.call(this, map, options);
        },
        addHooks: function() {
            L.Draw.Feature.prototype.addHooks.call(this);
            if (this._map) {
                this._tooltip.updateContent({
                    text: L.drawLocal.draw.handlers.marker.tooltip.start
                });
                if (!this._mouseMarker) {
                    this._mouseMarker = L.marker(this._map.getCenter(), {
                        icon: L.divIcon({
                            className: "leaflet-mouse-marker",
                            iconAnchor: [ 20, 20 ],
                            iconSize: [ 40, 40 ]
                        }),
                        opacity: 0,
                        zIndexOffset: this.options.zIndexOffset
                    });
                }
                this._mouseMarker.on("click", this._onClick, this).addTo(this._map);
                this._map.on("mousemove", this._onMouseMove, this);
            }
        },
        removeHooks: function() {
            L.Draw.Feature.prototype.removeHooks.call(this);
            if (this._map) {
                if (this._marker) {
                    this._marker.off("click", this._onClick, this);
                    this._map.off("click", this._onClick, this).removeLayer(this._marker);
                    delete this._marker;
                }
                this._mouseMarker.off("click", this._onClick, this);
                this._map.removeLayer(this._mouseMarker);
                delete this._mouseMarker;
                this._map.off("mousemove", this._onMouseMove, this);
            }
        },
        _onMouseMove: function(e) {
            var latlng = e.latlng;
            this._tooltip.updatePosition(latlng);
            this._mouseMarker.setLatLng(latlng);
            if (!this._marker) {
                this._marker = new L.Marker(latlng, {
                    icon: this.options.icon,
                    zIndexOffset: this.options.zIndexOffset
                });
                this._marker.on("click", this._onClick, this);
                this._map.on("click", this._onClick, this).addLayer(this._marker);
            } else {
                latlng = this._mouseMarker.getLatLng();
                this._marker.setLatLng(latlng);
            }
        },
        _onClick: function() {
            this._fireCreatedEvent();
            this.disable();
            if (this.options.repeatMode) {
                this.enable();
            }
        },
        _fireCreatedEvent: function() {
            var marker = new L.Marker(this._marker.getLatLng(), {
                icon: this.options.icon
            });
            L.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);
        }
    });
    L.Edit = L.Edit || {};
    L.Edit.Poly = L.Handler.extend({
        options: {
            icon: new L.DivIcon({
                iconSize: new L.Point(8, 8),
                className: "leaflet-div-icon leaflet-editing-icon"
            })
        },
        initialize: function(poly, options) {
            this._poly = poly;
            L.setOptions(this, options);
        },
        addHooks: function() {
            if (this._poly._map) {
                if (!this._markerGroup) {
                    this._initMarkers();
                }
                this._poly._map.addLayer(this._markerGroup);
            }
        },
        removeHooks: function() {
            if (this._poly._map) {
                this._poly._map.removeLayer(this._markerGroup);
                delete this._markerGroup;
                delete this._markers;
            }
        },
        updateMarkers: function() {
            this._markerGroup.clearLayers();
            this._initMarkers();
        },
        _initMarkers: function() {
            if (!this._markerGroup) {
                this._markerGroup = new L.LayerGroup();
            }
            this._markers = [];
            var latlngs = this._poly._latlngs, i, j, len, marker;
            for (i = 0, len = latlngs.length; i < len; i++) {
                marker = this._createMarker(latlngs[i], i);
                marker.on("click", this._onMarkerClick, this);
                this._markers.push(marker);
            }
            var markerLeft, markerRight;
            for (i = 0, j = len - 1; i < len; j = i++) {
                if (i === 0 && !(L.Polygon && this._poly instanceof L.Polygon)) {
                    continue;
                }
                markerLeft = this._markers[j];
                markerRight = this._markers[i];
                this._createMiddleMarker(markerLeft, markerRight);
                this._updatePrevNext(markerLeft, markerRight);
            }
        },
        _createMarker: function(latlng, index) {
            var marker = new L.Marker(latlng, {
                draggable: true,
                icon: this.options.icon
            });
            marker._origLatLng = latlng;
            marker._index = index;
            marker.on("drag", this._onMarkerDrag, this);
            marker.on("dragend", this._fireEdit, this);
            this._markerGroup.addLayer(marker);
            return marker;
        },
        _removeMarker: function(marker) {
            var i = marker._index;
            this._markerGroup.removeLayer(marker);
            this._markers.splice(i, 1);
            this._poly.spliceLatLngs(i, 1);
            this._updateIndexes(i, -1);
            marker.off("drag", this._onMarkerDrag, this).off("dragend", this._fireEdit, this).off("click", this._onMarkerClick, this);
        },
        _fireEdit: function() {
            this._poly.edited = true;
            this._poly.fire("edit");
        },
        _onMarkerDrag: function(e) {
            var marker = e.target;
            L.extend(marker._origLatLng, marker._latlng);
            if (marker._middleLeft) {
                marker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));
            }
            if (marker._middleRight) {
                marker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));
            }
            this._poly.redraw();
        },
        _onMarkerClick: function(e) {
            var minPoints = L.Polygon && this._poly instanceof L.Polygon ? 4 : 3, marker = e.target;
            if (this._poly._latlngs.length < minPoints) {
                return;
            }
            this._removeMarker(marker);
            this._updatePrevNext(marker._prev, marker._next);
            if (marker._middleLeft) {
                this._markerGroup.removeLayer(marker._middleLeft);
            }
            if (marker._middleRight) {
                this._markerGroup.removeLayer(marker._middleRight);
            }
            if (marker._prev && marker._next) {
                this._createMiddleMarker(marker._prev, marker._next);
            } else if (!marker._prev) {
                marker._next._middleLeft = null;
            } else if (!marker._next) {
                marker._prev._middleRight = null;
            }
            this._fireEdit();
        },
        _updateIndexes: function(index, delta) {
            this._markerGroup.eachLayer(function(marker) {
                if (marker._index > index) {
                    marker._index += delta;
                }
            });
        },
        _createMiddleMarker: function(marker1, marker2) {
            var latlng = this._getMiddleLatLng(marker1, marker2), marker = this._createMarker(latlng), onClick, onDragStart, onDragEnd;
            marker.setOpacity(.6);
            marker1._middleRight = marker2._middleLeft = marker;
            onDragStart = function() {
                var i = marker2._index;
                marker._index = i;
                marker.off("click", onClick, this).on("click", this._onMarkerClick, this);
                latlng.lat = marker.getLatLng().lat;
                latlng.lng = marker.getLatLng().lng;
                this._poly.spliceLatLngs(i, 0, latlng);
                this._markers.splice(i, 0, marker);
                marker.setOpacity(1);
                this._updateIndexes(i, 1);
                marker2._index++;
                this._updatePrevNext(marker1, marker);
                this._updatePrevNext(marker, marker2);
                this._poly.fire("editstart");
            };
            onDragEnd = function() {
                marker.off("dragstart", onDragStart, this);
                marker.off("dragend", onDragEnd, this);
                this._createMiddleMarker(marker1, marker);
                this._createMiddleMarker(marker, marker2);
            };
            onClick = function() {
                onDragStart.call(this);
                onDragEnd.call(this);
                this._fireEdit();
            };
            marker.on("click", onClick, this).on("dragstart", onDragStart, this).on("dragend", onDragEnd, this);
            this._markerGroup.addLayer(marker);
        },
        _updatePrevNext: function(marker1, marker2) {
            if (marker1) {
                marker1._next = marker2;
            }
            if (marker2) {
                marker2._prev = marker1;
            }
        },
        _getMiddleLatLng: function(marker1, marker2) {
            var map = this._poly._map, p1 = map.project(marker1.getLatLng()), p2 = map.project(marker2.getLatLng());
            return map.unproject(p1._add(p2)._divideBy(2));
        }
    });
    L.Polyline.addInitHook(function() {
        if (this.editing) {
            return;
        }
        if (L.Edit.Poly) {
            this.editing = new L.Edit.Poly(this);
            if (this.options.editable) {
                this.editing.enable();
            }
        }
        this.on("add", function() {
            if (this.editing && this.editing.enabled()) {
                this.editing.addHooks();
            }
        });
        this.on("remove", function() {
            if (this.editing && this.editing.enabled()) {
                this.editing.removeHooks();
            }
        });
    });
    L.Edit = L.Edit || {};
    L.Edit.SimpleShape = L.Handler.extend({
        options: {
            moveIcon: new L.DivIcon({
                iconSize: new L.Point(8, 8),
                className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-move"
            }),
            resizeIcon: new L.DivIcon({
                iconSize: new L.Point(8, 8),
                className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-resize"
            })
        },
        initialize: function(shape, options) {
            this._shape = shape;
            L.Util.setOptions(this, options);
        },
        addHooks: function() {
            if (this._shape._map) {
                this._map = this._shape._map;
                if (!this._markerGroup) {
                    this._initMarkers();
                }
                this._map.addLayer(this._markerGroup);
            }
        },
        removeHooks: function() {
            if (this._shape._map) {
                this._unbindMarker(this._moveMarker);
                for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {
                    this._unbindMarker(this._resizeMarkers[i]);
                }
                this._resizeMarkers = null;
                this._map.removeLayer(this._markerGroup);
                delete this._markerGroup;
            }
            this._map = null;
        },
        updateMarkers: function() {
            this._markerGroup.clearLayers();
            this._initMarkers();
        },
        _initMarkers: function() {
            if (!this._markerGroup) {
                this._markerGroup = new L.LayerGroup();
            }
            this._createMoveMarker();
            this._createResizeMarker();
        },
        _createMoveMarker: function() {},
        _createResizeMarker: function() {},
        _createMarker: function(latlng, icon) {
            var marker = new L.Marker(latlng, {
                draggable: true,
                icon: icon,
                zIndexOffset: 10
            });
            this._bindMarker(marker);
            this._markerGroup.addLayer(marker);
            return marker;
        },
        _bindMarker: function(marker) {
            marker.on("dragstart", this._onMarkerDragStart, this).on("drag", this._onMarkerDrag, this).on("dragend", this._onMarkerDragEnd, this);
        },
        _unbindMarker: function(marker) {
            marker.off("dragstart", this._onMarkerDragStart, this).off("drag", this._onMarkerDrag, this).off("dragend", this._onMarkerDragEnd, this);
        },
        _onMarkerDragStart: function(e) {
            var marker = e.target;
            marker.setOpacity(0);
            this._shape.fire("editstart");
        },
        _fireEdit: function() {
            this._shape.edited = true;
            this._shape.fire("edit");
        },
        _onMarkerDrag: function(e) {
            var marker = e.target, latlng = marker.getLatLng();
            if (marker === this._moveMarker) {
                this._move(latlng);
            } else {
                this._resize(latlng);
            }
            this._shape.redraw();
        },
        _onMarkerDragEnd: function(e) {
            var marker = e.target;
            marker.setOpacity(1);
            this._fireEdit();
        },
        _move: function() {},
        _resize: function() {}
    });
    L.Edit = L.Edit || {};
    L.Edit.Rectangle = L.Edit.SimpleShape.extend({
        _createMoveMarker: function() {
            var bounds = this._shape.getBounds(), center = bounds.getCenter();
            this._moveMarker = this._createMarker(center, this.options.moveIcon);
        },
        _createResizeMarker: function() {
            var corners = this._getCorners();
            this._resizeMarkers = [];
            for (var i = 0, l = corners.length; i < l; i++) {
                this._resizeMarkers.push(this._createMarker(corners[i], this.options.resizeIcon));
                this._resizeMarkers[i]._cornerIndex = i;
            }
        },
        _onMarkerDragStart: function(e) {
            L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);
            var corners = this._getCorners(), marker = e.target, currentCornerIndex = marker._cornerIndex;
            this._oppositeCorner = corners[(currentCornerIndex + 2) % 4];
            this._toggleCornerMarkers(0, currentCornerIndex);
        },
        _onMarkerDragEnd: function(e) {
            var marker = e.target, bounds, center;
            if (marker === this._moveMarker) {
                bounds = this._shape.getBounds();
                center = bounds.getCenter();
                marker.setLatLng(center);
            }
            this._toggleCornerMarkers(1);
            this._repositionCornerMarkers();
            L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, e);
        },
        _move: function(newCenter) {
            var latlngs = this._shape.getLatLngs(), bounds = this._shape.getBounds(), center = bounds.getCenter(), offset, newLatLngs = [];
            for (var i = 0, l = latlngs.length; i < l; i++) {
                offset = [ latlngs[i].lat - center.lat, latlngs[i].lng - center.lng ];
                newLatLngs.push([ newCenter.lat + offset[0], newCenter.lng + offset[1] ]);
            }
            this._shape.setLatLngs(newLatLngs);
            this._repositionCornerMarkers();
        },
        _resize: function(latlng) {
            var bounds;
            this._shape.setBounds(L.latLngBounds(latlng, this._oppositeCorner));
            bounds = this._shape.getBounds();
            this._moveMarker.setLatLng(bounds.getCenter());
        },
        _getCorners: function() {
            var bounds = this._shape.getBounds(), nw = bounds.getNorthWest(), ne = bounds.getNorthEast(), se = bounds.getSouthEast(), sw = bounds.getSouthWest();
            return [ nw, ne, se, sw ];
        },
        _toggleCornerMarkers: function(opacity) {
            for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {
                this._resizeMarkers[i].setOpacity(opacity);
            }
        },
        _repositionCornerMarkers: function() {
            var corners = this._getCorners();
            for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {
                this._resizeMarkers[i].setLatLng(corners[i]);
            }
        }
    });
    L.Rectangle.addInitHook(function() {
        if (L.Edit.Rectangle) {
            this.editing = new L.Edit.Rectangle(this);
            if (this.options.editable) {
                this.editing.enable();
            }
        }
    });
    L.Edit = L.Edit || {};
    L.Edit.Circle = L.Edit.SimpleShape.extend({
        _createMoveMarker: function() {
            var center = this._shape.getLatLng();
            this._moveMarker = this._createMarker(center, this.options.moveIcon);
        },
        _createResizeMarker: function() {
            var center = this._shape.getLatLng(), resizemarkerPoint = this._getResizeMarkerPoint(center);
            this._resizeMarkers = [];
            this._resizeMarkers.push(this._createMarker(resizemarkerPoint, this.options.resizeIcon));
        },
        _getResizeMarkerPoint: function(latlng) {
            var delta = this._shape._radius * Math.cos(Math.PI / 4), point = this._map.project(latlng);
            return this._map.unproject([ point.x + delta, point.y - delta ]);
        },
        _move: function(latlng) {
            var resizemarkerPoint = this._getResizeMarkerPoint(latlng);
            this._resizeMarkers[0].setLatLng(resizemarkerPoint);
            this._shape.setLatLng(latlng);
        },
        _resize: function(latlng) {
            var moveLatLng = this._moveMarker.getLatLng(), radius = moveLatLng.distanceTo(latlng);
            this._shape.setRadius(radius);
        }
    });
    L.Circle.addInitHook(function() {
        if (L.Edit.Circle) {
            this.editing = new L.Edit.Circle(this);
            if (this.options.editable) {
                this.editing.enable();
            }
        }
        this.on("add", function() {
            if (this.editing && this.editing.enabled()) {
                this.editing.addHooks();
            }
        });
        this.on("remove", function() {
            if (this.editing && this.editing.enabled()) {
                this.editing.removeHooks();
            }
        });
    });
    L.LatLngUtil = {
        cloneLatLngs: function(latlngs) {
            var clone = [];
            for (var i = 0, l = latlngs.length; i < l; i++) {
                clone.push(this.cloneLatLng(latlngs[i]));
            }
            return clone;
        },
        cloneLatLng: function(latlng) {
            return L.latLng(latlng.lat, latlng.lng);
        }
    };
    L.GeometryUtil = L.extend(L.GeometryUtil || {}, {
        geodesicArea: function(latLngs) {
            var pointsCount = latLngs.length, area = 0, d2r = L.LatLng.DEG_TO_RAD, p1, p2;
            if (pointsCount > 2) {
                for (var i = 0; i < pointsCount; i++) {
                    p1 = latLngs[i];
                    p2 = latLngs[(i + 1) % pointsCount];
                    area += (p2.lng - p1.lng) * d2r * (2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));
                }
                area = area * 6378137 * 6378137 / 2;
            }
            return Math.abs(area);
        },
        readableArea: function(area, isMetric) {
            var areaStr;
            if (isMetric) {
                if (area >= 1e4) {
                    areaStr = (area * 1e-4).toFixed(2) + " ha";
                } else {
                    areaStr = area.toFixed(2) + " m&sup2;";
                }
            } else {
                area *= .836127;
                if (area >= 3097600) {
                    areaStr = (area / 3097600).toFixed(2) + " mi&sup2;";
                } else if (area >= 4840) {
                    areaStr = (area / 4840).toFixed(2) + " acres";
                } else {
                    areaStr = Math.ceil(area) + " yd&sup2;";
                }
            }
            return areaStr;
        },
        readableDistance: function(distance, isMetric) {
            var distanceStr;
            if (isMetric) {
                if (distance > 1e3) {
                    distanceStr = (distance / 1e3).toFixed(2) + " km";
                } else {
                    distanceStr = Math.ceil(distance) + " m";
                }
            } else {
                distance *= 1.09361;
                if (distance > 1760) {
                    distanceStr = (distance / 1760).toFixed(2) + " miles";
                } else {
                    distanceStr = Math.ceil(distance) + " yd";
                }
            }
            return distanceStr;
        }
    });
    L.Util.extend(L.LineUtil, {
        segmentsIntersect: function(p, p1, p2, p3) {
            return this._checkCounterclockwise(p, p2, p3) !== this._checkCounterclockwise(p1, p2, p3) && this._checkCounterclockwise(p, p1, p2) !== this._checkCounterclockwise(p, p1, p3);
        },
        _checkCounterclockwise: function(p, p1, p2) {
            return (p2.y - p.y) * (p1.x - p.x) > (p1.y - p.y) * (p2.x - p.x);
        }
    });
    L.Polyline.include({
        intersects: function() {
            var points = this._originalPoints, len = points ? points.length : 0, i, p, p1;
            if (this._tooFewPointsForIntersection()) {
                return false;
            }
            for (i = len - 1; i >= 3; i--) {
                p = points[i - 1];
                p1 = points[i];
                if (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {
                    return true;
                }
            }
            return false;
        },
        newLatLngIntersects: function(latlng, skipFirst) {
            if (!this._map) {
                return false;
            }
            return this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);
        },
        newPointIntersects: function(newPoint, skipFirst) {
            var points = this._originalPoints, len = points ? points.length : 0, lastPoint = points ? points[len - 1] : null, maxIndex = len - 2;
            if (this._tooFewPointsForIntersection(1)) {
                return false;
            }
            return this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);
        },
        _tooFewPointsForIntersection: function(extraPoints) {
            var points = this._originalPoints, len = points ? points.length : 0;
            len += extraPoints || 0;
            return !this._originalPoints || len <= 3;
        },
        _lineSegmentsIntersectsRange: function(p, p1, maxIndex, minIndex) {
            var points = this._originalPoints, p2, p3;
            minIndex = minIndex || 0;
            for (var j = maxIndex; j > minIndex; j--) {
                p2 = points[j - 1];
                p3 = points[j];
                if (L.LineUtil.segmentsIntersect(p, p1, p2, p3)) {
                    return true;
                }
            }
            return false;
        }
    });
    L.Polygon.include({
        intersects: function() {
            var polylineIntersects, points = this._originalPoints, len, firstPoint, lastPoint, maxIndex;
            if (this._tooFewPointsForIntersection()) {
                return false;
            }
            polylineIntersects = L.Polyline.prototype.intersects.call(this);
            if (polylineIntersects) {
                return true;
            }
            len = points.length;
            firstPoint = points[0];
            lastPoint = points[len - 1];
            maxIndex = len - 2;
            return this._lineSegmentsIntersectsRange(lastPoint, firstPoint, maxIndex, 1);
        }
    });
    L.Control.Draw = L.Control.extend({
        options: {
            position: "topleft",
            draw: {},
            edit: false
        },
        initialize: function(options) {
            if (L.version < "0.7") {
                throw new Error("Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/");
            }
            L.Control.prototype.initialize.call(this, options);
            var toolbar;
            this._toolbars = {};
            if (L.DrawToolbar && this.options.draw) {
                toolbar = new L.DrawToolbar(this.options.draw);
                this._toolbars[L.DrawToolbar.TYPE] = toolbar;
                this._toolbars[L.DrawToolbar.TYPE].on("enable", this._toolbarEnabled, this);
            }
            if (L.EditToolbar && this.options.edit) {
                toolbar = new L.EditToolbar(this.options.edit);
                this._toolbars[L.EditToolbar.TYPE] = toolbar;
                this._toolbars[L.EditToolbar.TYPE].on("enable", this._toolbarEnabled, this);
            }
        },
        onAdd: function(map) {
            var container = L.DomUtil.create("div", "leaflet-draw"), addedTopClass = false, topClassName = "leaflet-draw-toolbar-top", toolbarContainer;
            for (var toolbarId in this._toolbars) {
                if (this._toolbars.hasOwnProperty(toolbarId)) {
                    toolbarContainer = this._toolbars[toolbarId].addToolbar(map);
                    if (toolbarContainer) {
                        if (!addedTopClass) {
                            if (!L.DomUtil.hasClass(toolbarContainer, topClassName)) {
                                L.DomUtil.addClass(toolbarContainer.childNodes[0], topClassName);
                            }
                            addedTopClass = true;
                        }
                        container.appendChild(toolbarContainer);
                    }
                }
            }
            return container;
        },
        onRemove: function() {
            for (var toolbarId in this._toolbars) {
                if (this._toolbars.hasOwnProperty(toolbarId)) {
                    this._toolbars[toolbarId].removeToolbar();
                }
            }
        },
        setDrawingOptions: function(options) {
            for (var toolbarId in this._toolbars) {
                if (this._toolbars[toolbarId] instanceof L.DrawToolbar) {
                    this._toolbars[toolbarId].setOptions(options);
                }
            }
        },
        _toolbarEnabled: function(e) {
            var enabledToolbar = e.target;
            for (var toolbarId in this._toolbars) {
                if (this._toolbars[toolbarId] !== enabledToolbar) {
                    this._toolbars[toolbarId].disable();
                }
            }
        }
    });
    L.Map.mergeOptions({
        drawControlTooltips: true,
        drawControl: false
    });
    L.Map.addInitHook(function() {
        if (this.options.drawControl) {
            this.drawControl = new L.Control.Draw();
            this.addControl(this.drawControl);
        }
    });
    L.Toolbar = L.Class.extend({
        includes: [ L.Mixin.Events ],
        initialize: function(options) {
            L.setOptions(this, options);
            this._modes = {};
            this._actionButtons = [];
            this._activeMode = null;
        },
        enabled: function() {
            return this._activeMode !== null;
        },
        disable: function() {
            if (!this.enabled()) {
                return;
            }
            this._activeMode.handler.disable();
        },
        addToolbar: function(map) {
            var container = L.DomUtil.create("div", "leaflet-draw-section"), buttonIndex = 0, buttonClassPrefix = this._toolbarClass || "", modeHandlers = this.getModeHandlers(map), i;
            this._toolbarContainer = L.DomUtil.create("div", "leaflet-draw-toolbar leaflet-bar");
            this._map = map;
            for (i = 0; i < modeHandlers.length; i++) {
                if (modeHandlers[i].enabled) {
                    this._initModeHandler(modeHandlers[i].handler, this._toolbarContainer, buttonIndex++, buttonClassPrefix, modeHandlers[i].title);
                }
            }
            if (!buttonIndex) {
                return;
            }
            this._lastButtonIndex = --buttonIndex;
            this._actionsContainer = L.DomUtil.create("ul", "leaflet-draw-actions");
            container.appendChild(this._toolbarContainer);
            container.appendChild(this._actionsContainer);
            return container;
        },
        removeToolbar: function() {
            for (var handlerId in this._modes) {
                if (this._modes.hasOwnProperty(handlerId)) {
                    this._disposeButton(this._modes[handlerId].button, this._modes[handlerId].handler.enable, this._modes[handlerId].handler);
                    this._modes[handlerId].handler.disable();
                    this._modes[handlerId].handler.off("enabled", this._handlerActivated, this).off("disabled", this._handlerDeactivated, this);
                }
            }
            this._modes = {};
            for (var i = 0, l = this._actionButtons.length; i < l; i++) {
                this._disposeButton(this._actionButtons[i].button, this._actionButtons[i].callback, this);
            }
            this._actionButtons = [];
            this._actionsContainer = null;
        },
        _initModeHandler: function(handler, container, buttonIndex, classNamePredix, buttonTitle) {
            var type = handler.type;
            this._modes[type] = {};
            this._modes[type].handler = handler;
            this._modes[type].button = this._createButton({
                title: buttonTitle,
                className: classNamePredix + "-" + type,
                container: container,
                callback: this._modes[type].handler.enable,
                context: this._modes[type].handler
            });
            this._modes[type].buttonIndex = buttonIndex;
            this._modes[type].handler.on("enabled", this._handlerActivated, this).on("disabled", this._handlerDeactivated, this);
        },
        _createButton: function(options) {
            var link = L.DomUtil.create("a", options.className || "", options.container);
            link.href = "#";
            if (options.text) {
                link.innerHTML = options.text;
            }
            if (options.title) {
                link.title = options.title;
            }
            L.DomEvent.on(link, "click", L.DomEvent.stopPropagation).on(link, "mousedown", L.DomEvent.stopPropagation).on(link, "dblclick", L.DomEvent.stopPropagation).on(link, "click", L.DomEvent.preventDefault).on(link, "click", options.callback, options.context);
            return link;
        },
        _disposeButton: function(button, callback) {
            L.DomEvent.off(button, "click", L.DomEvent.stopPropagation).off(button, "mousedown", L.DomEvent.stopPropagation).off(button, "dblclick", L.DomEvent.stopPropagation).off(button, "click", L.DomEvent.preventDefault).off(button, "click", callback);
        },
        _handlerActivated: function(e) {
            this.disable();
            this._activeMode = this._modes[e.handler];
            L.DomUtil.addClass(this._activeMode.button, "leaflet-draw-toolbar-button-enabled");
            this._showActionsToolbar();
            this.fire("enable");
        },
        _handlerDeactivated: function() {
            this._hideActionsToolbar();
            L.DomUtil.removeClass(this._activeMode.button, "leaflet-draw-toolbar-button-enabled");
            this._activeMode = null;
            this.fire("disable");
        },
        _createActions: function(handler) {
            var container = this._actionsContainer, buttons = this.getActions(handler), l = buttons.length, li, di, dl, button;
            for (di = 0, dl = this._actionButtons.length; di < dl; di++) {
                this._disposeButton(this._actionButtons[di].button, this._actionButtons[di].callback);
            }
            this._actionButtons = [];
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            for (var i = 0; i < l; i++) {
                if ("enabled" in buttons[i] && !buttons[i].enabled) {
                    continue;
                }
                li = L.DomUtil.create("li", "", container);
                button = this._createButton({
                    title: buttons[i].title,
                    text: buttons[i].text,
                    container: li,
                    callback: buttons[i].callback,
                    context: buttons[i].context
                });
                this._actionButtons.push({
                    button: button,
                    callback: buttons[i].callback
                });
            }
        },
        _showActionsToolbar: function() {
            var buttonIndex = this._activeMode.buttonIndex, lastButtonIndex = this._lastButtonIndex, toolbarPosition = this._activeMode.button.offsetTop - 1;
            this._createActions(this._activeMode.handler);
            this._actionsContainer.style.top = toolbarPosition + "px";
            if (buttonIndex === 0) {
                L.DomUtil.addClass(this._toolbarContainer, "leaflet-draw-toolbar-notop");
                L.DomUtil.addClass(this._actionsContainer, "leaflet-draw-actions-top");
            }
            if (buttonIndex === lastButtonIndex) {
                L.DomUtil.addClass(this._toolbarContainer, "leaflet-draw-toolbar-nobottom");
                L.DomUtil.addClass(this._actionsContainer, "leaflet-draw-actions-bottom");
            }
            this._actionsContainer.style.display = "block";
        },
        _hideActionsToolbar: function() {
            this._actionsContainer.style.display = "none";
            L.DomUtil.removeClass(this._toolbarContainer, "leaflet-draw-toolbar-notop");
            L.DomUtil.removeClass(this._toolbarContainer, "leaflet-draw-toolbar-nobottom");
            L.DomUtil.removeClass(this._actionsContainer, "leaflet-draw-actions-top");
            L.DomUtil.removeClass(this._actionsContainer, "leaflet-draw-actions-bottom");
        }
    });
    L.Tooltip = L.Class.extend({
        initialize: function(map) {
            this._map = map;
            this._popupPane = map._panes.popupPane;
            this._container = map.options.drawControlTooltips ? L.DomUtil.create("div", "leaflet-draw-tooltip", this._popupPane) : null;
            this._singleLineLabel = false;
        },
        dispose: function() {
            if (this._container) {
                this._popupPane.removeChild(this._container);
                this._container = null;
            }
        },
        updateContent: function(labelText) {
            if (!this._container) {
                return this;
            }
            labelText.subtext = labelText.subtext || "";
            if (labelText.subtext.length === 0 && !this._singleLineLabel) {
                L.DomUtil.addClass(this._container, "leaflet-draw-tooltip-single");
                this._singleLineLabel = true;
            } else if (labelText.subtext.length > 0 && this._singleLineLabel) {
                L.DomUtil.removeClass(this._container, "leaflet-draw-tooltip-single");
                this._singleLineLabel = false;
            }
            this._container.innerHTML = (labelText.subtext.length > 0 ? '<span class="leaflet-draw-tooltip-subtext">' + labelText.subtext + "</span>" + "<br />" : "") + "<span>" + labelText.text + "</span>";
            return this;
        },
        updatePosition: function(latlng) {
            var pos = this._map.latLngToLayerPoint(latlng), tooltipContainer = this._container;
            if (this._container) {
                tooltipContainer.style.visibility = "inherit";
                L.DomUtil.setPosition(tooltipContainer, pos);
            }
            return this;
        },
        showAsError: function() {
            if (this._container) {
                L.DomUtil.addClass(this._container, "leaflet-error-draw-tooltip");
            }
            return this;
        },
        removeError: function() {
            if (this._container) {
                L.DomUtil.removeClass(this._container, "leaflet-error-draw-tooltip");
            }
            return this;
        }
    });
    L.DrawToolbar = L.Toolbar.extend({
        statics: {
            TYPE: "draw"
        },
        options: {
            polyline: {},
            polygon: {},
            rectangle: {},
            circle: {},
            marker: {}
        },
        initialize: function(options) {
            for (var type in this.options) {
                if (this.options.hasOwnProperty(type)) {
                    if (options[type]) {
                        options[type] = L.extend({}, this.options[type], options[type]);
                    }
                }
            }
            this._toolbarClass = "leaflet-draw-draw";
            L.Toolbar.prototype.initialize.call(this, options);
        },
        getModeHandlers: function(map) {
            return [ {
                enabled: this.options.polyline,
                handler: new L.Draw.Polyline(map, this.options.polyline),
                title: L.drawLocal.draw.toolbar.buttons.polyline
            }, {
                enabled: this.options.polygon,
                handler: new L.Draw.Polygon(map, this.options.polygon),
                title: L.drawLocal.draw.toolbar.buttons.polygon
            }, {
                enabled: this.options.rectangle,
                handler: new L.Draw.Rectangle(map, this.options.rectangle),
                title: L.drawLocal.draw.toolbar.buttons.rectangle
            }, {
                enabled: this.options.circle,
                handler: new L.Draw.Circle(map, this.options.circle),
                title: L.drawLocal.draw.toolbar.buttons.circle
            }, {
                enabled: this.options.marker,
                handler: new L.Draw.Marker(map, this.options.marker),
                title: L.drawLocal.draw.toolbar.buttons.marker
            } ];
        },
        getActions: function(handler) {
            return [ {
                enabled: handler.deleteLastVertex,
                title: L.drawLocal.draw.toolbar.undo.title,
                text: L.drawLocal.draw.toolbar.undo.text,
                callback: handler.deleteLastVertex,
                context: handler
            }, {
                title: L.drawLocal.draw.toolbar.actions.title,
                text: L.drawLocal.draw.toolbar.actions.text,
                callback: this.disable,
                context: this
            } ];
        },
        setOptions: function(options) {
            L.setOptions(this, options);
            for (var type in this._modes) {
                if (this._modes.hasOwnProperty(type) && options.hasOwnProperty(type)) {
                    this._modes[type].handler.setOptions(options[type]);
                }
            }
        }
    });
    L.EditToolbar = L.Toolbar.extend({
        statics: {
            TYPE: "edit"
        },
        options: {
            edit: {
                selectedPathOptions: {
                    color: "#fe57a1",
                    opacity: .6,
                    dashArray: "10, 10",
                    fill: true,
                    fillColor: "#fe57a1",
                    fillOpacity: .1,
                    maintainColor: false
                }
            },
            remove: {},
            featureGroup: null
        },
        initialize: function(options) {
            if (options.edit) {
                if (typeof options.edit.selectedPathOptions === "undefined") {
                    options.edit.selectedPathOptions = this.options.edit.selectedPathOptions;
                }
                options.edit.selectedPathOptions = L.extend({}, this.options.edit.selectedPathOptions, options.edit.selectedPathOptions);
            }
            if (options.remove) {
                options.remove = L.extend({}, this.options.remove, options.remove);
            }
            this._toolbarClass = "leaflet-draw-edit";
            L.Toolbar.prototype.initialize.call(this, options);
            this._selectedFeatureCount = 0;
        },
        getModeHandlers: function(map) {
            var featureGroup = this.options.featureGroup;
            return [ {
                enabled: this.options.edit,
                handler: new L.EditToolbar.Edit(map, {
                    featureGroup: featureGroup,
                    selectedPathOptions: this.options.edit.selectedPathOptions
                }),
                title: L.drawLocal.edit.toolbar.buttons.edit
            }, {
                enabled: this.options.remove,
                handler: new L.EditToolbar.Delete(map, {
                    featureGroup: featureGroup
                }),
                title: L.drawLocal.edit.toolbar.buttons.remove
            } ];
        },
        getActions: function() {
            return [ {
                title: L.drawLocal.edit.toolbar.actions.save.title,
                text: L.drawLocal.edit.toolbar.actions.save.text,
                callback: this._save,
                context: this
            }, {
                title: L.drawLocal.edit.toolbar.actions.cancel.title,
                text: L.drawLocal.edit.toolbar.actions.cancel.text,
                callback: this.disable,
                context: this
            } ];
        },
        addToolbar: function(map) {
            var container = L.Toolbar.prototype.addToolbar.call(this, map);
            this._checkDisabled();
            this.options.featureGroup.on("layeradd layerremove", this._checkDisabled, this);
            return container;
        },
        removeToolbar: function() {
            this.options.featureGroup.off("layeradd layerremove", this._checkDisabled, this);
            L.Toolbar.prototype.removeToolbar.call(this);
        },
        disable: function() {
            if (!this.enabled()) {
                return;
            }
            this._activeMode.handler.revertLayers();
            L.Toolbar.prototype.disable.call(this);
        },
        _save: function() {
            this._activeMode.handler.save();
            this._activeMode.handler.disable();
        },
        _checkDisabled: function() {
            var featureGroup = this.options.featureGroup, hasLayers = featureGroup.getLayers().length !== 0, button;
            if (this.options.edit) {
                button = this._modes[L.EditToolbar.Edit.TYPE].button;
                if (hasLayers) {
                    L.DomUtil.removeClass(button, "leaflet-disabled");
                } else {
                    L.DomUtil.addClass(button, "leaflet-disabled");
                }
                button.setAttribute("title", hasLayers ? L.drawLocal.edit.toolbar.buttons.edit : L.drawLocal.edit.toolbar.buttons.editDisabled);
            }
            if (this.options.remove) {
                button = this._modes[L.EditToolbar.Delete.TYPE].button;
                if (hasLayers) {
                    L.DomUtil.removeClass(button, "leaflet-disabled");
                } else {
                    L.DomUtil.addClass(button, "leaflet-disabled");
                }
                button.setAttribute("title", hasLayers ? L.drawLocal.edit.toolbar.buttons.remove : L.drawLocal.edit.toolbar.buttons.removeDisabled);
            }
        }
    });
    L.EditToolbar.Edit = L.Handler.extend({
        statics: {
            TYPE: "edit"
        },
        includes: L.Mixin.Events,
        initialize: function(map, options) {
            L.Handler.prototype.initialize.call(this, map);
            this._selectedPathOptions = options.selectedPathOptions;
            this._featureGroup = options.featureGroup;
            if (!(this._featureGroup instanceof L.FeatureGroup)) {
                throw new Error("options.featureGroup must be a L.FeatureGroup");
            }
            this._uneditedLayerProps = {};
            this.type = L.EditToolbar.Edit.TYPE;
        },
        enable: function() {
            if (this._enabled || !this._hasAvailableLayers()) {
                return;
            }
            this.fire("enabled", {
                handler: this.type
            });
            this._map.fire("draw:editstart", {
                handler: this.type
            });
            L.Handler.prototype.enable.call(this);
            this._featureGroup.on("layeradd", this._enableLayerEdit, this).on("layerremove", this._disableLayerEdit, this);
        },
        disable: function() {
            if (!this._enabled) {
                return;
            }
            this._featureGroup.off("layeradd", this._enableLayerEdit, this).off("layerremove", this._disableLayerEdit, this);
            L.Handler.prototype.disable.call(this);
            this._map.fire("draw:editstop", {
                handler: this.type
            });
            this.fire("disabled", {
                handler: this.type
            });
        },
        addHooks: function() {
            var map = this._map;
            if (map) {
                map.getContainer().focus();
                this._featureGroup.eachLayer(this._enableLayerEdit, this);
                this._tooltip = new L.Tooltip(this._map);
                this._tooltip.updateContent({
                    text: L.drawLocal.edit.handlers.edit.tooltip.text,
                    subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext
                });
                this._map.on("mousemove", this._onMouseMove, this);
            }
        },
        removeHooks: function() {
            if (this._map) {
                this._featureGroup.eachLayer(this._disableLayerEdit, this);
                this._uneditedLayerProps = {};
                this._tooltip.dispose();
                this._tooltip = null;
                this._map.off("mousemove", this._onMouseMove, this);
            }
        },
        revertLayers: function() {
            this._featureGroup.eachLayer(function(layer) {
                this._revertLayer(layer);
            }, this);
        },
        save: function() {
            var editedLayers = new L.LayerGroup();
            this._featureGroup.eachLayer(function(layer) {
                if (layer.edited) {
                    editedLayers.addLayer(layer);
                    layer.edited = false;
                }
            });
            this._map.fire("draw:edited", {
                layers: editedLayers
            });
        },
        _backupLayer: function(layer) {
            var id = L.Util.stamp(layer);
            if (!this._uneditedLayerProps[id]) {
                if (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {
                    this._uneditedLayerProps[id] = {
                        latlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs())
                    };
                } else if (layer instanceof L.Circle) {
                    this._uneditedLayerProps[id] = {
                        latlng: L.LatLngUtil.cloneLatLng(layer.getLatLng()),
                        radius: layer.getRadius()
                    };
                } else if (layer instanceof L.Marker) {
                    this._uneditedLayerProps[id] = {
                        latlng: L.LatLngUtil.cloneLatLng(layer.getLatLng())
                    };
                }
            }
        },
        _revertLayer: function(layer) {
            var id = L.Util.stamp(layer);
            layer.edited = false;
            if (this._uneditedLayerProps.hasOwnProperty(id)) {
                if (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {
                    layer.setLatLngs(this._uneditedLayerProps[id].latlngs);
                } else if (layer instanceof L.Circle) {
                    layer.setLatLng(this._uneditedLayerProps[id].latlng);
                    layer.setRadius(this._uneditedLayerProps[id].radius);
                } else if (layer instanceof L.Marker) {
                    layer.setLatLng(this._uneditedLayerProps[id].latlng);
                }
            }
        },
        _toggleMarkerHighlight: function(marker) {
            if (!marker._icon) {
                return;
            }
            var icon = marker._icon;
            icon.style.display = "none";
            if (L.DomUtil.hasClass(icon, "leaflet-edit-marker-selected")) {
                L.DomUtil.removeClass(icon, "leaflet-edit-marker-selected");
                this._offsetMarker(icon, -4);
            } else {
                L.DomUtil.addClass(icon, "leaflet-edit-marker-selected");
                this._offsetMarker(icon, 4);
            }
            icon.style.display = "";
        },
        _offsetMarker: function(icon, offset) {
            var iconMarginTop = parseInt(icon.style.marginTop, 10) - offset, iconMarginLeft = parseInt(icon.style.marginLeft, 10) - offset;
            icon.style.marginTop = iconMarginTop + "px";
            icon.style.marginLeft = iconMarginLeft + "px";
        },
        _enableLayerEdit: function(e) {
            var layer = e.layer || e.target || e, isMarker = layer instanceof L.Marker, pathOptions;
            if (isMarker && !layer._icon) {
                return;
            }
            this._backupLayer(layer);
            if (this._selectedPathOptions) {
                pathOptions = L.Util.extend({}, this._selectedPathOptions);
                if (pathOptions.maintainColor) {
                    pathOptions.color = layer.options.color;
                    pathOptions.fillColor = layer.options.fillColor;
                }
                if (isMarker) {
                    this._toggleMarkerHighlight(layer);
                } else {
                    layer.options.previousOptions = L.Util.extend({
                        dashArray: null
                    }, layer.options);
                    if (!(layer instanceof L.Circle) && !(layer instanceof L.Polygon) && !(layer instanceof L.Rectangle)) {
                        pathOptions.fill = false;
                    }
                    layer.setStyle(pathOptions);
                }
            }
            if (isMarker) {
                layer.dragging.enable();
                layer.on("dragend", this._onMarkerDragEnd);
            } else {
                layer.editing.enable();
            }
        },
        _disableLayerEdit: function(e) {
            var layer = e.layer || e.target || e;
            layer.edited = false;
            if (this._selectedPathOptions) {
                if (layer instanceof L.Marker) {
                    this._toggleMarkerHighlight(layer);
                } else {
                    layer.setStyle(layer.options.previousOptions);
                    delete layer.options.previousOptions;
                }
            }
            if (layer instanceof L.Marker) {
                layer.dragging.disable();
                layer.off("dragend", this._onMarkerDragEnd, this);
            } else {
                layer.editing.disable();
            }
        },
        _onMarkerDragEnd: function(e) {
            var layer = e.target;
            layer.edited = true;
        },
        _onMouseMove: function(e) {
            this._tooltip.updatePosition(e.latlng);
        },
        _hasAvailableLayers: function() {
            return this._featureGroup.getLayers().length !== 0;
        }
    });
    L.EditToolbar.Delete = L.Handler.extend({
        statics: {
            TYPE: "remove"
        },
        includes: L.Mixin.Events,
        initialize: function(map, options) {
            L.Handler.prototype.initialize.call(this, map);
            L.Util.setOptions(this, options);
            this._deletableLayers = this.options.featureGroup;
            if (!(this._deletableLayers instanceof L.FeatureGroup)) {
                throw new Error("options.featureGroup must be a L.FeatureGroup");
            }
            this.type = L.EditToolbar.Delete.TYPE;
        },
        enable: function() {
            if (this._enabled || !this._hasAvailableLayers()) {
                return;
            }
            this.fire("enabled", {
                handler: this.type
            });
            this._map.fire("draw:deletestart", {
                handler: this.type
            });
            L.Handler.prototype.enable.call(this);
            this._deletableLayers.on("layeradd", this._enableLayerDelete, this).on("layerremove", this._disableLayerDelete, this);
        },
        disable: function() {
            if (!this._enabled) {
                return;
            }
            this._deletableLayers.off("layeradd", this._enableLayerDelete, this).off("layerremove", this._disableLayerDelete, this);
            L.Handler.prototype.disable.call(this);
            this._map.fire("draw:deletestop", {
                handler: this.type
            });
            this.fire("disabled", {
                handler: this.type
            });
        },
        addHooks: function() {
            var map = this._map;
            if (map) {
                map.getContainer().focus();
                this._deletableLayers.eachLayer(this._enableLayerDelete, this);
                this._deletedLayers = new L.layerGroup();
                this._tooltip = new L.Tooltip(this._map);
                this._tooltip.updateContent({
                    text: L.drawLocal.edit.handlers.remove.tooltip.text
                });
                this._map.on("mousemove", this._onMouseMove, this);
            }
        },
        removeHooks: function() {
            if (this._map) {
                this._deletableLayers.eachLayer(this._disableLayerDelete, this);
                this._deletedLayers = null;
                this._tooltip.dispose();
                this._tooltip = null;
                this._map.off("mousemove", this._onMouseMove, this);
            }
        },
        revertLayers: function() {
            this._deletedLayers.eachLayer(function(layer) {
                this._deletableLayers.addLayer(layer);
            }, this);
        },
        save: function() {
            this._map.fire("draw:deleted", {
                layers: this._deletedLayers
            });
        },
        _enableLayerDelete: function(e) {
            var layer = e.layer || e.target || e;
            layer.on("click", this._removeLayer, this);
        },
        _disableLayerDelete: function(e) {
            var layer = e.layer || e.target || e;
            layer.off("click", this._removeLayer, this);
            this._deletedLayers.removeLayer(layer);
        },
        _removeLayer: function(e) {
            var layer = e.layer || e.target || e;
            this._deletableLayers.removeLayer(layer);
            this._deletedLayers.addLayer(layer);
        },
        _onMouseMove: function(e) {
            this._tooltip.updatePosition(e.latlng);
        },
        _hasAvailableLayers: function() {
            return this._deletableLayers.getLayers().length !== 0;
        }
    });
})(window, document);

L.Google = L.Class.extend({
    includes: L.Mixin.Events,
    options: {
        minZoom: 0,
        maxZoom: 18,
        tileSize: 256,
        subdomains: "abc",
        errorTileUrl: "",
        attribution: "",
        opacity: 1,
        continuousWorld: false,
        noWrap: false,
        mapOptions: {
            backgroundColor: "#dddddd"
        }
    },
    initialize: function(type, options) {
        L.Util.setOptions(this, options);
        this._ready = google.maps.Map !== undefined;
        if (!this._ready) L.Google.asyncWait.push(this);
        this._type = type || "SATELLITE";
    },
    onAdd: function(map, insertAtTheBottom) {
        this._map = map;
        this._insertAtTheBottom = insertAtTheBottom;
        this._initContainer();
        this._initMapObject();
        map.on("viewreset", this._resetCallback, this);
        this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
        map.on("move", this._update, this);
        map.on("zoomanim", this._handleZoomAnim, this);
        map._controlCorners.bottomright.style.marginBottom = "20px";
        this._reset();
        this._update();
    },
    onRemove: function(map) {
        map._container.removeChild(this._container);
        map.off("viewreset", this._resetCallback, this);
        map.off("move", this._update, this);
        map.off("zoomanim", this._handleZoomAnim, this);
        map._controlCorners.bottomright.style.marginBottom = "0em";
    },
    getAttribution: function() {
        return this.options.attribution;
    },
    setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (opacity < 1) {
            L.DomUtil.setOpacity(this._container, opacity);
        }
    },
    setElementSize: function(e, size) {
        e.style.width = size.x + "px";
        e.style.height = size.y + "px";
    },
    _initContainer: function() {
        var tilePane = this._map._container, first = tilePane.firstChild;
        if (!this._container) {
            this._container = L.DomUtil.create("div", "leaflet-google-layer leaflet-top leaflet-left");
            this._container.id = "_GMapContainer_" + L.Util.stamp(this);
            this._container.style.zIndex = "auto";
        }
        tilePane.insertBefore(this._container, first);
        this.setOpacity(this.options.opacity);
        this.setElementSize(this._container, this._map.getSize());
    },
    _initMapObject: function() {
        if (!this._ready) return;
        this._google_center = new google.maps.LatLng(0, 0);
        var map = new google.maps.Map(this._container, {
            center: this._google_center,
            zoom: 0,
            tilt: 0,
            mapTypeId: google.maps.MapTypeId[this._type],
            disableDefaultUI: true,
            keyboardShortcuts: false,
            draggable: false,
            disableDoubleClickZoom: true,
            scrollwheel: false,
            streetViewControl: false,
            styles: this.options.mapOptions.styles,
            backgroundColor: this.options.mapOptions.backgroundColor
        });
        var _this = this;
        this._reposition = google.maps.event.addListenerOnce(map, "center_changed", function() {
            _this.onReposition();
        });
        this._google = map;
        google.maps.event.addListenerOnce(map, "idle", function() {
            _this._checkZoomLevels();
        });
        this.fire("MapObjectInitialized", {
            mapObject: map
        });
    },
    _checkZoomLevels: function() {
        if (this._google.getZoom() !== this._map.getZoom()) {
            this._map.setZoom(this._google.getZoom());
        }
    },
    _resetCallback: function(e) {
        this._reset(e.hard);
    },
    _reset: function(clearOldContainer) {
        this._initContainer();
    },
    _update: function(e) {
        if (!this._google) return;
        this._resize();
        var center = this._map.getCenter();
        var _center = new google.maps.LatLng(center.lat, center.lng);
        this._google.setCenter(_center);
        this._google.setZoom(Math.round(this._map.getZoom()));
        this._checkZoomLevels();
    },
    _resize: function() {
        var size = this._map.getSize();
        if (this._container.style.width === size.x && this._container.style.height === size.y) return;
        this.setElementSize(this._container, size);
        this.onReposition();
    },
    _handleZoomAnim: function(e) {
        var center = e.center;
        var _center = new google.maps.LatLng(center.lat, center.lng);
        this._google.setCenter(_center);
        this._google.setZoom(Math.round(e.zoom));
    },
    onReposition: function() {
        if (!this._google) return;
        google.maps.event.trigger(this._google, "resize");
    }
});

L.Google.asyncWait = [];

L.Google.asyncInitialize = function() {
    var i;
    for (i = 0; i < L.Google.asyncWait.length; i++) {
        var o = L.Google.asyncWait[i];
        o._ready = true;
        if (o._container) {
            o._initMapObject();
            o._update();
        }
    }
    L.Google.asyncWait = [];
};

(function($) {
    var CLOSE_EVENT = "Close", BEFORE_CLOSE_EVENT = "BeforeClose", AFTER_CLOSE_EVENT = "AfterClose", BEFORE_APPEND_EVENT = "BeforeAppend", MARKUP_PARSE_EVENT = "MarkupParse", OPEN_EVENT = "Open", CHANGE_EVENT = "Change", NS = "mfp", EVENT_NS = "." + NS, READY_CLASS = "mfp-ready", REMOVING_CLASS = "mfp-removing", PREVENT_CLOSE_CLASS = "mfp-prevent-close";
    var mfp, MagnificPopup = function() {}, _isJQ = !!window.jQuery, _prevStatus, _window = $(window), _body, _document, _prevContentType, _wrapClasses, _currPopupType;
    var _mfpOn = function(name, f) {
        mfp.ev.on(NS + name + EVENT_NS, f);
    }, _getEl = function(className, appendTo, html, raw) {
        var el = document.createElement("div");
        el.className = "mfp-" + className;
        if (html) {
            el.innerHTML = html;
        }
        if (!raw) {
            el = $(el);
            if (appendTo) {
                el.appendTo(appendTo);
            }
        } else if (appendTo) {
            appendTo.appendChild(el);
        }
        return el;
    }, _mfpTrigger = function(e, data) {
        mfp.ev.triggerHandler(NS + e, data);
        if (mfp.st.callbacks) {
            e = e.charAt(0).toLowerCase() + e.slice(1);
            if (mfp.st.callbacks[e]) {
                mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [ data ]);
            }
        }
    }, _getCloseBtn = function(type) {
        if (type !== _currPopupType || !mfp.currTemplate.closeBtn) {
            mfp.currTemplate.closeBtn = $(mfp.st.closeMarkup.replace("%title%", mfp.st.tClose));
            _currPopupType = type;
        }
        return mfp.currTemplate.closeBtn;
    }, _checkInstance = function() {
        if (!$.magnificPopup.instance) {
            mfp = new MagnificPopup();
            mfp.init();
            $.magnificPopup.instance = mfp;
        }
    }, supportsTransitions = function() {
        var s = document.createElement("p").style, v = [ "ms", "O", "Moz", "Webkit" ];
        if (s["transition"] !== undefined) {
            return true;
        }
        while (v.length) {
            if (v.pop() + "Transition" in s) {
                return true;
            }
        }
        return false;
    };
    MagnificPopup.prototype = {
        constructor: MagnificPopup,
        init: function() {
            var appVersion = navigator.appVersion;
            mfp.isIE7 = appVersion.indexOf("MSIE 7.") !== -1;
            mfp.isIE8 = appVersion.indexOf("MSIE 8.") !== -1;
            mfp.isLowIE = mfp.isIE7 || mfp.isIE8;
            mfp.isAndroid = /android/gi.test(appVersion);
            mfp.isIOS = /iphone|ipad|ipod/gi.test(appVersion);
            mfp.supportsTransition = supportsTransitions();
            mfp.probablyMobile = mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent);
            _body = $(document.body);
            _document = $(document);
            mfp.popupsCache = {};
        },
        open: function(data) {
            var i;
            if (data.isObj === false) {
                mfp.items = data.items.toArray();
                mfp.index = 0;
                var items = data.items, item;
                for (i = 0; i < items.length; i++) {
                    item = items[i];
                    if (item.parsed) {
                        item = item.el[0];
                    }
                    if (item === data.el[0]) {
                        mfp.index = i;
                        break;
                    }
                }
            } else {
                mfp.items = $.isArray(data.items) ? data.items : [ data.items ];
                mfp.index = data.index || 0;
            }
            if (mfp.isOpen) {
                mfp.updateItemHTML();
                return;
            }
            mfp.types = [];
            _wrapClasses = "";
            if (data.mainEl && data.mainEl.length) {
                mfp.ev = data.mainEl.eq(0);
            } else {
                mfp.ev = _document;
            }
            if (data.key) {
                if (!mfp.popupsCache[data.key]) {
                    mfp.popupsCache[data.key] = {};
                }
                mfp.currTemplate = mfp.popupsCache[data.key];
            } else {
                mfp.currTemplate = {};
            }
            mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data);
            mfp.fixedContentPos = mfp.st.fixedContentPos === "auto" ? !mfp.probablyMobile : mfp.st.fixedContentPos;
            if (mfp.st.modal) {
                mfp.st.closeOnContentClick = false;
                mfp.st.closeOnBgClick = false;
                mfp.st.showCloseBtn = false;
                mfp.st.enableEscapeKey = false;
            }
            if (!mfp.bgOverlay) {
                mfp.bgOverlay = _getEl("bg").on("click" + EVENT_NS, function() {
                    mfp.close();
                });
                mfp.wrap = _getEl("wrap").attr("tabindex", -1).on("click" + EVENT_NS, function(e) {
                    if (mfp._checkIfClose(e.target)) {
                        mfp.close();
                    }
                });
                mfp.container = _getEl("container", mfp.wrap);
            }
            mfp.contentContainer = _getEl("content");
            if (mfp.st.preloader) {
                mfp.preloader = _getEl("preloader", mfp.container, mfp.st.tLoading);
            }
            var modules = $.magnificPopup.modules;
            for (i = 0; i < modules.length; i++) {
                var n = modules[i];
                n = n.charAt(0).toUpperCase() + n.slice(1);
                mfp["init" + n].call(mfp);
            }
            _mfpTrigger("BeforeOpen");
            if (mfp.st.showCloseBtn) {
                if (!mfp.st.closeBtnInside) {
                    mfp.wrap.append(_getCloseBtn());
                } else {
                    _mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
                        values.close_replaceWith = _getCloseBtn(item.type);
                    });
                    _wrapClasses += " mfp-close-btn-in";
                }
            }
            if (mfp.st.alignTop) {
                _wrapClasses += " mfp-align-top";
            }
            if (mfp.fixedContentPos) {
                mfp.wrap.css({
                    overflow: mfp.st.overflowY,
                    overflowX: "hidden",
                    overflowY: mfp.st.overflowY
                });
            } else {
                mfp.wrap.css({
                    top: _window.scrollTop(),
                    position: "absolute"
                });
            }
            if (mfp.st.fixedBgPos === false || mfp.st.fixedBgPos === "auto" && !mfp.fixedContentPos) {
                mfp.bgOverlay.css({
                    height: _document.height(),
                    position: "absolute"
                });
            }
            if (mfp.st.enableEscapeKey) {
                _document.on("keyup" + EVENT_NS, function(e) {
                    if (e.keyCode === 27) {
                        mfp.close();
                    }
                });
            }
            _window.on("resize" + EVENT_NS, function() {
                mfp.updateSize();
            });
            if (!mfp.st.closeOnContentClick) {
                _wrapClasses += " mfp-auto-cursor";
            }
            if (_wrapClasses) mfp.wrap.addClass(_wrapClasses);
            var windowHeight = mfp.wH = _window.height();
            var windowStyles = {};
            if (mfp.fixedContentPos) {
                if (mfp._hasScrollBar(windowHeight)) {
                    var s = mfp._getScrollbarSize();
                    if (s) {
                        windowStyles.marginRight = s;
                    }
                }
            }
            if (mfp.fixedContentPos) {
                if (!mfp.isIE7) {
                    windowStyles.overflow = "hidden";
                } else {
                    $("body, html").css("overflow", "hidden");
                }
            }
            var classesToadd = mfp.st.mainClass;
            if (mfp.isIE7) {
                classesToadd += " mfp-ie7";
            }
            if (classesToadd) {
                mfp._addClassToMFP(classesToadd);
            }
            mfp.updateItemHTML();
            _mfpTrigger("BuildControls");
            $("html").css(windowStyles);
            mfp.bgOverlay.add(mfp.wrap).prependTo(document.body);
            mfp._lastFocusedEl = document.activeElement;
            setTimeout(function() {
                if (mfp.content) {
                    mfp._addClassToMFP(READY_CLASS);
                    mfp._setFocus();
                } else {
                    mfp.bgOverlay.addClass(READY_CLASS);
                }
                _document.on("focusin" + EVENT_NS, mfp._onFocusIn);
            }, 16);
            mfp.isOpen = true;
            mfp.updateSize(windowHeight);
            _mfpTrigger(OPEN_EVENT);
            return data;
        },
        close: function() {
            if (!mfp.isOpen) return;
            _mfpTrigger(BEFORE_CLOSE_EVENT);
            mfp.isOpen = false;
            if (mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition) {
                mfp._addClassToMFP(REMOVING_CLASS);
                setTimeout(function() {
                    mfp._close();
                }, mfp.st.removalDelay);
            } else {
                mfp._close();
            }
        },
        _close: function() {
            _mfpTrigger(CLOSE_EVENT);
            var classesToRemove = REMOVING_CLASS + " " + READY_CLASS + " ";
            mfp.bgOverlay.detach();
            mfp.wrap.detach();
            mfp.container.empty();
            if (mfp.st.mainClass) {
                classesToRemove += mfp.st.mainClass + " ";
            }
            mfp._removeClassFromMFP(classesToRemove);
            if (mfp.fixedContentPos) {
                var windowStyles = {
                    marginRight: ""
                };
                if (mfp.isIE7) {
                    $("body, html").css("overflow", "");
                } else {
                    windowStyles.overflow = "";
                }
                $("html").css(windowStyles);
            }
            _document.off("keyup" + EVENT_NS + " focusin" + EVENT_NS);
            mfp.ev.off(EVENT_NS);
            mfp.wrap.attr("class", "mfp-wrap").removeAttr("style");
            mfp.bgOverlay.attr("class", "mfp-bg");
            mfp.container.attr("class", "mfp-container");
            if (mfp.st.showCloseBtn && (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
                if (mfp.currTemplate.closeBtn) mfp.currTemplate.closeBtn.detach();
            }
            if (mfp._lastFocusedEl) {
                $(mfp._lastFocusedEl).focus();
            }
            mfp.currItem = null;
            mfp.content = null;
            mfp.currTemplate = null;
            mfp.prevHeight = 0;
            _mfpTrigger(AFTER_CLOSE_EVENT);
        },
        updateSize: function(winHeight) {
            if (mfp.isIOS) {
                var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
                var height = window.innerHeight * zoomLevel;
                mfp.wrap.css("height", height);
                mfp.wH = height;
            } else {
                mfp.wH = winHeight || _window.height();
            }
            if (!mfp.fixedContentPos) {
                mfp.wrap.css("height", mfp.wH);
            }
            _mfpTrigger("Resize");
        },
        updateItemHTML: function() {
            var item = mfp.items[mfp.index];
            mfp.contentContainer.detach();
            if (mfp.content) mfp.content.detach();
            if (!item.parsed) {
                item = mfp.parseEl(mfp.index);
            }
            var type = item.type;
            _mfpTrigger("BeforeChange", [ mfp.currItem ? mfp.currItem.type : "", type ]);
            mfp.currItem = item;
            if (!mfp.currTemplate[type]) {
                var markup = mfp.st[type] ? mfp.st[type].markup : false;
                _mfpTrigger("FirstMarkupParse", markup);
                if (markup) {
                    mfp.currTemplate[type] = $(markup);
                } else {
                    mfp.currTemplate[type] = true;
                }
            }
            if (_prevContentType && _prevContentType !== item.type) {
                mfp.container.removeClass("mfp-" + _prevContentType + "-holder");
            }
            var newContent = mfp["get" + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
            mfp.appendContent(newContent, type);
            item.preloaded = true;
            _mfpTrigger(CHANGE_EVENT, item);
            _prevContentType = item.type;
            mfp.container.prepend(mfp.contentContainer);
            _mfpTrigger("AfterChange");
        },
        appendContent: function(newContent, type) {
            mfp.content = newContent;
            if (newContent) {
                if (mfp.st.showCloseBtn && mfp.st.closeBtnInside && mfp.currTemplate[type] === true) {
                    if (!mfp.content.find(".mfp-close").length) {
                        mfp.content.append(_getCloseBtn());
                    }
                } else {
                    mfp.content = newContent;
                }
            } else {
                mfp.content = "";
            }
            _mfpTrigger(BEFORE_APPEND_EVENT);
            mfp.container.addClass("mfp-" + type + "-holder");
            mfp.contentContainer.append(mfp.content);
        },
        parseEl: function(index) {
            var item = mfp.items[index], type = item.type;
            if (item.tagName) {
                item = {
                    el: $(item)
                };
            } else {
                item = {
                    data: item,
                    src: item.src
                };
            }
            if (item.el) {
                var types = mfp.types;
                for (var i = 0; i < types.length; i++) {
                    if (item.el.hasClass("mfp-" + types[i])) {
                        type = types[i];
                        break;
                    }
                }
                item.src = item.el.attr("data-mfp-src");
                if (!item.src) {
                    item.src = item.el.attr("href");
                }
            }
            item.type = type || mfp.st.type || "inline";
            item.index = index;
            item.parsed = true;
            mfp.items[index] = item;
            _mfpTrigger("ElementParse", item);
            return mfp.items[index];
        },
        addGroup: function(el, options) {
            var eHandler = function(e) {
                e.mfpEl = this;
                mfp._openClick(e, el, options);
            };
            if (!options) {
                options = {};
            }
            var eName = "click.magnificPopup";
            options.mainEl = el;
            if (options.items) {
                options.isObj = true;
                el.off(eName).on(eName, eHandler);
            } else {
                options.isObj = false;
                if (options.delegate) {
                    el.off(eName).on(eName, options.delegate, eHandler);
                } else {
                    options.items = el;
                    el.off(eName).on(eName, eHandler);
                }
            }
        },
        _openClick: function(e, el, options) {
            var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;
            if (!midClick && (e.which === 2 || e.ctrlKey || e.metaKey)) {
                return;
            }
            var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;
            if (disableOn) {
                if ($.isFunction(disableOn)) {
                    if (!disableOn.call(mfp)) {
                        return true;
                    }
                } else {
                    if (_window.width() < disableOn) {
                        return true;
                    }
                }
            }
            if (e.type) {
                e.preventDefault();
                if (mfp.isOpen) {
                    e.stopPropagation();
                }
            }
            options.el = $(e.mfpEl);
            if (options.delegate) {
                options.items = el.find(options.delegate);
            }
            mfp.open(options);
        },
        updateStatus: function(status, text) {
            if (mfp.preloader) {
                if (_prevStatus !== status) {
                    mfp.container.removeClass("mfp-s-" + _prevStatus);
                }
                if (!text && status === "loading") {
                    text = mfp.st.tLoading;
                }
                var data = {
                    status: status,
                    text: text
                };
                _mfpTrigger("UpdateStatus", data);
                status = data.status;
                text = data.text;
                mfp.preloader.html(text);
                mfp.preloader.find("a").on("click", function(e) {
                    e.stopImmediatePropagation();
                });
                mfp.container.addClass("mfp-s-" + status);
                _prevStatus = status;
            }
        },
        _checkIfClose: function(target) {
            if ($(target).hasClass(PREVENT_CLOSE_CLASS)) {
                return;
            }
            var closeOnContent = mfp.st.closeOnContentClick;
            var closeOnBg = mfp.st.closeOnBgClick;
            if (closeOnContent && closeOnBg) {
                return true;
            } else {
                if (!mfp.content || $(target).hasClass("mfp-close") || mfp.preloader && target === mfp.preloader[0]) {
                    return true;
                }
                if (target !== mfp.content[0] && !$.contains(mfp.content[0], target)) {
                    if (closeOnBg) {
                        if ($.contains(document, target)) {
                            return true;
                        }
                    }
                } else if (closeOnContent) {
                    return true;
                }
            }
            return false;
        },
        _addClassToMFP: function(cName) {
            mfp.bgOverlay.addClass(cName);
            mfp.wrap.addClass(cName);
        },
        _removeClassFromMFP: function(cName) {
            this.bgOverlay.removeClass(cName);
            mfp.wrap.removeClass(cName);
        },
        _hasScrollBar: function(winHeight) {
            return (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height());
        },
        _setFocus: function() {
            (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
        },
        _onFocusIn: function(e) {
            if (e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target)) {
                mfp._setFocus();
                return false;
            }
        },
        _parseMarkup: function(template, values, item) {
            var arr;
            if (item.data) {
                values = $.extend(item.data, values);
            }
            _mfpTrigger(MARKUP_PARSE_EVENT, [ template, values, item ]);
            $.each(values, function(key, value) {
                if (value === undefined || value === false) {
                    return true;
                }
                arr = key.split("_");
                if (arr.length > 1) {
                    var el = template.find(EVENT_NS + "-" + arr[0]);
                    if (el.length > 0) {
                        var attr = arr[1];
                        if (attr === "replaceWith") {
                            if (el[0] !== value[0]) {
                                el.replaceWith(value);
                            }
                        } else if (attr === "img") {
                            if (el.is("img")) {
                                el.attr("src", value);
                            } else {
                                el.replaceWith('<img src="' + value + '" class="' + el.attr("class") + '" />');
                            }
                        } else {
                            el.attr(arr[1], value);
                        }
                    }
                } else {
                    template.find(EVENT_NS + "-" + key).html(value);
                }
            });
        },
        _getScrollbarSize: function() {
            if (mfp.scrollbarSize === undefined) {
                var scrollDiv = document.createElement("div");
                scrollDiv.id = "mfp-sbm";
                scrollDiv.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;";
                document.body.appendChild(scrollDiv);
                mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
                document.body.removeChild(scrollDiv);
            }
            return mfp.scrollbarSize;
        }
    };
    $.magnificPopup = {
        instance: null,
        proto: MagnificPopup.prototype,
        modules: [],
        open: function(options, index) {
            _checkInstance();
            if (!options) {
                options = {};
            } else {
                options = $.extend(true, {}, options);
            }
            options.isObj = true;
            options.index = index || 0;
            return this.instance.open(options);
        },
        close: function() {
            return $.magnificPopup.instance && $.magnificPopup.instance.close();
        },
        registerModule: function(name, module) {
            if (module.options) {
                $.magnificPopup.defaults[name] = module.options;
            }
            $.extend(this.proto, module.proto);
            this.modules.push(name);
        },
        defaults: {
            disableOn: 0,
            key: null,
            midClick: false,
            mainClass: "",
            preloader: true,
            focus: "",
            closeOnContentClick: false,
            closeOnBgClick: true,
            closeBtnInside: true,
            showCloseBtn: true,
            enableEscapeKey: true,
            modal: false,
            alignTop: false,
            removalDelay: 0,
            fixedContentPos: "auto",
            fixedBgPos: "auto",
            overflowY: "auto",
            closeMarkup: '<button title="%title%" type="button" class="mfp-close">&times;</button>',
            tClose: "Close (Esc)",
            tLoading: "Loading..."
        }
    };
    $.fn.magnificPopup = function(options) {
        _checkInstance();
        var jqEl = $(this);
        if (typeof options === "string") {
            if (options === "open") {
                var items, itemOpts = _isJQ ? jqEl.data("magnificPopup") : jqEl[0].magnificPopup, index = parseInt(arguments[1], 10) || 0;
                if (itemOpts.items) {
                    items = itemOpts.items[index];
                } else {
                    items = jqEl;
                    if (itemOpts.delegate) {
                        items = items.find(itemOpts.delegate);
                    }
                    items = items.eq(index);
                }
                mfp._openClick({
                    mfpEl: items
                }, jqEl, itemOpts);
            } else {
                if (mfp.isOpen) mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
            }
        } else {
            options = $.extend(true, {}, options);
            if (_isJQ) {
                jqEl.data("magnificPopup", options);
            } else {
                jqEl[0].magnificPopup = options;
            }
            mfp.addGroup(jqEl, options);
        }
        return jqEl;
    };
    var INLINE_NS = "inline", _hiddenClass, _inlinePlaceholder, _lastInlineElement, _putInlineElementsBack = function() {
        if (_lastInlineElement) {
            _inlinePlaceholder.after(_lastInlineElement.addClass(_hiddenClass)).detach();
            _lastInlineElement = null;
        }
    };
    $.magnificPopup.registerModule(INLINE_NS, {
        options: {
            hiddenClass: "hide",
            markup: "",
            tNotFound: "Content not found"
        },
        proto: {
            initInline: function() {
                mfp.types.push(INLINE_NS);
                _mfpOn(CLOSE_EVENT + "." + INLINE_NS, function() {
                    _putInlineElementsBack();
                });
            },
            getInline: function(item, template) {
                _putInlineElementsBack();
                if (item.src) {
                    var inlineSt = mfp.st.inline, el = $(item.src);
                    if (el.length) {
                        var parent = el[0].parentNode;
                        if (parent && parent.tagName) {
                            if (!_inlinePlaceholder) {
                                _hiddenClass = inlineSt.hiddenClass;
                                _inlinePlaceholder = _getEl(_hiddenClass);
                                _hiddenClass = "mfp-" + _hiddenClass;
                            }
                            _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
                        }
                        mfp.updateStatus("ready");
                    } else {
                        mfp.updateStatus("error", inlineSt.tNotFound);
                        el = $("<div>");
                    }
                    item.inlineElement = el;
                    return el;
                }
                mfp.updateStatus("ready");
                mfp._parseMarkup(template, {}, item);
                return template;
            }
        }
    });
    var AJAX_NS = "ajax", _ajaxCur, _removeAjaxCursor = function() {
        if (_ajaxCur) {
            _body.removeClass(_ajaxCur);
        }
    }, _destroyAjaxRequest = function() {
        _removeAjaxCursor();
        if (mfp.req) {
            mfp.req.abort();
        }
    };
    $.magnificPopup.registerModule(AJAX_NS, {
        options: {
            settings: null,
            cursor: "mfp-ajax-cur",
            tError: '<a href="%url%">The content</a> could not be loaded.'
        },
        proto: {
            initAjax: function() {
                mfp.types.push(AJAX_NS);
                _ajaxCur = mfp.st.ajax.cursor;
                _mfpOn(CLOSE_EVENT + "." + AJAX_NS, _destroyAjaxRequest);
                _mfpOn("BeforeChange." + AJAX_NS, _destroyAjaxRequest);
            },
            getAjax: function(item) {
                if (_ajaxCur) _body.addClass(_ajaxCur);
                mfp.updateStatus("loading");
                var opts = $.extend({
                    url: item.src,
                    success: function(data, textStatus, jqXHR) {
                        var temp = {
                            data: data,
                            xhr: jqXHR
                        };
                        _mfpTrigger("ParseAjax", temp);
                        mfp.appendContent($(temp.data), AJAX_NS);
                        item.finished = true;
                        _removeAjaxCursor();
                        mfp._setFocus();
                        setTimeout(function() {
                            mfp.wrap.addClass(READY_CLASS);
                        }, 16);
                        mfp.updateStatus("ready");
                        _mfpTrigger("AjaxContentAdded");
                    },
                    error: function() {
                        _removeAjaxCursor();
                        item.finished = item.loadError = true;
                        mfp.updateStatus("error", mfp.st.ajax.tError.replace("%url%", item.src));
                    }
                }, mfp.st.ajax.settings);
                mfp.req = $.ajax(opts);
                return "";
            }
        }
    });
    var _imgInterval, _getTitle = function(item) {
        if (item.data && item.data.title !== undefined) return item.data.title;
        var src = mfp.st.image.titleSrc;
        if (src) {
            if ($.isFunction(src)) {
                return src.call(mfp, item);
            } else if (item.el) {
                return item.el.attr(src) || "";
            }
        }
        return "";
    };
    $.magnificPopup.registerModule("image", {
        options: {
            markup: '<div class="mfp-figure">' + '<div class="mfp-close"></div>' + "<figure>" + '<div class="mfp-img"></div>' + "<figcaption>" + '<div class="mfp-bottom-bar">' + '<div class="mfp-title"></div>' + '<div class="mfp-counter"></div>' + "</div>" + "</figcaption>" + "</figure>" + "</div>",
            cursor: "mfp-zoom-out-cur",
            titleSrc: "title",
            verticalFit: true,
            tError: '<a href="%url%">The image</a> could not be loaded.'
        },
        proto: {
            initImage: function() {
                var imgSt = mfp.st.image, ns = ".image";
                mfp.types.push("image");
                _mfpOn(OPEN_EVENT + ns, function() {
                    if (mfp.currItem.type === "image" && imgSt.cursor) {
                        _body.addClass(imgSt.cursor);
                    }
                });
                _mfpOn(CLOSE_EVENT + ns, function() {
                    if (imgSt.cursor) {
                        _body.removeClass(imgSt.cursor);
                    }
                    _window.off("resize" + EVENT_NS);
                });
                _mfpOn("Resize" + ns, mfp.resizeImage);
                if (mfp.isLowIE) {
                    _mfpOn("AfterChange", mfp.resizeImage);
                }
            },
            resizeImage: function() {
                var item = mfp.currItem;
                if (!item || !item.img) return;
                if (mfp.st.image.verticalFit) {
                    var decr = 0;
                    if (mfp.isLowIE) {
                        decr = parseInt(item.img.css("padding-top"), 10) + parseInt(item.img.css("padding-bottom"), 10);
                    }
                    item.img.css("max-height", mfp.wH - decr);
                }
            },
            _onImageHasSize: function(item) {
                if (item.img) {
                    item.hasSize = true;
                    if (_imgInterval) {
                        clearInterval(_imgInterval);
                    }
                    item.isCheckingImgSize = false;
                    _mfpTrigger("ImageHasSize", item);
                    if (item.imgHidden) {
                        if (mfp.content) mfp.content.removeClass("mfp-loading");
                        item.imgHidden = false;
                    }
                }
            },
            findImageSize: function(item) {
                var counter = 0, img = item.img[0], mfpSetInterval = function(delay) {
                    if (_imgInterval) {
                        clearInterval(_imgInterval);
                    }
                    _imgInterval = setInterval(function() {
                        if (img.naturalWidth > 0) {
                            mfp._onImageHasSize(item);
                            return;
                        }
                        if (counter > 200) {
                            clearInterval(_imgInterval);
                        }
                        counter++;
                        if (counter === 3) {
                            mfpSetInterval(10);
                        } else if (counter === 40) {
                            mfpSetInterval(50);
                        } else if (counter === 100) {
                            mfpSetInterval(500);
                        }
                    }, delay);
                };
                mfpSetInterval(1);
            },
            getImage: function(item, template) {
                var guard = 0, onLoadComplete = function() {
                    if (item) {
                        if (item.img[0].complete) {
                            item.img.off(".mfploader");
                            if (item === mfp.currItem) {
                                mfp._onImageHasSize(item);
                                mfp.updateStatus("ready");
                            }
                            item.hasSize = true;
                            item.loaded = true;
                            _mfpTrigger("ImageLoadComplete");
                        } else {
                            guard++;
                            if (guard < 200) {
                                setTimeout(onLoadComplete, 100);
                            } else {
                                onLoadError();
                            }
                        }
                    }
                }, onLoadError = function() {
                    if (item) {
                        item.img.off(".mfploader");
                        if (item === mfp.currItem) {
                            mfp._onImageHasSize(item);
                            mfp.updateStatus("error", imgSt.tError.replace("%url%", item.src));
                        }
                        item.hasSize = true;
                        item.loaded = true;
                        item.loadError = true;
                    }
                }, imgSt = mfp.st.image;
                var el = template.find(".mfp-img");
                if (el.length) {
                    var img = document.createElement("img");
                    img.className = "mfp-img";
                    item.img = $(img).on("load.mfploader", onLoadComplete).on("error.mfploader", onLoadError);
                    img.src = item.src;
                    if (el.is("img")) {
                        item.img = item.img.clone();
                    }
                    if (item.img[0].naturalWidth > 0) {
                        item.hasSize = true;
                    }
                }
                mfp._parseMarkup(template, {
                    title: _getTitle(item),
                    img_replaceWith: item.img
                }, item);
                mfp.resizeImage();
                if (item.hasSize) {
                    if (_imgInterval) clearInterval(_imgInterval);
                    if (item.loadError) {
                        template.addClass("mfp-loading");
                        mfp.updateStatus("error", imgSt.tError.replace("%url%", item.src));
                    } else {
                        template.removeClass("mfp-loading");
                        mfp.updateStatus("ready");
                    }
                    return template;
                }
                mfp.updateStatus("loading");
                item.loading = true;
                if (!item.hasSize) {
                    item.imgHidden = true;
                    template.addClass("mfp-loading");
                    mfp.findImageSize(item);
                }
                return template;
            }
        }
    });
    var hasMozTransform, getHasMozTransform = function() {
        if (hasMozTransform === undefined) {
            hasMozTransform = document.createElement("p").style.MozTransform !== undefined;
        }
        return hasMozTransform;
    };
    $.magnificPopup.registerModule("zoom", {
        options: {
            enabled: false,
            easing: "ease-in-out",
            duration: 300,
            opener: function(element) {
                return element.is("img") ? element : element.find("img");
            }
        },
        proto: {
            initZoom: function() {
                var zoomSt = mfp.st.zoom, ns = ".zoom", image;
                if (!zoomSt.enabled || !mfp.supportsTransition) {
                    return;
                }
                var duration = zoomSt.duration, getElToAnimate = function(image) {
                    var newImg = image.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image"), transition = "all " + zoomSt.duration / 1e3 + "s " + zoomSt.easing, cssObj = {
                        position: "fixed",
                        zIndex: 9999,
                        left: 0,
                        top: 0,
                        "-webkit-backface-visibility": "hidden"
                    }, t = "transition";
                    cssObj["-webkit-" + t] = cssObj["-moz-" + t] = cssObj["-o-" + t] = cssObj[t] = transition;
                    newImg.css(cssObj);
                    return newImg;
                }, showMainContent = function() {
                    mfp.content.css("visibility", "visible");
                }, openTimeout, animatedImg;
                _mfpOn("BuildControls" + ns, function() {
                    if (mfp._allowZoom()) {
                        clearTimeout(openTimeout);
                        mfp.content.css("visibility", "hidden");
                        image = mfp._getItemToZoom();
                        if (!image) {
                            showMainContent();
                            return;
                        }
                        animatedImg = getElToAnimate(image);
                        animatedImg.css(mfp._getOffset());
                        mfp.wrap.append(animatedImg);
                        openTimeout = setTimeout(function() {
                            animatedImg.css(mfp._getOffset(true));
                            openTimeout = setTimeout(function() {
                                showMainContent();
                                setTimeout(function() {
                                    animatedImg.remove();
                                    image = animatedImg = null;
                                    _mfpTrigger("ZoomAnimationEnded");
                                }, 16);
                            }, duration);
                        }, 16);
                    }
                });
                _mfpOn(BEFORE_CLOSE_EVENT + ns, function() {
                    if (mfp._allowZoom()) {
                        clearTimeout(openTimeout);
                        mfp.st.removalDelay = duration;
                        if (!image) {
                            image = mfp._getItemToZoom();
                            if (!image) {
                                return;
                            }
                            animatedImg = getElToAnimate(image);
                        }
                        animatedImg.css(mfp._getOffset(true));
                        mfp.wrap.append(animatedImg);
                        mfp.content.css("visibility", "hidden");
                        setTimeout(function() {
                            animatedImg.css(mfp._getOffset());
                        }, 16);
                    }
                });
                _mfpOn(CLOSE_EVENT + ns, function() {
                    if (mfp._allowZoom()) {
                        showMainContent();
                        if (animatedImg) {
                            animatedImg.remove();
                        }
                        image = null;
                    }
                });
            },
            _allowZoom: function() {
                return mfp.currItem.type === "image";
            },
            _getItemToZoom: function() {
                if (mfp.currItem.hasSize) {
                    return mfp.currItem.img;
                } else {
                    return false;
                }
            },
            _getOffset: function(isLarge) {
                var el;
                if (isLarge) {
                    el = mfp.currItem.img;
                } else {
                    el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
                }
                var offset = el.offset();
                var paddingTop = parseInt(el.css("padding-top"), 10);
                var paddingBottom = parseInt(el.css("padding-bottom"), 10);
                offset.top -= $(window).scrollTop() - paddingTop;
                var obj = {
                    width: el.width(),
                    height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
                };
                if (getHasMozTransform()) {
                    obj["-moz-transform"] = obj["transform"] = "translate(" + offset.left + "px," + offset.top + "px)";
                } else {
                    obj.left = offset.left;
                    obj.top = offset.top;
                }
                return obj;
            }
        }
    });
    var IFRAME_NS = "iframe", _emptyPage = "//about:blank", _fixIframeBugs = function(isShowing) {
        if (mfp.currTemplate[IFRAME_NS]) {
            var el = mfp.currTemplate[IFRAME_NS].find("iframe");
            if (el.length) {
                if (!isShowing) {
                    el[0].src = _emptyPage;
                }
                if (mfp.isIE8) {
                    el.css("display", isShowing ? "block" : "none");
                }
            }
        }
    };
    $.magnificPopup.registerModule(IFRAME_NS, {
        options: {
            markup: '<div class="mfp-iframe-scaler">' + '<div class="mfp-close"></div>' + '<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>' + "</div>",
            srcAction: "iframe_src",
            patterns: {
                youtube: {
                    index: "youtube.com",
                    id: "v=",
                    src: "//www.youtube.com/embed/%id%?autoplay=1"
                },
                vimeo: {
                    index: "vimeo.com/",
                    id: "/",
                    src: "//player.vimeo.com/video/%id%?autoplay=1"
                },
                gmaps: {
                    index: "//maps.google.",
                    src: "%id%&output=embed"
                }
            }
        },
        proto: {
            initIframe: function() {
                mfp.types.push(IFRAME_NS);
                _mfpOn("BeforeChange", function(e, prevType, newType) {
                    if (prevType !== newType) {
                        if (prevType === IFRAME_NS) {
                            _fixIframeBugs();
                        } else if (newType === IFRAME_NS) {
                            _fixIframeBugs(true);
                        }
                    }
                });
                _mfpOn(CLOSE_EVENT + "." + IFRAME_NS, function() {
                    _fixIframeBugs();
                });
            },
            getIframe: function(item, template) {
                var embedSrc = item.src;
                var iframeSt = mfp.st.iframe;
                $.each(iframeSt.patterns, function() {
                    if (embedSrc.indexOf(this.index) > -1) {
                        if (this.id) {
                            if (typeof this.id === "string") {
                                embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id) + this.id.length, embedSrc.length);
                            } else {
                                embedSrc = this.id.call(this, embedSrc);
                            }
                        }
                        embedSrc = this.src.replace("%id%", embedSrc);
                        return false;
                    }
                });
                var dataObj = {};
                if (iframeSt.srcAction) {
                    dataObj[iframeSt.srcAction] = embedSrc;
                }
                mfp._parseMarkup(template, dataObj, item);
                mfp.updateStatus("ready");
                return template;
            }
        }
    });
    var _getLoopedId = function(index) {
        var numSlides = mfp.items.length;
        if (index > numSlides - 1) {
            return index - numSlides;
        } else if (index < 0) {
            return numSlides + index;
        }
        return index;
    }, _replaceCurrTotal = function(text, curr, total) {
        return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
    };
    $.magnificPopup.registerModule("gallery", {
        options: {
            enabled: false,
            arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
            preload: [ 0, 2 ],
            navigateByImgClick: true,
            arrows: true,
            tPrev: "Previous (Left arrow key)",
            tNext: "Next (Right arrow key)",
            tCounter: "%curr% of %total%"
        },
        proto: {
            initGallery: function() {
                var gSt = mfp.st.gallery, ns = ".mfp-gallery", supportsFastClick = Boolean($.fn.mfpFastClick);
                mfp.direction = true;
                if (!gSt || !gSt.enabled) return false;
                _wrapClasses += " mfp-gallery";
                _mfpOn(OPEN_EVENT + ns, function() {
                    if (gSt.navigateByImgClick) {
                        mfp.wrap.on("click" + ns, ".mfp-img", function() {
                            if (mfp.items.length > 1) {
                                mfp.next();
                                return false;
                            }
                        });
                    }
                    _document.on("keydown" + ns, function(e) {
                        if (e.keyCode === 37) {
                            mfp.prev();
                        } else if (e.keyCode === 39) {
                            mfp.next();
                        }
                    });
                });
                _mfpOn("UpdateStatus" + ns, function(e, data) {
                    if (data.text) {
                        data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
                    }
                });
                _mfpOn(MARKUP_PARSE_EVENT + ns, function(e, element, values, item) {
                    var l = mfp.items.length;
                    values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : "";
                });
                _mfpOn("BuildControls" + ns, function() {
                    if (mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
                        var markup = gSt.arrowMarkup, arrowLeft = mfp.arrowLeft = $(markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, "left")).addClass(PREVENT_CLOSE_CLASS), arrowRight = mfp.arrowRight = $(markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, "right")).addClass(PREVENT_CLOSE_CLASS);
                        var eName = supportsFastClick ? "mfpFastClick" : "click";
                        arrowLeft[eName](function() {
                            mfp.prev();
                        });
                        arrowRight[eName](function() {
                            mfp.next();
                        });
                        if (mfp.isIE7) {
                            _getEl("b", arrowLeft[0], false, true);
                            _getEl("a", arrowLeft[0], false, true);
                            _getEl("b", arrowRight[0], false, true);
                            _getEl("a", arrowRight[0], false, true);
                        }
                        mfp.container.append(arrowLeft.add(arrowRight));
                    }
                });
                _mfpOn(CHANGE_EVENT + ns, function() {
                    if (mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);
                    mfp._preloadTimeout = setTimeout(function() {
                        mfp.preloadNearbyImages();
                        mfp._preloadTimeout = null;
                    }, 16);
                });
                _mfpOn(CLOSE_EVENT + ns, function() {
                    _document.off(ns);
                    mfp.wrap.off("click" + ns);
                    if (mfp.arrowLeft && supportsFastClick) {
                        mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick();
                    }
                    mfp.arrowRight = mfp.arrowLeft = null;
                });
            },
            next: function() {
                mfp.direction = true;
                mfp.index = _getLoopedId(mfp.index + 1);
                mfp.updateItemHTML();
            },
            prev: function() {
                mfp.direction = false;
                mfp.index = _getLoopedId(mfp.index - 1);
                mfp.updateItemHTML();
            },
            goTo: function(newIndex) {
                mfp.direction = newIndex >= mfp.index;
                mfp.index = newIndex;
                mfp.updateItemHTML();
            },
            preloadNearbyImages: function() {
                var p = mfp.st.gallery.preload, preloadBefore = Math.min(p[0], mfp.items.length), preloadAfter = Math.min(p[1], mfp.items.length), i;
                for (i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
                    mfp._preloadItem(mfp.index + i);
                }
                for (i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
                    mfp._preloadItem(mfp.index - i);
                }
            },
            _preloadItem: function(index) {
                index = _getLoopedId(index);
                if (mfp.items[index].preloaded) {
                    return;
                }
                var item = mfp.items[index];
                if (!item.parsed) {
                    item = mfp.parseEl(index);
                }
                _mfpTrigger("LazyLoad", item);
                if (item.type === "image") {
                    item.img = $('<img class="mfp-img" />').on("load.mfploader", function() {
                        item.hasSize = true;
                    }).on("error.mfploader", function() {
                        item.hasSize = true;
                        item.loadError = true;
                        _mfpTrigger("LazyLoadError", item);
                    }).attr("src", item.src);
                }
                item.preloaded = true;
            }
        }
    });
    var RETINA_NS = "retina";
    $.magnificPopup.registerModule(RETINA_NS, {
        options: {
            replaceSrc: function(item) {
                return item.src.replace(/\.\w+$/, function(m) {
                    return "@2x" + m;
                });
            },
            ratio: 1
        },
        proto: {
            initRetina: function() {
                if (window.devicePixelRatio > 1) {
                    var st = mfp.st.retina, ratio = st.ratio;
                    ratio = !isNaN(ratio) ? ratio : ratio();
                    if (ratio > 1) {
                        _mfpOn("ImageHasSize" + "." + RETINA_NS, function(e, item) {
                            item.img.css({
                                "max-width": item.img[0].naturalWidth / ratio,
                                width: "100%"
                            });
                        });
                        _mfpOn("ElementParse" + "." + RETINA_NS, function(e, item) {
                            item.src = st.replaceSrc(item, ratio);
                        });
                    }
                }
            }
        }
    });
    (function() {
        var ghostClickDelay = 1e3, supportsTouch = "ontouchstart" in window, unbindTouchMove = function() {
            _window.off("touchmove" + ns + " touchend" + ns);
        }, eName = "mfpFastClick", ns = "." + eName;
        $.fn.mfpFastClick = function(callback) {
            return $(this).each(function() {
                var elem = $(this), lock;
                if (supportsTouch) {
                    var timeout, startX, startY, pointerMoved, point, numPointers;
                    elem.on("touchstart" + ns, function(e) {
                        pointerMoved = false;
                        numPointers = 1;
                        point = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0];
                        startX = point.clientX;
                        startY = point.clientY;
                        _window.on("touchmove" + ns, function(e) {
                            point = e.originalEvent ? e.originalEvent.touches : e.touches;
                            numPointers = point.length;
                            point = point[0];
                            if (Math.abs(point.clientX - startX) > 10 || Math.abs(point.clientY - startY) > 10) {
                                pointerMoved = true;
                                unbindTouchMove();
                            }
                        }).on("touchend" + ns, function(e) {
                            unbindTouchMove();
                            if (pointerMoved || numPointers > 1) {
                                return;
                            }
                            lock = true;
                            e.preventDefault();
                            clearTimeout(timeout);
                            timeout = setTimeout(function() {
                                lock = false;
                            }, ghostClickDelay);
                            callback();
                        });
                    });
                }
                elem.on("click" + ns, function() {
                    if (!lock) {
                        callback();
                    }
                });
            });
        };
        $.fn.destroyMfpFastClick = function() {
            $(this).off("touchstart" + ns + " click" + ns);
            if (supportsTouch) _window.off("touchmove" + ns + " touchend" + ns);
        };
    })();
    _checkInstance();
})(window.jQuery || window.Zepto);

(function(undefined) {
    var moment, VERSION = "2.7.0", globalScope = typeof global !== "undefined" ? global : this, oldGlobalMoment, round = Math.round, i, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, locales = {}, momentProperties = [], hasModule = typeof module !== "undefined" && module.exports, aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenOneToFourDigits = /\d{1,4}/, parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, parseTokenDigits = /\d+/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, parseTokenT = /T/i, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, parseTokenOrdinal = /\d{1,2}/, parseTokenOneDigit = /\d/, parseTokenTwoDigits = /\d\d/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{4}/, parseTokenSixDigits = /[+-]?\d{6}/, parseTokenSignedNumber = /[+-]?\d+/, isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/ ], [ "YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d{2}/ ], [ "YYYY-DDD", /\d{4}-\d{3}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ], parseTimezoneChunker = /([\+\-]|\d\d)/gi, proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {
        Milliseconds: 1,
        Seconds: 1e3,
        Minutes: 6e4,
        Hours: 36e5,
        Days: 864e5,
        Months: 2592e6,
        Years: 31536e6
    }, unitAliases = {
        ms: "millisecond",
        s: "second",
        m: "minute",
        h: "hour",
        d: "day",
        D: "date",
        w: "week",
        W: "isoWeek",
        M: "month",
        Q: "quarter",
        y: "year",
        DDD: "dayOfYear",
        e: "weekday",
        E: "isoWeekday",
        gg: "weekYear",
        GG: "isoWeekYear"
    }, camelFunctions = {
        dayofyear: "dayOfYear",
        isoweekday: "isoWeekday",
        isoweek: "isoWeek",
        weekyear: "weekYear",
        isoweekyear: "isoWeekYear"
    }, formatFunctions = {}, relativeTimeThresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    }, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
        M: function() {
            return this.month() + 1;
        },
        MMM: function(format) {
            return this.localeData().monthsShort(this, format);
        },
        MMMM: function(format) {
            return this.localeData().months(this, format);
        },
        D: function() {
            return this.date();
        },
        DDD: function() {
            return this.dayOfYear();
        },
        d: function() {
            return this.day();
        },
        dd: function(format) {
            return this.localeData().weekdaysMin(this, format);
        },
        ddd: function(format) {
            return this.localeData().weekdaysShort(this, format);
        },
        dddd: function(format) {
            return this.localeData().weekdays(this, format);
        },
        w: function() {
            return this.week();
        },
        W: function() {
            return this.isoWeek();
        },
        YY: function() {
            return leftZeroFill(this.year() % 100, 2);
        },
        YYYY: function() {
            return leftZeroFill(this.year(), 4);
        },
        YYYYY: function() {
            return leftZeroFill(this.year(), 5);
        },
        YYYYYY: function() {
            var y = this.year(), sign = y >= 0 ? "+" : "-";
            return sign + leftZeroFill(Math.abs(y), 6);
        },
        gg: function() {
            return leftZeroFill(this.weekYear() % 100, 2);
        },
        gggg: function() {
            return leftZeroFill(this.weekYear(), 4);
        },
        ggggg: function() {
            return leftZeroFill(this.weekYear(), 5);
        },
        GG: function() {
            return leftZeroFill(this.isoWeekYear() % 100, 2);
        },
        GGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 4);
        },
        GGGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 5);
        },
        e: function() {
            return this.weekday();
        },
        E: function() {
            return this.isoWeekday();
        },
        a: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), true);
        },
        A: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), false);
        },
        H: function() {
            return this.hours();
        },
        h: function() {
            return this.hours() % 12 || 12;
        },
        m: function() {
            return this.minutes();
        },
        s: function() {
            return this.seconds();
        },
        S: function() {
            return toInt(this.milliseconds() / 100);
        },
        SS: function() {
            return leftZeroFill(toInt(this.milliseconds() / 10), 2);
        },
        SSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        SSSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        Z: function() {
            var a = -this.zone(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
        },
        ZZ: function() {
            var a = -this.zone(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
        },
        z: function() {
            return this.zoneAbbr();
        },
        zz: function() {
            return this.zoneName();
        },
        X: function() {
            return this.unix();
        },
        Q: function() {
            return this.quarter();
        }
    }, deprecations = {}, lists = [ "months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin" ];
    function dfl(a, b, c) {
        switch (arguments.length) {
          case 2:
            return a != null ? a : b;

          case 3:
            return a != null ? a : b != null ? b : c;

          default:
            throw new Error("Implement me");
        }
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }
    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }
    function padToken(func, count) {
        return function(a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function(a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }
    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
    function Locale() {}
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = moment.localeData();
        this._bubble();
    }
    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }
        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }
        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== "undefined") {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== "undefined") {
            to._i = from._i;
        }
        if (typeof from._f !== "undefined") {
            to._f = from._f;
        }
        if (typeof from._l !== "undefined") {
            to._l = from._l;
        }
        if (typeof from._strict !== "undefined") {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== "undefined") {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== "undefined") {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== "undefined") {
            to._offset = from._offset;
        }
        if (typeof from._pf !== "undefined") {
            to._pf = from._pf;
        }
        if (typeof from._locale !== "undefined") {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== "undefined") {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }
    function leftZeroFill(number, targetLength, forceSign) {
        var output = "" + Math.abs(number), sign = number >= 0;
        while (output.length < targetLength) {
            output = "0" + output;
        }
        return (sign ? forceSign ? "+" : "" : "-") + output;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
                tmp = val;
                val = period;
                period = tmp;
            }
            val = typeof val === "string" ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, "Date", rawGetter(mom, "Date") + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, "Month") + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }
    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
    }
    function isDate(input) {
        return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date;
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    function makeList(field) {
        var count, setter;
        if (field.indexOf("week") === 0) {
            count = 7;
            setter = "day";
        } else if (field.indexOf("month") === 0) {
            count = 12;
            setter = "month";
        } else {
            return;
        }
        moment[field] = function(format, index) {
            var i, getter, method = moment._locale[field], results = [];
            if (typeof format === "number") {
                index = format;
                format = undefined;
            }
            getter = function(i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || "");
            };
            if (index != null) {
                return getter(index);
            } else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }
        return value;
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([ year, 11, 31 + dow - doy ]), dow, doy).week;
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            m._pf.overflow = overflow;
        }
    }
    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;
            if (m._strict) {
                m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require("./locale/" + name);
                moment.locale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) : moment(input).local();
    }
    extend(Locale.prototype, {
        set: function(config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === "function") {
                    this[i] = prop;
                } else {
                    this["_" + i] = prop;
                }
            }
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
            return this._months[m.month()];
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
            return this._monthsShort[m.month()];
        },
        monthsParse: function(monthName) {
            var i, mom, regex;
            if (!this._monthsParse) {
                this._monthsParse = [];
            }
            for (i = 0; i < 12; i++) {
                if (!this._monthsParse[i]) {
                    mom = moment.utc([ 2e3, i ]);
                    regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                    this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
            return this._weekdays[m.day()];
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
            return this._weekdaysShort[m.day()];
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
            return this._weekdaysMin[m.day()];
        },
        weekdaysParse: function(weekdayName) {
            var i, mom, regex;
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }
            for (i = 0; i < 7; i++) {
                if (!this._weekdaysParse[i]) {
                    mom = moment([ 2e3, 1 ]).day(i);
                    regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                    this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },
        _longDateFormat: {
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY LT",
            LLLL: "dddd, MMMM D, YYYY LT"
        },
        longDateFormat: function(key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },
        isPM: function(input) {
            return (input + "").toLowerCase().charAt(0) === "p";
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "pm" : "PM";
            } else {
                return isLower ? "am" : "AM";
            }
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function(key, mom) {
            var output = this._calendar[key];
            return typeof output === "function" ? output.apply(mom) : output;
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        },
        pastFuture: function(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
        },
        ordinal: function(number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal: "%d",
        preparse: function(string) {
            return string;
        },
        postformat: function(string) {
            return string;
        },
        week: function(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },
        _week: {
            dow: 0,
            doy: 6
        },
        _invalidDate: "Invalid date",
        invalidDate: function() {
            return this._invalidDate;
        }
    });
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
          case "Q":
            return parseTokenOneDigit;

          case "DDDD":
            return parseTokenThreeDigits;

          case "YYYY":
          case "GGGG":
          case "gggg":
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;

          case "Y":
          case "G":
          case "g":
            return parseTokenSignedNumber;

          case "YYYYYY":
          case "YYYYY":
          case "GGGGG":
          case "ggggg":
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;

          case "S":
            if (strict) {
                return parseTokenOneDigit;
            }

          case "SS":
            if (strict) {
                return parseTokenTwoDigits;
            }

          case "SSS":
            if (strict) {
                return parseTokenThreeDigits;
            }

          case "DDD":
            return parseTokenOneToThreeDigits;

          case "MMM":
          case "MMMM":
          case "dd":
          case "ddd":
          case "dddd":
            return parseTokenWord;

          case "a":
          case "A":
            return config._locale._meridiemParse;

          case "X":
            return parseTokenTimestampMs;

          case "Z":
          case "ZZ":
            return parseTokenTimezone;

          case "T":
            return parseTokenT;

          case "SSSS":
            return parseTokenDigits;

          case "MM":
          case "DD":
          case "YY":
          case "GG":
          case "gg":
          case "HH":
          case "hh":
          case "mm":
          case "ss":
          case "ww":
          case "WW":
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;

          case "M":
          case "D":
          case "d":
          case "H":
          case "h":
          case "m":
          case "s":
          case "w":
          case "W":
          case "e":
          case "E":
            return parseTokenOneOrTwoDigits;

          case "Do":
            return parseTokenOrdinal;

          default:
            a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"));
            return a;
        }
    }
    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = string.match(parseTokenTimezone) || [], tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [], parts = (tzChunk + "").match(parseTimezoneChunker) || [ "-", 0, 0 ], minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? -minutes : minutes;
    }
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
          case "Q":
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;

          case "M":
          case "MM":
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;

          case "MMM":
          case "MMMM":
            a = config._locale.monthsParse(input);
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;

          case "D":
          case "DD":
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;

          case "Do":
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input, 10));
            }
            break;

          case "DDD":
          case "DDDD":
            if (input != null) {
                config._dayOfYear = toInt(input);
            }
            break;

          case "YY":
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;

          case "YYYY":
          case "YYYYY":
          case "YYYYYY":
            datePartArray[YEAR] = toInt(input);
            break;

          case "a":
          case "A":
            config._isPm = config._locale.isPM(input);
            break;

          case "H":
          case "HH":
          case "h":
          case "hh":
            datePartArray[HOUR] = toInt(input);
            break;

          case "m":
          case "mm":
            datePartArray[MINUTE] = toInt(input);
            break;

          case "s":
          case "ss":
            datePartArray[SECOND] = toInt(input);
            break;

          case "S":
          case "SS":
          case "SSS":
          case "SSSS":
            datePartArray[MILLISECOND] = toInt(("0." + input) * 1e3);
            break;

          case "X":
            config._d = new Date(parseFloat(input) * 1e3);
            break;

          case "Z":
          case "ZZ":
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;

          case "dd":
          case "ddd":
          case "dddd":
            a = config._locale.weekdaysParse(input);
            if (a != null) {
                config._w = config._w || {};
                config._w["d"] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;

          case "w":
          case "ww":
          case "W":
          case "WW":
          case "d":
          case "e":
          case "E":
            token = token.substr(0, 1);

          case "gggg":
          case "GGGG":
          case "GGGGG":
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;

          case "gg":
          case "GG":
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
            } else {
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }
            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }
    }
    function dateFromObject(config) {
        var normalizedInput;
        if (config._d) {
            return;
        }
        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [ normalizedInput.year, normalizedInput.month, normalizedInput.day, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond ];
        dateFromConfig(config);
    }
    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ];
        } else {
            return [ now.getFullYear(), now.getMonth(), now.getDate() ];
        }
    }
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }
        config._a = [];
        config._pf.empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                } else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }
        dateFromConfig(config);
        checkOverflow(config);
    }
    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);
            if (!isValid(tempConfig)) {
                continue;
            }
            currentScore += tempConfig._pf.charsLeftOver;
            currentScore += tempConfig._pf.unusedTokens.length * 10;
            tempConfig._pf.score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function parseISO(config) {
        var i, l, string = config._i, match = isoRegex.exec(string);
        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }
    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === "string") {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (typeof input === "object") {
            dateFromObject(config);
        } else if (typeof input === "number") {
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }
    function makeDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }
    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    function parseWeekday(input, locale) {
        if (typeof input === "string") {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            } else {
                input = locale.weekdaysParse(input);
                if (typeof input !== "number") {
                    return null;
                }
            }
        }
        return input;
    }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), args = seconds < relativeTimeThresholds.s && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < relativeTimeThresholds.m && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < relativeTimeThresholds.h && [ "hh", hours ] || days === 1 && [ "d" ] || days < relativeTimeThresholds.d && [ "dd", days ] || months === 1 && [ "M" ] || months < relativeTimeThresholds.M && [ "MM", months ] || years === 1 && [ "y" ] || [ "yy", years ];
        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }
        adjustedMoment = moment(mom).add(daysToDayOfWeek, "d");
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }
    function makeMoment(config) {
        var input = config._i, format = config._f;
        config._locale = config._locale || moment.localeData(config._l);
        if (input === null || format === undefined && input === "") {
            return moment.invalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
        }
        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }
        return new Moment(config);
    }
    moment = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();
        return makeMoment(c);
    };
    moment.suppressDeprecationWarnings = false;
    moment.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " + "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.", function(config) {
        config._d = new Date(config._i);
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    moment.min = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    };
    moment.max = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    };
    moment.utc = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();
        return makeMoment(c).utc();
    };
    moment.unix = function(input) {
        return moment(input * 1e3);
    };
    moment.duration = function(input, key) {
        var duration = input, match = null, sign, ret, parseIso, diffRes;
        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === "number") {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            parseIso = function(inp) {
                var res = inp && parseFloat(inp.replace(",", "."));
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (moment.isDuration(input) && input.hasOwnProperty("_locale")) {
            ret._locale = input._locale;
        }
        return ret;
    };
    moment.version = VERSION;
    moment.defaultFormat = isoFormat;
    moment.ISO_8601 = function() {};
    moment.momentProperties = momentProperties;
    moment.updateOffset = function() {};
    moment.relativeTimeThreshold = function(threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };
    moment.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", function(key, value) {
        return moment.locale(key, value);
    });
    moment.locale = function(key, values) {
        var data;
        if (key) {
            if (typeof values !== "undefined") {
                data = moment.defineLocale(key, values);
            } else {
                data = moment.localeData(key);
            }
            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }
        return moment._locale._abbr;
    };
    moment.defineLocale = function(name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);
            moment.locale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    };
    moment.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", function(key) {
        return moment.localeData(key);
    });
    moment.localeData = function(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return moment._locale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [ key ];
        }
        return chooseLocale(key);
    };
    moment.isMoment = function(obj) {
        return obj instanceof Moment || obj != null && obj.hasOwnProperty("_isAMomentObject");
    };
    moment.isDuration = function(obj) {
        return obj instanceof Duration;
    };
    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }
    moment.normalizeUnits = function(units) {
        return normalizeUnits(units);
    };
    moment.invalid = function(flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        } else {
            m._pf.userInvalidated = true;
        }
        return m;
    };
    moment.parseZone = function() {
        return moment.apply(null, arguments).parseZone();
    };
    moment.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    extend(moment.fn = Moment.prototype, {
        clone: function() {
            return moment(this);
        },
        valueOf: function() {
            return +this._d + (this._offset || 0) * 6e4;
        },
        unix: function() {
            return Math.floor(+this / 1e3);
        },
        toString: function() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },
        toDate: function() {
            return this._offset ? new Date(+this) : this._d;
        },
        toISOString: function() {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            } else {
                return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
        },
        toArray: function() {
            var m = this;
            return [ m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds() ];
        },
        isValid: function() {
            return isValid(this);
        },
        isDSTShifted: function() {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }
            return false;
        },
        parsingFlags: function() {
            return extend({}, this._pf);
        },
        invalidAt: function() {
            return this._pf.overflow;
        },
        utc: function(keepLocalTime) {
            return this.zone(0, keepLocalTime);
        },
        local: function(keepLocalTime) {
            if (this._isUTC) {
                this.zone(0, keepLocalTime);
                this._isUTC = false;
                if (keepLocalTime) {
                    this.add(this._d.getTimezoneOffset(), "m");
                }
            }
            return this;
        },
        format: function(inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },
        add: createAdder(1, "add"),
        subtract: createAdder(-1, "subtract"),
        diff: function(input, units, asFloat) {
            var that = makeAs(input, this), zoneDiff = (this.zone() - that.zone()) * 6e4, diff, output;
            units = normalizeUnits(units);
            if (units === "year" || units === "month") {
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5;
                output = (this.year() - that.year()) * 12 + (this.month() - that.month());
                output += (this - moment(this).startOf("month") - (that - moment(that).startOf("month"))) / diff;
                output -= (this.zone() - moment(this).startOf("month").zone() - (that.zone() - moment(that).startOf("month").zone())) * 6e4 / diff;
                if (units === "year") {
                    output = output / 12;
                }
            } else {
                diff = this - that;
                output = units === "second" ? diff / 1e3 : units === "minute" ? diff / 6e4 : units === "hour" ? diff / 36e5 : units === "day" ? (diff - zoneDiff) / 864e5 : units === "week" ? (diff - zoneDiff) / 6048e5 : diff;
            }
            return asFloat ? output : absRound(output);
        },
        from: function(time, withoutSuffix) {
            return moment.duration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        },
        fromNow: function(withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },
        calendar: function(time) {
            var now = time || moment(), sod = makeAs(now, this).startOf("day"), diff = this.diff(sod, "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
            return this.format(this.localeData().calendar(format, this));
        },
        isLeapYear: function() {
            return isLeapYear(this.year());
        },
        isDST: function() {
            return this.zone() < this.clone().month(0).zone() || this.zone() < this.clone().month(5).zone();
        },
        day: function(input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, "d");
            } else {
                return day;
            }
        },
        month: makeAccessor("Month", true),
        startOf: function(units) {
            units = normalizeUnits(units);
            switch (units) {
              case "year":
                this.month(0);

              case "quarter":
              case "month":
                this.date(1);

              case "week":
              case "isoWeek":
              case "day":
                this.hours(0);

              case "hour":
                this.minutes(0);

              case "minute":
                this.seconds(0);

              case "second":
                this.milliseconds(0);
            }
            if (units === "week") {
                this.weekday(0);
            } else if (units === "isoWeek") {
                this.isoWeekday(1);
            }
            if (units === "quarter") {
                this.month(Math.floor(this.month() / 3) * 3);
            }
            return this;
        },
        endOf: function(units) {
            units = normalizeUnits(units);
            return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
        },
        isAfter: function(input, units) {
            units = typeof units !== "undefined" ? units : "millisecond";
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },
        isBefore: function(input, units) {
            units = typeof units !== "undefined" ? units : "millisecond";
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },
        isSame: function(input, units) {
            units = units || "ms";
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },
        min: deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function(other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        }),
        max: deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function(other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        }),
        zone: function(input, keepLocalTime) {
            var offset = this._offset || 0, localAdjust;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._d.getTimezoneOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.subtract(localAdjust, "m");
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this, moment.duration(offset - input, "m"), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },
        zoneAbbr: function() {
            return this._isUTC ? "UTC" : "";
        },
        zoneName: function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },
        parseZone: function() {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === "string") {
                this.zone(this._i);
            }
            return this;
        },
        hasAlignedHourOffset: function(input) {
            if (!input) {
                input = 0;
            } else {
                input = moment(input).zone();
            }
            return (this.zone() - input) % 60 === 0;
        },
        daysInMonth: function() {
            return daysInMonth(this.year(), this.month());
        },
        dayOfYear: function(input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        },
        quarter: function(input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },
        weekYear: function(input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add(input - year, "y");
        },
        isoWeekYear: function(input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add(input - year, "y");
        },
        week: function(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, "d");
        },
        isoWeek: function(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, "d");
        },
        weekday: function(input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, "d");
        },
        isoWeekday: function(input) {
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },
        isoWeeksInYear: function() {
            return weeksInYear(this.year(), 1, 4);
        },
        weeksInYear: function() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units]();
        },
        set: function(units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === "function") {
                this[units](value);
            }
            return this;
        },
        locale: function(key) {
            if (key === undefined) {
                return this._locale._abbr;
            } else {
                this._locale = moment.localeData(key);
                return this;
            }
        },
        lang: deprecate("moment().lang() is deprecated. Use moment().localeData() instead.", function(key) {
            return this.localeData(key);
        }),
        localeData: function() {
            return this._locale;
        }
    });
    function rawMonthSetter(mom, value) {
        var dayOfMonth;
        if (typeof value === "string") {
            value = mom.localeData().monthsParse(value);
            if (typeof value !== "number") {
                return mom;
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
    }
    function rawGetter(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
    }
    function rawSetter(mom, unit, value) {
        if (unit === "Month") {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
    }
    function makeAccessor(unit, keepTime) {
        return function(value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }
    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor("Milliseconds", false);
    moment.fn.second = moment.fn.seconds = makeAccessor("Seconds", false);
    moment.fn.minute = moment.fn.minutes = makeAccessor("Minutes", false);
    moment.fn.hour = moment.fn.hours = makeAccessor("Hours", true);
    moment.fn.date = makeAccessor("Date", true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor("Date", true));
    moment.fn.year = makeAccessor("FullYear", true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor("FullYear", true));
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;
    moment.fn.toJSON = moment.fn.toISOString;
    function daysToYears(days) {
        return days * 400 / 146097;
    }
    function yearsToDays(years) {
        return years * 146097 / 400;
    }
    extend(moment.duration.fn = Duration.prototype, {
        _bubble: function() {
            var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years = 0;
            data.milliseconds = milliseconds % 1e3;
            seconds = absRound(milliseconds / 1e3);
            data.seconds = seconds % 60;
            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;
            hours = absRound(minutes / 60);
            data.hours = hours % 24;
            days += absRound(hours / 24);
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));
            months += absRound(days / 30);
            days %= 30;
            years += absRound(months / 12);
            months %= 12;
            data.days = days;
            data.months = months;
            data.years = years;
        },
        abs: function() {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);
            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);
            return this;
        },
        weeks: function() {
            return absRound(this.days() / 7);
        },
        valueOf: function() {
            return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        },
        humanize: function(withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());
            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }
            return this.localeData().postformat(output);
        },
        add: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;
            this._bubble();
            return this;
        },
        subtract: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;
            this._bubble();
            return this;
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + "s"]();
        },
        as: function(units) {
            var days, months;
            units = normalizeUnits(units);
            days = this._days + this._milliseconds / 864e5;
            if (units === "month" || units === "year") {
                months = this._months + daysToYears(days) * 12;
                return units === "month" ? months : months / 12;
            } else {
                days += yearsToDays(this._months / 12);
                switch (units) {
                  case "week":
                    return days / 7;

                  case "day":
                    return days;

                  case "hour":
                    return days * 24;

                  case "minute":
                    return days * 24 * 60;

                  case "second":
                    return days * 24 * 60 * 60;

                  case "millisecond":
                    return days * 24 * 60 * 60 * 1e3;

                  default:
                    throw new Error("Unknown unit " + units);
                }
            }
        },
        lang: moment.fn.lang,
        locale: moment.fn.locale,
        toIsoString: deprecate("toIsoString() is deprecated. Please use toISOString() instead " + "(notice the capitals)", function() {
            return this.toISOString();
        }),
        toISOString: function() {
            var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()), hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()), seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3);
            if (!this.asSeconds()) {
                return "P0D";
            }
            return (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "");
        },
        localeData: function() {
            return this._locale;
        }
    });
    function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
            return this._data[name];
        };
    }
    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }
    moment.duration.fn.asMilliseconds = function() {
        return this.as("ms");
    };
    moment.duration.fn.asSeconds = function() {
        return this.as("s");
    };
    moment.duration.fn.asMinutes = function() {
        return this.as("m");
    };
    moment.duration.fn.asHours = function() {
        return this.as("h");
    };
    moment.duration.fn.asDays = function() {
        return this.as("d");
    };
    moment.duration.fn.asWeeks = function() {
        return this.as("weeks");
    };
    moment.duration.fn.asMonths = function() {
        return this.as("M");
    };
    moment.duration.fn.asYears = function() {
        return this.as("y");
    };
    moment.locale("en", {
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    function makeGlobal(shouldDeprecate) {
        if (typeof ender !== "undefined") {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate("Accessing Moment through the global scope is " + "deprecated, and will be removed in an upcoming " + "release.", moment);
        } else {
            globalScope.moment = moment;
        }
    }
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === "function" && define.amd) {
        define("moment", function(require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                globalScope.moment = oldGlobalMoment;
            }
            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "moment" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("../moment"));
    } else {
        factory(window.moment);
    }
})(function(moment) {
    return moment.defineLocale("pt-br", {
        months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
        monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
        weekdays: "domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado".split("_"),
        weekdaysShort: "dom_seg_ter_qua_qui_sex_sb".split("_"),
        weekdaysMin: "dom_2_3_4_5_6_sb".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY [s] LT",
            LLLL: "dddd, D [de] MMMM [de] YYYY [s] LT"
        },
        calendar: {
            sameDay: "[Hoje s] LT",
            nextDay: "[Amanh s] LT",
            nextWeek: "dddd [s] LT",
            lastDay: "[Ontem s] LT",
            lastWeek: function() {
                return this.day() === 0 || this.day() === 6 ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "em %s",
            past: "%s atrs",
            s: "segundos",
            m: "um minuto",
            mm: "%d minutos",
            h: "uma hora",
            hh: "%d horas",
            d: "um dia",
            dd: "%d dias",
            M: "um ms",
            MM: "%d meses",
            y: "um ano",
            yy: "%d anos"
        },
        ordinal: "%d"
    });
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(jQuery);
    }
})(function($) {
    $.ui = $.ui || {};
    $.extend($.ui, {
        version: "1.11.1",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });
    $.fn.extend({
        scrollParent: function(includeHidden) {
            var position = this.css("position"), excludeStaticParent = position === "absolute", overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/, scrollParent = this.parents().filter(function() {
                var parent = $(this);
                if (excludeStaticParent && parent.css("position") === "static") {
                    return false;
                }
                return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
            }).eq(0);
            return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
        },
        uniqueId: function() {
            var uuid = 0;
            return function() {
                return this.each(function() {
                    if (!this.id) {
                        this.id = "ui-id-" + ++uuid;
                    }
                });
            };
        }(),
        removeUniqueId: function() {
            return this.each(function() {
                if (/^ui-id-\d+$/.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap='#" + mapName + "']")[0];
            return !!img && visible(img);
        }
        return (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
    }
    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
            return $.css(this, "visibility") === "hidden";
        }).length;
    }
    $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : function(elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });
    if (!$("<a>").outerWidth(1).jquery) {
        $.each([ "Width", "Height" ], function(i, name) {
            var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
                innerWidth: $.fn.innerWidth,
                innerHeight: $.fn.innerHeight,
                outerWidth: $.fn.outerWidth,
                outerHeight: $.fn.outerHeight
            };
            function reduce(elem, size, border, margin) {
                $.each(side, function() {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }
            $.fn["inner" + name] = function(size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }
                return this.each(function() {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };
            $.fn["outer" + name] = function(size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }
                return this.each(function() {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });
    }
    if (!$.fn.addBack) {
        $.fn.addBack = function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        };
    }
    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
        $.fn.removeData = function(removeData) {
            return function(key) {
                if (arguments.length) {
                    return removeData.call(this, $.camelCase(key));
                } else {
                    return removeData.call(this);
                }
            };
        }($.fn.removeData);
    }
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    $.fn.extend({
        focus: function(orig) {
            return function(delay, fn) {
                return typeof delay === "number" ? this.each(function() {
                    var elem = this;
                    setTimeout(function() {
                        $(elem).focus();
                        if (fn) {
                            fn.call(elem);
                        }
                    }, delay);
                }) : orig.apply(this, arguments);
            };
        }($.fn.focus),
        disableSelection: function() {
            var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
            return function() {
                return this.bind(eventType + ".ui-disableSelection", function(event) {
                    event.preventDefault();
                });
            };
        }(),
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        },
        zIndex: function(zIndex) {
            if (zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }
            if (this.length) {
                var elem = $(this[0]), position, value;
                while (elem.length && elem[0] !== document) {
                    position = elem.css("position");
                    if (position === "absolute" || position === "relative" || position === "fixed") {
                        value = parseInt(elem.css("zIndex"), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }
            return 0;
        }
    });
    $.ui.plugin = {
        add: function(module, option, set) {
            var i, proto = $.ui[module].prototype;
            for (i in set) {
                proto.plugins[i] = proto.plugins[i] || [];
                proto.plugins[i].push([ option, set[i] ]);
            }
        },
        call: function(instance, name, args, allowDisconnected) {
            var i, set = instance.plugins[name];
            if (!set) {
                return;
            }
            if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
                return;
            }
            for (i = 0; i < set.length; i++) {
                if (instance.options[set[i][0]]) {
                    set[i][1].apply(instance.element, args);
                }
            }
        }
    };
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(jQuery);
    }
})(function($) {
    (function() {
        $.ui = $.ui || {};
        var cachedScrollbarWidth, supportsOffsetFractions, max = Math.max, abs = Math.abs, round = Math.round, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
        function getOffsets(offsets, width, height) {
            return [ parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1) ];
        }
        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0;
        }
        function getDimensions(elem) {
            var raw = elem[0];
            if (raw.nodeType === 9) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: 0,
                        left: 0
                    }
                };
            }
            if ($.isWindow(raw)) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: elem.scrollTop(),
                        left: elem.scrollLeft()
                    }
                };
            }
            if (raw.preventDefault) {
                return {
                    width: 0,
                    height: 0,
                    offset: {
                        top: raw.pageY,
                        left: raw.pageX
                    }
                };
            }
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            };
        }
        $.position = {
            scrollbarWidth: function() {
                if (cachedScrollbarWidth !== undefined) {
                    return cachedScrollbarWidth;
                }
                var w1, w2, div = $("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"), innerDiv = div.children()[0];
                $("body").append(div);
                w1 = innerDiv.offsetWidth;
                div.css("overflow", "scroll");
                w2 = innerDiv.offsetWidth;
                if (w1 === w2) {
                    w2 = div[0].clientWidth;
                }
                div.remove();
                return cachedScrollbarWidth = w1 - w2;
            },
            getScrollInfo: function(within) {
                var overflowX = within.isWindow || within.isDocument ? "" : within.element.css("overflow-x"), overflowY = within.isWindow || within.isDocument ? "" : within.element.css("overflow-y"), hasOverflowX = overflowX === "scroll" || overflowX === "auto" && within.width < within.element[0].scrollWidth, hasOverflowY = overflowY === "scroll" || overflowY === "auto" && within.height < within.element[0].scrollHeight;
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0
                };
            },
            getWithinInfo: function(element) {
                var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]), isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    isDocument: isDocument,
                    offset: withinElement.offset() || {
                        left: 0,
                        top: 0
                    },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
                    height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
                };
            }
        };
        $.fn.position = function(options) {
            if (!options || !options.of) {
                return _position.apply(this, arguments);
            }
            options = $.extend({}, options);
            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || "flip").split(" "), offsets = {};
            dimensions = getDimensions(target);
            if (target[0].preventDefault) {
                options.at = "left top";
            }
            targetWidth = dimensions.width;
            targetHeight = dimensions.height;
            targetOffset = dimensions.offset;
            basePosition = $.extend({}, targetOffset);
            $.each([ "my", "at" ], function() {
                var pos = (options[this] || "").split(" "), horizontalOffset, verticalOffset;
                if (pos.length === 1) {
                    pos = rhorizontal.test(pos[0]) ? pos.concat([ "center" ]) : rvertical.test(pos[0]) ? [ "center" ].concat(pos) : [ "center", "center" ];
                }
                pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
                horizontalOffset = roffset.exec(pos[0]);
                verticalOffset = roffset.exec(pos[1]);
                offsets[this] = [ horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0 ];
                options[this] = [ rposition.exec(pos[0])[0], rposition.exec(pos[1])[0] ];
            });
            if (collision.length === 1) {
                collision[1] = collision[0];
            }
            if (options.at[0] === "right") {
                basePosition.left += targetWidth;
            } else if (options.at[0] === "center") {
                basePosition.left += targetWidth / 2;
            }
            if (options.at[1] === "bottom") {
                basePosition.top += targetHeight;
            } else if (options.at[1] === "center") {
                basePosition.top += targetHeight / 2;
            }
            atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
            basePosition.left += atOffset[0];
            basePosition.top += atOffset[1];
            return this.each(function() {
                var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, "marginLeft"), marginTop = parseCss(this, "marginTop"), collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
                if (options.my[0] === "right") {
                    position.left -= elemWidth;
                } else if (options.my[0] === "center") {
                    position.left -= elemWidth / 2;
                }
                if (options.my[1] === "bottom") {
                    position.top -= elemHeight;
                } else if (options.my[1] === "center") {
                    position.top -= elemHeight / 2;
                }
                position.left += myOffset[0];
                position.top += myOffset[1];
                if (!supportsOffsetFractions) {
                    position.left = round(position.left);
                    position.top = round(position.top);
                }
                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };
                $.each([ "left", "top" ], function(i, dir) {
                    if ($.ui.position[collision[i]]) {
                        $.ui.position[collision[i]][dir](position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [ atOffset[0] + myOffset[0], atOffset[1] + myOffset[1] ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        });
                    }
                });
                if (options.using) {
                    using = function(props) {
                        var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
                            target: {
                                element: target,
                                left: targetOffset.left,
                                top: targetOffset.top,
                                width: targetWidth,
                                height: targetHeight
                            },
                            element: {
                                element: elem,
                                left: position.left,
                                top: position.top,
                                width: elemWidth,
                                height: elemHeight
                            },
                            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                        };
                        if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                            feedback.horizontal = "center";
                        }
                        if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                            feedback.vertical = "middle";
                        }
                        if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call(this, props, feedback);
                    };
                }
                elem.offset($.extend(position, {
                    using: using
                }));
            });
        };
        $.ui.position = {
            fit: {
                left: function(position, data) {
                    var within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset, newOverRight;
                    if (data.collisionWidth > outerWidth) {
                        if (overLeft > 0 && overRight <= 0) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                            position.left += overLeft - newOverRight;
                        } else if (overRight > 0 && overLeft <= 0) {
                            position.left = withinOffset;
                        } else {
                            if (overLeft > overRight) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }
                    } else if (overLeft > 0) {
                        position.left += overLeft;
                    } else if (overRight > 0) {
                        position.left -= overRight;
                    } else {
                        position.left = max(position.left - collisionPosLeft, position.left);
                    }
                },
                top: function(position, data) {
                    var within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset, newOverBottom;
                    if (data.collisionHeight > outerHeight) {
                        if (overTop > 0 && overBottom <= 0) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                            position.top += overTop - newOverBottom;
                        } else if (overBottom > 0 && overTop <= 0) {
                            position.top = withinOffset;
                        } else {
                            if (overTop > overBottom) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }
                    } else if (overTop > 0) {
                        position.top += overTop;
                    } else if (overBottom > 0) {
                        position.top -= overBottom;
                    } else {
                        position.top = max(position.top - collisionPosTop, position.top);
                    }
                }
            },
            flip: {
                left: function(position, data) {
                    var within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0, atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0, offset = -2 * data.offset[0], newOverRight, newOverLeft;
                    if (overLeft < 0) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                        if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if (overRight > 0) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                        if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function(position, data) {
                    var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === "top", myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0, atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
                    if (overTop < 0) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                        if (position.top + myOffset + atOffset + offset > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if (overBottom > 0) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                        if (position.top + myOffset + atOffset + offset > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    $.ui.position.flip.left.apply(this, arguments);
                    $.ui.position.fit.left.apply(this, arguments);
                },
                top: function() {
                    $.ui.position.flip.top.apply(this, arguments);
                    $.ui.position.fit.top.apply(this, arguments);
                }
            }
        };
        (function() {
            var testElement, testElementParent, testElementStyle, offsetLeft, i, body = document.getElementsByTagName("body")[0], div = document.createElement("div");
            testElement = document.createElement(body ? "div" : "body");
            testElementStyle = {
                visibility: "hidden",
                width: 0,
                height: 0,
                border: 0,
                margin: 0,
                background: "none"
            };
            if (body) {
                $.extend(testElementStyle, {
                    position: "absolute",
                    left: "-1000px",
                    top: "-1000px"
                });
            }
            for (i in testElementStyle) {
                testElement.style[i] = testElementStyle[i];
            }
            testElement.appendChild(div);
            testElementParent = body || document.documentElement;
            testElementParent.insertBefore(testElement, testElementParent.firstChild);
            div.style.cssText = "position: absolute; left: 10.7432222px;";
            offsetLeft = $(div).offset().left;
            supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
            testElement.innerHTML = "";
            testElementParent.removeChild(testElement);
        })();
    })();
    var position = $.ui.position;
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(jQuery);
    }
})(function($) {
    $.extend($.ui, {
        datepicker: {
            version: "1.11.1"
        }
    });
    var datepicker_instActive;
    function datepicker_getZindex(elem) {
        var position, value;
        while (elem.length && elem[0] !== document) {
            position = elem.css("position");
            if (position === "absolute" || position === "relative" || position === "fixed") {
                value = parseInt(elem.css("zIndex"), 10);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            elem = elem.parent();
        }
        return 0;
    }
    function Datepicker() {
        this._curInst = null;
        this._keyEvent = false;
        this._disabledInputs = [];
        this._datepickerShowing = false;
        this._inDialog = false;
        this._mainDivId = "ui-datepicker-div";
        this._inlineClass = "ui-datepicker-inline";
        this._appendClass = "ui-datepicker-append";
        this._triggerClass = "ui-datepicker-trigger";
        this._dialogClass = "ui-datepicker-dialog";
        this._disableClass = "ui-datepicker-disabled";
        this._unselectableClass = "ui-datepicker-unselectable";
        this._currentClass = "ui-datepicker-current-day";
        this._dayOverClass = "ui-datepicker-days-cell-over";
        this.regional = [];
        this.regional[""] = {
            closeText: "Done",
            prevText: "Prev",
            nextText: "Next",
            currentText: "Today",
            monthNames: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
            dayNamesMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ],
            weekHeader: "Wk",
            dateFormat: "mm/dd/yy",
            firstDay: 0,
            isRTL: false,
            showMonthAfterYear: false,
            yearSuffix: ""
        };
        this._defaults = {
            showOn: "focus",
            showAnim: "fadeIn",
            showOptions: {},
            defaultDate: null,
            appendText: "",
            buttonText: "...",
            buttonImage: "",
            buttonImageOnly: false,
            hideIfNoPrevNext: false,
            navigationAsDateFormat: false,
            gotoCurrent: false,
            changeMonth: false,
            changeYear: false,
            yearRange: "c-10:c+10",
            showOtherMonths: false,
            selectOtherMonths: false,
            showWeek: false,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: "+10",
            minDate: null,
            maxDate: null,
            duration: "fast",
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onChangeMonthYear: null,
            onClose: null,
            numberOfMonths: 1,
            showCurrentAtPos: 0,
            stepMonths: 1,
            stepBigMonths: 12,
            altField: "",
            altFormat: "",
            constrainInput: true,
            showButtonPanel: false,
            autoSize: false,
            disabled: false
        };
        $.extend(this._defaults, this.regional[""]);
        this.regional.en = $.extend(true, {}, this.regional[""]);
        this.regional["en-US"] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }
    $.extend(Datepicker.prototype, {
        markerClassName: "hasDatepicker",
        maxRows: 4,
        _widgetDatepicker: function() {
            return this.dpDiv;
        },
        setDefaults: function(settings) {
            datepicker_extendRemove(this._defaults, settings || {});
            return this;
        },
        _attachDatepicker: function(target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = nodeName === "div" || nodeName === "span";
            if (!target.id) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === "input") {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },
        _newInst: function(target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
            return {
                id: id,
                input: target,
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                drawMonth: 0,
                drawYear: 0,
                inline: inline,
                dpDiv: !inline ? this.dpDiv : datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
            };
        },
        _connectDatepicker: function(target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
            this._autoSize(inst);
            $.data(target, "datepicker", inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },
        _attachments: function(input, inst) {
            var showOn, buttonText, buttonImage, appendText = this._get(inst, "appendText"), isRTL = this._get(inst, "isRTL");
            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                input[isRTL ? "before" : "after"](inst.append);
            }
            input.unbind("focus", this._showDatepicker);
            if (inst.trigger) {
                inst.trigger.remove();
            }
            showOn = this._get(inst, "showOn");
            if (showOn === "focus" || showOn === "both") {
                input.focus(this._showDatepicker);
            }
            if (showOn === "button" || showOn === "both") {
                buttonText = this._get(inst, "buttonText");
                buttonImage = this._get(inst, "buttonImage");
                inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                })));
                input[isRTL ? "before" : "after"](inst.trigger);
                inst.trigger.click(function() {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },
        _autoSize: function(inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20), dateFormat = this._get(inst, "dateFormat");
                if (dateFormat.match(/[DM]/)) {
                    findMax = function(names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort")));
                    date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay());
                }
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },
        _inlineDatepicker: function(target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, "datepicker", inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
            inst.dpDiv.css("display", "block");
        },
        _dialogDatepicker: function(input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
            if (!inst) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");
                this._dialogInput.keydown(this._doKeyDown);
                $("body").append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], "datepicker", inst);
            }
            datepicker_extendRemove(inst.settings, settings || {});
            date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
            this._dialogInput.val(date);
            this._pos = pos ? pos.length ? pos : [ pos.pageX, pos.pageY ] : null;
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = [ browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY ];
            }
            this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px");
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], "datepicker", inst);
            return this;
        },
        _destroyDatepicker: function(target) {
            var nodeName, $target = $(target), inst = $.data(target, "datepicker");
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, "datepicker");
            if (nodeName === "input") {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp);
            } else if (nodeName === "div" || nodeName === "span") {
                $target.removeClass(this.markerClassName).empty();
            }
        },
        _enableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = false;
                inst.trigger.filter("button").each(function() {
                    this.disabled = false;
                }).end().filter("img").css({
                    opacity: "1.0",
                    cursor: ""
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().removeClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
            }
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            });
        },
        _disableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = true;
                inst.trigger.filter("button").each(function() {
                    this.disabled = true;
                }).end().filter("img").css({
                    opacity: "0.5",
                    cursor: "default"
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().addClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
            }
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            });
            this._disabledInputs[this._disabledInputs.length] = target;
        },
        _isDisabledDatepicker: function(target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },
        _getInst: function(target) {
            try {
                return $.data(target, "datepicker");
            } catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },
        _optionDatepicker: function(target, name, value) {
            var settings, date, minDate, maxDate, inst = this._getInst(target);
            if (arguments.length === 2 && typeof name === "string") {
                return name === "defaults" ? $.extend({}, $.datepicker._defaults) : inst ? name === "all" ? $.extend({}, inst.settings) : this._get(inst, name) : null;
            }
            settings = name || {};
            if (typeof name === "string") {
                settings = {};
                settings[name] = value;
            }
            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }
                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, "min");
                maxDate = this._getMinMaxDate(inst, "max");
                datepicker_extendRemove(inst.settings, settings);
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ("disabled" in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },
        _changeDatepicker: function(target, name, value) {
            this._optionDatepicker(target, name, value);
        },
        _refreshDatepicker: function(target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },
        _setDateDatepicker: function(target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },
        _getDateDatepicker: function(target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return inst ? this._getDate(inst) : null;
        },
        _doKeyDown: function(event) {
            var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                  case 9:
                    $.datepicker._hideDatepicker();
                    handled = false;
                    break;

                  case 13:
                    sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);
                    if (sel[0]) {
                        $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                    }
                    onSelect = $.datepicker._get(inst, "onSelect");
                    if (onSelect) {
                        dateStr = $.datepicker._formatDate(inst);
                        onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
                    } else {
                        $.datepicker._hideDatepicker();
                    }
                    return false;

                  case 27:
                    $.datepicker._hideDatepicker();
                    break;

                  case 33:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    break;

                  case 34:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    break;

                  case 35:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._clearDate(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 36:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._gotoToday(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 37:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    }
                    break;

                  case 38:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, -7, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 39:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    }
                    break;

                  case 40:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, +7, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  default:
                    handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) {
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },
        _doKeyPress: function(event) {
            var chars, chr, inst = $.datepicker._getInst(event.target);
            if ($.datepicker._get(inst, "constrainInput")) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
            }
        },
        _doKeyUp: function(event) {
            var date, inst = $.datepicker._getInst(event.target);
            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
                    if (date) {
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                } catch (err) {}
            }
            return true;
        },
        _showDatepicker: function(input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== "input") {
                input = $("input", input.parentNode)[0];
            }
            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
                return;
            }
            var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }
            beforeShow = $.datepicker._get(inst, "beforeShow");
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [ input, inst ]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            datepicker_extendRemove(inst.settings, beforeShowSettings);
            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);
            if ($.datepicker._inDialog) {
                input.value = "";
            }
            if (!$.datepicker._pos) {
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight;
            }
            isFixed = false;
            $(input).parents().each(function() {
                isFixed |= $(this).css("position") === "fixed";
                return !isFixed;
            });
            offset = {
                left: $.datepicker._pos[0],
                top: $.datepicker._pos[1]
            };
            $.datepicker._pos = null;
            inst.dpDiv.empty();
            inst.dpDiv.css({
                position: "absolute",
                display: "block",
                top: "-1000px"
            });
            $.datepicker._updateDatepicker(inst);
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute",
                display: "none",
                left: offset.left + "px",
                top: offset.top + "px"
            });
            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, "showAnim");
                duration = $.datepicker._get(inst, "duration");
                inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
                $.datepicker._datepickerShowing = true;
                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                } else {
                    inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                }
                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.focus();
                }
                $.datepicker._curInst = inst;
            }
        },
        _updateDatepicker: function(inst) {
            this.maxRows = 4;
            datepicker_instActive = inst;
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);
            var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17, activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");
            if (activeCell.length > 0) {
                datepicker_handleMouseover.apply(activeCell.get(0));
            }
            inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
            if (cols > 1) {
                inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em");
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                inst.input.focus();
            }
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function() {
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },
        _shouldFocusInput: function(inst) {
            return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
        },
        _checkOffset: function(inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
            offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0;
            offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
            offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
            offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
            return offset;
        },
        _findPos: function(obj) {
            var position, inst = this._getInst(obj), isRTL = this._get(inst, "isRTL");
            while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            }
            position = $(obj).offset();
            return [ position.left, position.top ];
        },
        _hideDatepicker: function(input) {
            var showAnim, duration, postProcess, onClose, inst = this._curInst;
            if (!inst || input && inst !== $.data(input, "datepicker")) {
                return;
            }
            if (this._datepickerShowing) {
                showAnim = this._get(inst, "showAnim");
                duration = this._get(inst, "duration");
                postProcess = function() {
                    $.datepicker._tidyDialog(inst);
                };
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                } else {
                    inst.dpDiv[showAnim === "slideDown" ? "slideUp" : showAnim === "fadeIn" ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess);
                }
                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;
                onClose = this._get(inst, "onClose");
                if (onClose) {
                    onClose.apply(inst.input ? inst.input[0] : null, [ inst.input ? inst.input.val() : "", inst ]);
                }
                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: "absolute",
                        left: "0",
                        top: "-100px"
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },
        _tidyDialog: function(inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
        },
        _checkExternalClick: function(event) {
            if (!$.datepicker._curInst) {
                return;
            }
            var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
            if ($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
                $.datepicker._hideDatepicker();
            }
        },
        _adjustDate: function(id, offset, period) {
            var target = $(id), inst = this._getInst(target[0]);
            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset + (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), period);
            this._updateDatepicker(inst);
        },
        _gotoToday: function(id) {
            var date, target = $(id), inst = this._getInst(target[0]);
            if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectMonthYear: function(id, select, period) {
            var target = $(id), inst = this._getInst(target[0]);
            inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectDay: function(id, month, year, td) {
            var inst, target = $(id);
            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }
            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $("a", td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
        },
        _clearDate: function(id) {
            var target = $(id);
            this._selectDate(target, "");
        },
        _selectDate: function(id, dateStr) {
            var onSelect, target = $(id), inst = this._getInst(target[0]);
            dateStr = dateStr != null ? dateStr : this._formatDate(inst);
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);
            onSelect = this._get(inst, "onSelect");
            if (onSelect) {
                onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
            } else if (inst.input) {
                inst.input.trigger("change");
            }
            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof inst.input[0] !== "object") {
                    inst.input.focus();
                }
                this._lastInput = null;
            }
        },
        _updateAlternate: function(inst) {
            var altFormat, date, dateStr, altField = this._get(inst, "altField");
            if (altField) {
                altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).each(function() {
                    $(this).val(dateStr);
                });
            }
        },
        noWeekends: function(date) {
            var day = date.getDay();
            return [ day > 0 && day < 6, "" ];
        },
        iso8601Week: function(date) {
            var time, checkDate = new Date(date.getTime());
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            time = checkDate.getTime();
            checkDate.setMonth(0);
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
        },
        parseDate: function(format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments";
            }
            value = typeof value === "object" ? value.toString() : value + "";
            if (value === "") {
                return null;
            }
            var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            }, getNumber = function(match) {
                var isDoubled = lookAhead(match), size = match === "@" ? 14 : match === "!" ? 20 : match === "y" && isDoubled ? 4 : match === "o" ? 3 : 2, minSize = match === "y" ? size : 1, digits = new RegExp("^\\d{" + minSize + "," + size + "}"), num = value.substring(iValue).match(digits);
                if (!num) {
                    throw "Missing number at position " + iValue;
                }
                iValue += num[0].length;
                return parseInt(num[0], 10);
            }, getName = function(match, shortNames, longNames) {
                var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                    return [ [ k, v ] ];
                }).sort(function(a, b) {
                    return -(a[1].length - b[1].length);
                });
                $.each(names, function(i, pair) {
                    var name = pair[1];
                    if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                        index = pair[0];
                        iValue += name.length;
                        return false;
                    }
                });
                if (index !== -1) {
                    return index + 1;
                } else {
                    throw "Unknown name at position " + iValue;
                }
            }, checkLiteral = function() {
                if (value.charAt(iValue) !== format.charAt(iFormat)) {
                    throw "Unexpected literal at position " + iValue;
                }
                iValue++;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                      case "d":
                        day = getNumber("d");
                        break;

                      case "D":
                        getName("D", dayNamesShort, dayNames);
                        break;

                      case "o":
                        doy = getNumber("o");
                        break;

                      case "m":
                        month = getNumber("m");
                        break;

                      case "M":
                        month = getName("M", monthNamesShort, monthNames);
                        break;

                      case "y":
                        year = getNumber("y");
                        break;

                      case "@":
                        date = new Date(getNumber("@"));
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;

                      case "!":
                        date = new Date((getNumber("!") - this._ticksTo1970) / 1e4);
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;

                      case "'":
                        if (lookAhead("'")) {
                            checkLiteral();
                        } else {
                            literal = true;
                        }
                        break;

                      default:
                        checkLiteral();
                    }
                }
            }
            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }
            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
            }
            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }
            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw "Invalid date";
            }
            return date;
        },
        ATOM: "yy-mm-dd",
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 1e7,
        formatDate: function(format, date, settings) {
            if (!date) {
                return "";
            }
            var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            }, formatNumber = function(match, value, len) {
                var num = "" + value;
                if (lookAhead(match)) {
                    while (num.length < len) {
                        num = "0" + num;
                    }
                }
                return num;
            }, formatName = function(match, value, shortNames, longNames) {
                return lookAhead(match) ? longNames[value] : shortNames[value];
            }, output = "", literal = false;
            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                          case "d":
                            output += formatNumber("d", date.getDate(), 2);
                            break;

                          case "D":
                            output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                            break;

                          case "o":
                            output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                            break;

                          case "m":
                            output += formatNumber("m", date.getMonth() + 1, 2);
                            break;

                          case "M":
                            output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                            break;

                          case "y":
                            output += lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100;
                            break;

                          case "@":
                            output += date.getTime();
                            break;

                          case "!":
                            output += date.getTime() * 1e4 + this._ticksTo1970;
                            break;

                          case "'":
                            if (lookAhead("'")) {
                                output += "'";
                            } else {
                                literal = true;
                            }
                            break;

                          default:
                            output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },
        _possibleChars: function(format) {
            var iFormat, chars = "", literal = false, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                      case "d":
                      case "m":
                      case "y":
                      case "@":
                        chars += "0123456789";
                        break;

                      case "D":
                      case "M":
                        return null;

                      case "'":
                        if (lookAhead("'")) {
                            chars += "'";
                        } else {
                            literal = true;
                        }
                        break;

                      default:
                        chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },
        _get: function(inst, name) {
            return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
        },
        _setDateFromField: function(inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }
            var dateFormat = this._get(inst, "dateFormat"), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = noDefault ? "" : dates;
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = dates ? date.getDate() : 0;
            inst.currentMonth = dates ? date.getMonth() : 0;
            inst.currentYear = dates ? date.getFullYear() : 0;
            this._adjustInstDate(inst);
        },
        _getDefaultDate: function(inst) {
            return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },
        _determineDate: function(inst, date, defaultDate) {
            var offsetNumeric = function(offset) {
                var date = new Date();
                date.setDate(date.getDate() + offset);
                return date;
            }, offsetString = function(offset) {
                try {
                    return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
                } catch (e) {}
                var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
                while (matches) {
                    switch (matches[2] || "d") {
                      case "d":
                      case "D":
                        day += parseInt(matches[1], 10);
                        break;

                      case "w":
                      case "W":
                        day += parseInt(matches[1], 10) * 7;
                        break;

                      case "m":
                      case "M":
                        month += parseInt(matches[1], 10);
                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                        break;

                      case "y":
                      case "Y":
                        year += parseInt(matches[1], 10);
                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                        break;
                    }
                    matches = pattern.exec(offset);
                }
                return new Date(year, month, day);
            }, newDate = date == null || date === "" ? defaultDate : typeof date === "string" ? offsetString(date) : typeof date === "number" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
            newDate = newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate;
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },
        _daylightSavingAdjust: function(date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },
        _setDate: function(inst, date, noChange) {
            var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? "" : this._formatDate(inst));
            }
        },
        _getDate: function(inst) {
            var startDate = !inst.currentYear || inst.input && inst.input.val() === "" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return startDate;
        },
        _attachHandlers: function(inst) {
            var stepMonths = this._get(inst, "stepMonths"), id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function() {
                var handler = {
                    prev: function() {
                        $.datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function() {
                        $.datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function() {
                        $.datepicker._hideDatepicker();
                    },
                    today: function() {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function() {
                        $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                        return false;
                    },
                    selectMonth: function() {
                        $.datepicker._selectMonthYear(id, this, "M");
                        return false;
                    },
                    selectYear: function() {
                        $.datepicker._selectMonthYear(id, this, "Y");
                        return false;
                    }
                };
                $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
            });
        },
        _generateHTML: function(inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), isRTL = this._get(inst, "isRTL"), showButtonPanel = this._get(inst, "showButtonPanel"), hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"), navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, "showCurrentAtPos"), stepMonths = this._get(inst, "stepMonths"), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
                maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;
            prevText = this._get(inst, "prevText");
            prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
            prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>";
            nextText = this._get(inst, "nextText");
            nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
            next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>";
            currentText = this._get(inst, "currentText");
            gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today;
            currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
            controls = !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "";
            buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
            firstDay = parseInt(this._get(inst, "firstDay"), 10);
            firstDay = isNaN(firstDay) ? 0 : firstDay;
            showWeek = this._get(inst, "showWeek");
            dayNames = this._get(inst, "dayNames");
            dayNamesMin = this._get(inst, "dayNamesMin");
            monthNames = this._get(inst, "monthNames");
            monthNamesShort = this._get(inst, "monthNamesShort");
            beforeShowDay = this._get(inst, "beforeShowDay");
            showOtherMonths = this._get(inst, "showOtherMonths");
            selectOtherMonths = this._get(inst, "selectOtherMonths");
            defaultDate = this._getDefaultDate(inst);
            html = "";
            dow;
            for (row = 0; row < numMonths[0]; row++) {
                group = "";
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if (isMultiMonth) {
                        calender += "<div class='ui-datepicker-group";
                        if (numMonths[1] > 1) {
                            switch (col) {
                              case 0:
                                calender += " ui-datepicker-group-first";
                                cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                break;

                              case numMonths[1] - 1:
                                calender += " ui-datepicker-group-last";
                                cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                break;

                              default:
                                calender += " ui-datepicker-group-middle";
                                cornerClass = "";
                                break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
                    thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "";
                    for (dow = 0; dow < 7; dow++) {
                        day = (dow + firstDay) % 7;
                        thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7);
                    numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) {
                        calender += "<tr>";
                        tbody = !showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>";
                        for (dow = 0; dow < 7; dow++) {
                            daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [ printDate ]) : [ true, "" ];
                            otherMonth = printDate.getMonth() !== drawMonth;
                            unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
                            tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (otherMonth ? " ui-datepicker-other-month" : "") + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? " " + this._dayOverClass : "") + (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (otherMonth && !showOtherMonths ? "&#xa0;" : unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (otherMonth ? " ui-priority-secondary" : "") + "' href='#'>" + printDate.getDate() + "</a>") + "</td>";
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },
        _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, "changeMonth"), changeYear = this._get(inst, "changeYear"), showMonthAfterYear = this._get(inst, "showMonthAfterYear"), html = "<div class='ui-datepicker-title'>", monthHtml = "";
            if (secondary || !changeMonth) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
            } else {
                inMinYear = minDate && minDate.getFullYear() === drawYear;
                inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }
            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
            }
            if (!inst.yearshtml) {
                inst.yearshtml = "";
                if (secondary || !changeYear) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {
                    years = this._get(inst, "yearRange").split(":");
                    thisYear = new Date().getFullYear();
                    determineYear = function(value) {
                        var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                        return isNaN(year) ? thisYear : year;
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ""));
                    year = minDate ? Math.max(year, minDate.getFullYear()) : year;
                    endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for (;year <= endYear; year++) {
                        inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";
                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }
            html += this._get(inst, "yearSuffix");
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
            }
            html += "</div>";
            return html;
        },
        _adjustInstDate: function(inst, offset, period) {
            var year = inst.drawYear + (period === "Y" ? offset : 0), month = inst.drawMonth + (period === "M" ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === "M" || period === "Y") {
                this._notifyChange(inst);
            }
        },
        _restrictMinMax: function(inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), newDate = minDate && date < minDate ? minDate : date;
            return maxDate && newDate > maxDate ? maxDate : newDate;
        },
        _notifyChange: function(inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            if (onChange) {
                onChange.apply(inst.input ? inst.input[0] : null, [ inst.selectedYear, inst.selectedMonth + 1, inst ]);
            }
        },
        _getNumberOfMonths: function(inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return numMonths == null ? [ 1, 1 ] : typeof numMonths === "number" ? [ 1, numMonths ] : numMonths;
        },
        _getMinMaxDate: function(inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },
        _getDaysInMonth: function(year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },
        _getFirstDayOfMonth: function(year, month) {
            return new Date(year, month, 1).getDay();
        },
        _canAdjustMonth: function(inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },
        _isInRange: function(inst, date) {
            var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), minYear = null, maxYear = null, years = this._get(inst, "yearRange");
            if (years) {
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }
            return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
        },
        _getFormatConfig: function(inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"),
                dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"),
                monthNames: this._get(inst, "monthNames")
            };
        },
        _formatDate: function(inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = day ? typeof day === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
    });
    function datepicker_bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.delegate(selector, "mouseout", function() {
            $(this).removeClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).removeClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).removeClass("ui-datepicker-next-hover");
            }
        }).delegate(selector, "mouseover", datepicker_handleMouseover);
    }
    function datepicker_handleMouseover() {
        if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
            $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
            $(this).addClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).addClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).addClass("ui-datepicker-next-hover");
            }
        }
    }
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }
    $.fn.datepicker = function(options) {
        if (!this.length) {
            return this;
        }
        if (!$.datepicker.initialized) {
            $(document).mousedown($.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }
        if ($("#" + $.datepicker._mainDivId).length === 0) {
            $("body").append($.datepicker.dpDiv);
        }
        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
            return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
        }
        if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
            return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
        }
        return this.each(function() {
            typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this ].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
        });
    };
    $.datepicker = new Datepicker();
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.11.1";
    var datepicker = $.datepicker;
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "../datepicker" ], factory);
    } else {
        factory(jQuery.datepicker);
    }
})(function(datepicker) {
    datepicker.regional["pt-BR"] = {
        closeText: "Fechar",
        prevText: "&#x3C;Anterior",
        nextText: "Prximo&#x3E;",
        currentText: "Hoje",
        monthNames: [ "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro" ],
        monthNamesShort: [ "Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez" ],
        dayNames: [ "Domingo", "Segunda-feira", "Tera-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sbado" ],
        dayNamesShort: [ "Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb" ],
        dayNamesMin: [ "Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb" ],
        weekHeader: "Sm",
        dateFormat: "dd/mm/yy",
        firstDay: 0,
        isRTL: false,
        showMonthAfterYear: false,
        yearSuffix: ""
    };
    datepicker.setDefaults(datepicker.regional["pt-BR"]);
    return datepicker.regional["pt-BR"];
});

(function(window, document, undefined) {
    "use strict";
    function minErr(module) {
        return function() {
            var code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments, stringify = function(obj) {
                if (typeof obj === "function") {
                    return obj.toString().replace(/ \{[\s\S]*$/, "");
                } else if (typeof obj === "undefined") {
                    return "undefined";
                } else if (typeof obj !== "string") {
                    return JSON.stringify(obj);
                }
                return obj;
            }, message, i;
            message = prefix + template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1), arg;
                if (index + 2 < templateArgs.length) {
                    arg = templateArgs[index + 2];
                    if (typeof arg === "function") {
                        return arg.toString().replace(/ ?\{[\s\S]*$/, "");
                    } else if (typeof arg === "undefined") {
                        return "undefined";
                    } else if (typeof arg !== "string") {
                        return toJson(arg);
                    }
                    return arg;
                }
                return match;
            });
            message = message + "\nhttp://errors.angularjs.org/1.2.26/" + (module ? module + "/" : "") + code;
            for (i = 2; i < arguments.length; i++) {
                message = message + (i == 2 ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(stringify(arguments[i]));
            }
            return new Error(message);
        };
    }
    var VALIDITY_STATE_PROPERTY = "validity";
    var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    };
    var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
    };
    var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
    };
    if ("i" !== "I".toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
    }
    var msie, jqLite, jQuery, slice = [].slice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, nodeName_, uid = [ "0", "0", "0" ];
    msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
    if (isNaN(msie)) {
        msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
    }
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
            return false;
        }
        var length = obj.length;
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key;
        if (obj) {
            if (isFunction(obj)) {
                for (key in obj) {
                    if (key != "prototype" && key != "length" && key != "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                        iterator.call(context, obj[key], key);
                    }
                }
            } else if (isArray(obj) || isArrayLike(obj)) {
                for (key = 0; key < obj.length; key++) {
                    iterator.call(context, obj[key], key);
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context);
            } else {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key);
                    }
                }
            }
        }
        return obj;
    }
    function sortedKeys(obj) {
        var keys = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys.sort();
    }
    function forEachSorted(obj, iterator, context) {
        var keys = sortedKeys(obj);
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        var index = uid.length;
        var digit;
        while (index) {
            index--;
            digit = uid[index].charCodeAt(0);
            if (digit == 57) {
                uid[index] = "A";
                return uid.join("");
            }
            if (digit == 90) {
                uid[index] = "0";
            } else {
                uid[index] = String.fromCharCode(digit + 1);
                return uid.join("");
            }
        }
        uid.unshift("0");
        return uid.join("");
    }
    function setHashKey(obj, h) {
        if (h) {
            obj.$$hashKey = h;
        } else {
            delete obj.$$hashKey;
        }
    }
    function extend(dst) {
        var h = dst.$$hashKey;
        forEach(arguments, function(obj) {
            if (obj !== dst) {
                forEach(obj, function(value, key) {
                    dst[key] = value;
                });
            }
        });
        setHashKey(dst, h);
        return dst;
    }
    function int(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function noop() {}
    noop.$inject = [];
    function identity($) {
        return $;
    }
    identity.$inject = [];
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function isUndefined(value) {
        return typeof value === "undefined";
    }
    function isDefined(value) {
        return typeof value !== "undefined";
    }
    function isObject(value) {
        return value != null && typeof value === "object";
    }
    function isString(value) {
        return typeof value === "string";
    }
    function isNumber(value) {
        return typeof value === "number";
    }
    function isDate(value) {
        return toString.call(value) === "[object Date]";
    }
    var isArray = function() {
        if (!isFunction(Array.isArray)) {
            return function(value) {
                return toString.call(value) === "[object Array]";
            };
        }
        return Array.isArray;
    }();
    function isFunction(value) {
        return typeof value === "function";
    }
    function isRegExp(value) {
        return toString.call(value) === "[object RegExp]";
    }
    function isWindow(obj) {
        return obj && obj.document && obj.location && obj.alert && obj.setInterval;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return toString.call(obj) === "[object File]";
    }
    function isBlob(obj) {
        return toString.call(obj) === "[object Blob]";
    }
    function isBoolean(value) {
        return typeof value === "boolean";
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    var trim = function() {
        if (!String.prototype.trim) {
            return function(value) {
                return isString(value) ? value.replace(/^\s\s*/, "").replace(/\s\s*$/, "") : value;
            };
        }
        return function(value) {
            return isString(value) ? value.trim() : value;
        };
    }();
    function isElement(node) {
        return !!(node && (node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) obj[items[i]] = true;
        return obj;
    }
    if (msie < 9) {
        nodeName_ = function(element) {
            element = element.nodeName ? element : element[0];
            return element.scopeName && element.scopeName != "HTML" ? uppercase(element.scopeName + ":" + element.nodeName) : element.nodeName;
        };
    } else {
        nodeName_ = function(element) {
            return element.nodeName ? element.nodeName : element[0].nodeName;
        };
    }
    function map(obj, iterator, context) {
        var results = [];
        forEach(obj, function(value, index, list) {
            results.push(iterator.call(context, value, index, list));
        });
        return results;
    }
    function size(obj, ownPropsOnly) {
        var count = 0, key;
        if (isArray(obj) || isString(obj)) {
            return obj.length;
        } else if (isObject(obj)) {
            for (key in obj) if (!ownPropsOnly || obj.hasOwnProperty(key)) count++;
        }
        return count;
    }
    function includes(array, obj) {
        return indexOf(array, obj) != -1;
    }
    function indexOf(array, obj) {
        if (array.indexOf) return array.indexOf(obj);
        for (var i = 0; i < array.length; i++) {
            if (obj === array[i]) return i;
        }
        return -1;
    }
    function arrayRemove(array, value) {
        var index = indexOf(array, value);
        if (index >= 0) array.splice(index, 1);
        return value;
    }
    function isLeafNode(node) {
        if (node) {
            switch (node.nodeName) {
              case "OPTION":
              case "PRE":
              case "TITLE":
                return true;
            }
        }
        return false;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
            throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (!destination) {
            destination = source;
            if (source) {
                if (isArray(source)) {
                    destination = copy(source, [], stackSource, stackDest);
                } else if (isDate(source)) {
                    destination = new Date(source.getTime());
                } else if (isRegExp(source)) {
                    destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                    destination.lastIndex = source.lastIndex;
                } else if (isObject(source)) {
                    destination = copy(source, {}, stackSource, stackDest);
                }
            }
        } else {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            stackSource = stackSource || [];
            stackDest = stackDest || [];
            if (isObject(source)) {
                var index = indexOf(stackSource, source);
                if (index !== -1) return stackDest[index];
                stackSource.push(source);
                stackDest.push(destination);
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) {
                    result = copy(source[i], null, stackSource, stackDest);
                    if (isObject(source[i])) {
                        stackSource.push(source[i]);
                        stackDest.push(result);
                    }
                    destination.push(result);
                }
            } else {
                var h = destination.$$hashKey;
                if (isArray(destination)) {
                    destination.length = 0;
                } else {
                    forEach(destination, function(value, key) {
                        delete destination[key];
                    });
                }
                for (var key in source) {
                    result = copy(source[key], null, stackSource, stackDest);
                    if (isObject(source[key])) {
                        stackSource.push(source[key]);
                        stackDest.push(result);
                    }
                    destination[key] = result;
                }
                setHashKey(destination, h);
            }
        }
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0; i < src.length; i++) {
                dst[i] = src[i];
            }
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) {
                if (hasOwnProperty.call(src, key) && !(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                    dst[key] = src[key];
                }
            }
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true;
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 == t2) {
            if (t1 == "object") {
                if (isArray(o1)) {
                    if (!isArray(o2)) return false;
                    if ((length = o1.length) == o2.length) {
                        for (key = 0; key < length; key++) {
                            if (!equals(o1[key], o2[key])) return false;
                        }
                        return true;
                    }
                } else if (isDate(o1)) {
                    if (!isDate(o2)) return false;
                    return isNaN(o1.getTime()) && isNaN(o2.getTime()) || o1.getTime() === o2.getTime();
                } else if (isRegExp(o1) && isRegExp(o2)) {
                    return o1.toString() == o2.toString();
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
                    keySet = {};
                    for (key in o1) {
                        if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
                        if (!equals(o1[key], o2[key])) return false;
                        keySet[key] = true;
                    }
                    for (key in o2) {
                        if (!keySet.hasOwnProperty(key) && key.charAt(0) !== "$" && o2[key] !== undefined && !isFunction(o2[key])) return false;
                    }
                    return true;
                }
            }
        }
        return false;
    }
    var csp = function() {
        if (isDefined(csp.isActive_)) return csp.isActive_;
        var active = !!(document.querySelector("[ng-csp]") || document.querySelector("[data-ng-csp]"));
        if (!active) {
            try {
                new Function("");
            } catch (e) {
                active = true;
            }
        }
        return csp.isActive_ = active;
    };
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length ? function() {
                return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs);
            } : function() {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self);
            };
        } else {
            return fn;
        }
    }
    function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === "string" && key.charAt(0) === "$") {
            val = undefined;
        } else if (isWindow(value)) {
            val = "$WINDOW";
        } else if (value && document === value) {
            val = "$DOCUMENT";
        } else if (isScope(value)) {
            val = "$SCOPE";
        }
        return val;
    }
    function toJson(obj, pretty) {
        if (typeof obj === "undefined") return undefined;
        return JSON.stringify(obj, toJsonReplacer, pretty ? "  " : null);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function toBoolean(value) {
        if (typeof value === "function") {
            value = true;
        } else if (value && value.length !== 0) {
            var v = lowercase("" + value);
            value = !(v == "f" || v == "0" || v == "false" || v == "no" || v == "n" || v == "[]");
        } else {
            value = false;
        }
        return value;
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var TEXT_NODE = 3;
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {}, key_value, key;
        forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue) {
                key_value = keyValue.replace(/\+/g, "%20").split("=");
                key = tryDecodeURIComponent(key_value[0]);
                if (isDefined(key)) {
                    var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
                    if (!hasOwnProperty.call(obj, key)) {
                        obj[key] = val;
                    } else if (isArray(obj[key])) {
                        obj[key].push(val);
                    } else {
                        obj[key] = [ obj[key], val ];
                    }
                }
            }
        });
        return obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
            if (isArray(value)) {
                forEach(value, function(arrayValue) {
                    parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
                });
            } else {
                parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
            }
        });
        return parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    function angularInit(element, bootstrap) {
        var elements = [ element ], appElement, module, names = [ "ng:app", "ng-app", "x-ng-app", "data-ng-app" ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
        function append(element) {
            element && elements.push(element);
        }
        forEach(names, function(name) {
            names[name] = true;
            append(document.getElementById(name));
            name = name.replace(":", "\\:");
            if (element.querySelectorAll) {
                forEach(element.querySelectorAll("." + name), append);
                forEach(element.querySelectorAll("." + name + "\\:"), append);
                forEach(element.querySelectorAll("[" + name + "]"), append);
            }
        });
        forEach(elements, function(element) {
            if (!appElement) {
                var className = " " + element.className + " ";
                var match = NG_APP_CLASS_REGEXP.exec(className);
                if (match) {
                    appElement = element;
                    module = (match[2] || "").replace(/\s+/g, ",");
                } else {
                    forEach(element.attributes, function(attr) {
                        if (!appElement && names[attr.name]) {
                            appElement = element;
                            module = attr.value;
                        }
                    });
                }
            }
        });
        if (appElement) {
            bootstrap(appElement, module ? [ module ] : []);
        }
    }
    function bootstrap(element, modules) {
        var doBootstrap = function() {
            element = jqLite(element);
            if (element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [];
            modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]);
            modules.unshift("ng");
            var injector = createInjector(modules);
            injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", "$animate", function(scope, element, compile, injector, animate) {
                scope.$apply(function() {
                    element.data("$injector", injector);
                    compile(element)(scope);
                });
            } ]);
            return injector;
        };
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
            return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
        angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            });
            doBootstrap();
        };
    }
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator) {
        separator = separator || "_";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function bindJQuery() {
        jQuery = window.jQuery;
        if (jQuery && jQuery.fn.on) {
            jqLite = jQuery;
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            });
            jqLitePatchJQueryRemove("remove", true, true, false);
            jqLitePatchJQueryRemove("empty", false, false, false);
            jqLitePatchJQueryRemove("html", false, false, true);
        } else {
            jqLite = JQLite;
        }
        angular.element = jqLite;
    }
    function assertArg(arg, name, reason) {
        if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        }
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
        return arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
        }
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        var keys = path.split(".");
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj);
        }
        return obj;
    }
    function getBlockElements(nodes) {
        var startNode = nodes[0], endNode = nodes[nodes.length - 1];
        if (startNode === endNode) {
            return jqLite(startNode);
        }
        var element = startNode;
        var elements = [ element ];
        do {
            element = element.nextSibling;
            if (!element) break;
            elements.push(element);
        } while (element !== endNode);
        return jqLite(elements);
    }
    function setupModuleLoader(window) {
        var $injectorMinErr = minErr("$injector");
        var ngMinErr = minErr("ng");
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, "angular", Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, "module", function() {
            var modules = {};
            return function module(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if (name === "hasOwnProperty") {
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                    }
                };
                assertNotHasOwnProperty(name, "module");
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null;
                }
                return ensure(modules, name, function() {
                    if (!requires) {
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
                    }
                    var invokeQueue = [];
                    var runBlocks = [];
                    var config = invokeLater("$injector", "invoke");
                    var moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            runBlocks.push(block);
                            return this;
                        }
                    };
                    if (configFn) {
                        config(configFn);
                    }
                    return moduleInstance;
                    function invokeLater(provider, method, insertMethod) {
                        return function() {
                            invokeQueue[insertMethod || "push"]([ provider, method, arguments ]);
                            return moduleInstance;
                        };
                    }
                });
            };
        });
    }
    var version = {
        full: "1.2.26",
        major: 1,
        minor: 2,
        dot: 26,
        codeName: "captivating-disinterest"
    };
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            $$minErr: minErr,
            $$csp: csp
        });
        angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale");
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
        }
        angularModule("ng", [ "ngLocale" ], [ "$provide", function ngModule($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            });
            $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                ngValue: ngValueDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider
            });
        } ]);
    }
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = window.document.addEventListener ? function(element, type, fn) {
        element.addEventListener(type, fn, false);
    } : function(element, type, fn) {
        element.attachEvent("on" + type, fn);
    }, removeEventListenerFn = window.document.removeEventListener ? function(element, type, fn) {
        element.removeEventListener(type, fn, false);
    } : function(element, type, fn) {
        element.detachEvent("on" + type, fn);
    };
    var jqData = JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    function jqNextId() {
        return ++jqId;
    }
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
    var MOZ_HACK_REGEXP = /^moz([A-Z])/;
    var jqLiteMinErr = minErr("jqLite");
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    function jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
        var originalJqFn = jQuery.fn[name];
        originalJqFn = originalJqFn.$original || originalJqFn;
        removePatch.$original = originalJqFn;
        jQuery.fn[name] = removePatch;
        function removePatch(param) {
            var list = filterElems && param ? [ this.filter(param) ] : [ this ], fireEvent = dispatchThis, set, setIndex, setLength, element, childIndex, childLength, children;
            if (!getterIfNoArguments || param != null) {
                while (list.length) {
                    set = list.shift();
                    for (setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
                        element = jqLite(set[setIndex]);
                        if (fireEvent) {
                            element.triggerHandler("$destroy");
                        } else {
                            fireEvent = !fireEvent;
                        }
                        for (childIndex = 0, childLength = (children = element.children()).length; childIndex < childLength; childIndex++) {
                            list.push(jQuery(children[childIndex]));
                        }
                    }
                }
            }
            return originalJqFn.apply(this, arguments);
        }
    }
    var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var HTML_REGEXP = /<|&#?\w+;/;
    var TAG_NAME_REGEXP = /<([\w:]+)/;
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
    var wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteBuildFragment(html, context) {
        var elem, tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i, j, jj;
        if (jqLiteIsTextNode(html)) {
            nodes.push(context.createTextNode(html));
        } else {
            tmp = fragment.appendChild(context.createElement("div"));
            tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = "<div>&#160;</div>" + wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
            tmp.removeChild(tmp.firstChild);
            i = wrap[0];
            while (i--) {
                tmp = tmp.lastChild;
            }
            for (j = 0, jj = tmp.childNodes.length; j < jj; ++j) nodes.push(tmp.childNodes[j]);
            tmp = fragment.firstChild;
            tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        return nodes;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            return [ context.createElement(parsed[1]) ];
        }
        return jqLiteBuildFragment(html, context);
    }
    function JQLite(element) {
        if (element instanceof JQLite) {
            return element;
        }
        if (isString(element)) {
            element = trim(element);
        }
        if (!(this instanceof JQLite)) {
            if (isString(element) && element.charAt(0) != "<") {
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            }
            return new JQLite(element);
        }
        if (isString(element)) {
            jqLiteAddNodes(this, jqLiteParseHTML(element));
            var fragment = jqLite(document.createDocumentFragment());
            fragment.append(this);
        } else {
            jqLiteAddNodes(this, element);
        }
    }
    function jqLiteClone(element) {
        return element.cloneNode(true);
    }
    function jqLiteDealoc(element) {
        jqLiteRemoveData(element);
        for (var i = 0, children = element.childNodes || []; i < children.length; i++) {
            jqLiteDealoc(children[i]);
        }
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
        if (!handle) return;
        if (isUndefined(type)) {
            forEach(events, function(eventHandler, type) {
                removeEventListenerFn(element, type, eventHandler);
                delete events[type];
            });
        } else {
            forEach(type.split(" "), function(type) {
                if (isUndefined(fn)) {
                    removeEventListenerFn(element, type, events[type]);
                    delete events[type];
                } else {
                    arrayRemove(events[type] || [], fn);
                }
            });
        }
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = jqCache[expandoId];
        if (expandoStore) {
            if (name) {
                delete jqCache[expandoId].data[name];
                return;
            }
            if (expandoStore.handle) {
                expandoStore.events.$destroy && expandoStore.handle({}, "$destroy");
                jqLiteOff(element);
            }
            delete jqCache[expandoId];
            element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, key, value) {
        var expandoId = element.ng339, expandoStore = jqCache[expandoId || -1];
        if (isDefined(value)) {
            if (!expandoStore) {
                element.ng339 = expandoId = jqNextId();
                expandoStore = jqCache[expandoId] = {};
            }
            expandoStore[key] = value;
        } else {
            return expandoStore && expandoStore[key];
        }
    }
    function jqLiteData(element, key, value) {
        var data = jqLiteExpandoStore(element, "data"), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
        if (!data && !isSimpleGetter) {
            jqLiteExpandoStore(element, "data", data = {});
        }
        if (isSetter) {
            data[key] = value;
        } else {
            if (keyDefined) {
                if (isSimpleGetter) {
                    return data && data[key];
                } else {
                    extend(data, key);
                }
            } else {
                return data;
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        if (!element.getAttribute) return false;
        return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            forEach(cssClasses.split(" "), function(cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
            });
        }
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass);
                if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
                    existingClasses += cssClass + " ";
                }
            });
            element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) {
            elements = !elements.nodeName && isDefined(elements.length) && !isWindow(elements) ? elements : [ elements ];
            for (var i = 0; i < elements.length; i++) {
                root.push(elements[i]);
            }
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == 9) {
            element = element.documentElement;
        }
        var names = isArray(name) ? name : [ name ];
        while (element) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                if ((value = jqLite.data(element, names[i])) !== undefined) return value;
            }
            element = element.parentNode || element.nodeType === 11 && element.host;
        }
    }
    function jqLiteEmpty(element) {
        for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
            jqLiteDealoc(childNodes[i]);
        }
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
    }
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            var fired = false;
            function trigger() {
                if (fired) return;
                fired = true;
                fn();
            }
            if (document.readyState === "complete") {
                setTimeout(trigger);
            } else {
                this.on("DOMContentLoaded", trigger);
                JQLite(window).on("load", trigger);
            }
        },
        toString: function() {
            var value = [];
            forEach(this, function(e) {
                value.push("" + e);
            });
            return "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    };
    var BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[uppercase(value)] = true;
    });
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
    }
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData
    }, function(fn, name) {
        JQLite[name] = fn;
    });
    forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            name = camelCase(name);
            if (isDefined(value)) {
                element.style[name] = value;
            } else {
                var val;
                if (msie <= 8) {
                    val = element.currentStyle && element.currentStyle[name];
                    if (val === "") val = "auto";
                }
                val = val || element.style[name];
                if (msie <= 8) {
                    val = val === "" ? undefined : val;
                }
                return val;
            }
        },
        attr: function(element, name, value) {
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (isDefined(value)) {
                    if (!!value) {
                        element[name] = true;
                        element.setAttribute(name, lowercasedName);
                    } else {
                        element[name] = false;
                        element.removeAttribute(lowercasedName);
                    }
                } else {
                    return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                }
            } else if (isDefined(value)) {
                element.setAttribute(name, value);
            } else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return ret === null ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            if (isDefined(value)) {
                element[name] = value;
            } else {
                return element[name];
            }
        },
        text: function() {
            var NODE_TYPE_TEXT_PROPERTY = [];
            if (msie < 9) {
                NODE_TYPE_TEXT_PROPERTY[1] = "innerText";
                NODE_TYPE_TEXT_PROPERTY[3] = "nodeValue";
            } else {
                NODE_TYPE_TEXT_PROPERTY[1] = NODE_TYPE_TEXT_PROPERTY[3] = "textContent";
            }
            getText.$dv = "";
            return getText;
            function getText(element, value) {
                var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType];
                if (isUndefined(value)) {
                    return textProp ? element[textProp] : "";
                }
                element[textProp] = value;
            }
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (nodeName_(element) === "SELECT" && element.multiple) {
                    var result = [];
                    forEach(element.options, function(option) {
                        if (option.selected) {
                            result.push(option.value || option.text);
                        }
                    });
                    return result.length === 0 ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (isUndefined(value)) {
                return element.innerHTML;
            }
            for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
                jqLiteDealoc(childNodes[i]);
            }
            element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key;
            var nodeCount = this.length;
            if (fn !== jqLiteEmpty && (fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) {
                        if (fn === jqLiteData) {
                            fn(this[i], arg1);
                        } else {
                            for (key in arg1) {
                                fn(this[i], key, arg1[key]);
                            }
                        }
                    }
                    return this;
                } else {
                    var value = fn.$dv;
                    var jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount;
                    for (var j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue;
                    }
                    return value;
                }
            } else {
                for (i = 0; i < nodeCount; i++) {
                    fn(this[i], arg1, arg2);
                }
                return this;
            }
        };
    });
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            if (!event.preventDefault) {
                event.preventDefault = function() {
                    event.returnValue = false;
                };
            }
            if (!event.stopPropagation) {
                event.stopPropagation = function() {
                    event.cancelBubble = true;
                };
            }
            if (!event.target) {
                event.target = event.srcElement || document;
            }
            if (isUndefined(event.defaultPrevented)) {
                var prevent = event.preventDefault;
                event.preventDefault = function() {
                    event.defaultPrevented = true;
                    prevent.call(event);
                };
                event.defaultPrevented = false;
            }
            event.isDefaultPrevented = function() {
                return event.defaultPrevented || event.returnValue === false;
            };
            var eventHandlersCopy = shallowCopy(events[type || event.type] || []);
            forEach(eventHandlersCopy, function(fn) {
                fn.call(element, event);
            });
            if (msie <= 8) {
                event.preventDefault = null;
                event.stopPropagation = null;
                event.isDefaultPrevented = null;
            } else {
                delete event.preventDefault;
                delete event.stopPropagation;
                delete event.isDefaultPrevented;
            }
        };
        eventHandler.elem = element;
        return eventHandler;
    }
    forEach({
        removeData: jqLiteRemoveData,
        dealoc: jqLiteDealoc,
        on: function onFn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
            if (!events) jqLiteExpandoStore(element, "events", events = {});
            if (!handle) jqLiteExpandoStore(element, "handle", handle = createEventHandler(element, events));
            forEach(type.split(" "), function(type) {
                var eventFns = events[type];
                if (!eventFns) {
                    if (type == "mouseenter" || type == "mouseleave") {
                        var contains = document.body.contains || document.body.compareDocumentPosition ? function(a, b) {
                            var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
                        } : function(a, b) {
                            if (b) {
                                while (b = b.parentNode) {
                                    if (b === a) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        };
                        events[type] = [];
                        var eventmap = {
                            mouseleave: "mouseout",
                            mouseenter: "mouseover"
                        };
                        onFn(element, eventmap[type], function(event) {
                            var target = this, related = event.relatedTarget;
                            if (!related || related !== target && !contains(target, related)) {
                                handle(event, type);
                            }
                        });
                    } else {
                        addEventListenerFn(element, type, handle);
                        events[type] = [];
                    }
                    eventFns = events[type];
                }
                eventFns.push(fn);
            });
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element);
            element.on(type, function onFn() {
                element.off(type, fn);
                element.off(type, onFn);
            });
            element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element);
            forEach(new JQLite(replaceNode), function(node) {
                if (index) {
                    parent.insertBefore(node, index.nextSibling);
                } else {
                    parent.replaceChild(node, element);
                }
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            forEach(element.childNodes, function(element) {
                if (element.nodeType === 1) children.push(element);
            });
            return children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            forEach(new JQLite(node), function(child) {
                if (element.nodeType === 1 || element.nodeType === 11) {
                    element.appendChild(child);
                }
            });
        },
        prepend: function(element, node) {
            if (element.nodeType === 1) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode)[0];
            var parent = element.parentNode;
            if (parent) {
                parent.replaceChild(wrapNode, element);
            }
            wrapNode.appendChild(element);
        },
        remove: function(element) {
            jqLiteDealoc(element);
            var parent = element.parentNode;
            if (parent) parent.removeChild(element);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            forEach(new JQLite(newElement), function(node) {
                parent.insertBefore(node, index.nextSibling);
                index = node;
            });
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            if (selector) {
                forEach(selector.split(" "), function(className) {
                    var classCondition = condition;
                    if (isUndefined(classCondition)) {
                        classCondition = !jqLiteHasClass(element, className);
                    }
                    (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                });
            }
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        next: function(element) {
            if (element.nextElementSibling) {
                return element.nextElementSibling;
            }
            var elm = element.nextSibling;
            while (elm != null && elm.nodeType !== 1) {
                elm = elm.nextSibling;
            }
            return elm;
        },
        find: function(element, selector) {
            if (element.getElementsByTagName) {
                return element.getElementsByTagName(selector);
            } else {
                return [];
            }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs;
            var eventName = event.type || event;
            var eventFns = (jqLiteExpandoStore(element, "events") || {})[eventName];
            if (eventFns) {
                dummyEvent = {
                    preventDefault: function() {
                        this.defaultPrevented = true;
                    },
                    isDefaultPrevented: function() {
                        return this.defaultPrevented === true;
                    },
                    stopPropagation: noop,
                    type: eventName,
                    target: element
                };
                if (event.type) {
                    dummyEvent = extend(dummyEvent, event);
                }
                eventFnsCopy = shallowCopy(eventFns);
                handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ];
                forEach(eventFnsCopy, function(fn) {
                    fn.apply(element, handlerArgs);
                });
            }
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            var value;
            for (var i = 0; i < this.length; i++) {
                if (isUndefined(value)) {
                    value = fn(this[i], arg1, arg2, arg3);
                    if (isDefined(value)) {
                        value = jqLite(value);
                    }
                } else {
                    jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                }
            }
            return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
    });
    function hashKey(obj, nextUidFn) {
        var objType = typeof obj, key;
        if (objType == "function" || objType == "object" && obj !== null) {
            if (typeof (key = obj.$$hashKey) == "function") {
                key = obj.$$hashKey();
            } else if (key === undefined) {
                key = obj.$$hashKey = (nextUidFn || nextUid)();
            }
        } else {
            key = obj;
        }
        return objType + ":" + key;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            delete this[key];
            return value;
        }
    };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var $injectorMinErr = minErr("$injector");
    function annotate(fn) {
        var $inject, fnText, argDecl, last;
        if (typeof fn === "function") {
            if (!($inject = fn.$inject)) {
                $inject = [];
                if (fn.length) {
                    fnText = fn.toString().replace(STRIP_COMMENTS, "");
                    argDecl = fnText.match(FN_ARGS);
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else if (isArray(fn)) {
            last = fn.length - 1;
            assertArgFn(fn[last], "fn");
            $inject = fn.slice(0, last);
        } else {
            assertArgFn(fn, "fn", true);
        }
        return $inject;
    }
    function createInjector(modulesToLoad) {
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], true), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function() {
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(servicename) {
            var provider = providerInjector.get(servicename + providerSuffix);
            return instanceInjector.invoke(provider.$get, provider);
        });
        forEach(loadModules(modulesToLoad), function(fn) {
            instanceInjector.invoke(fn || noop);
        });
        return instanceInjector;
        function supportObject(delegate) {
            return function(key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate));
                } else {
                    return delegate(key, value);
                }
            };
        }
        function provider(name, provider_) {
            assertNotHasOwnProperty(name, "service");
            if (isFunction(provider_) || isArray(provider_)) {
                provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            }
            return providerCache[name + providerSuffix] = provider_;
        }
        function factory(name, factoryFn) {
            return provider(name, {
                $get: factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val));
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant");
            providerCache[name] = value;
            instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            var runBlocks = [], moduleFn, invokeQueue, i, ii;
            forEach(modulesToLoad, function(module) {
                if (loadedModules.get(module)) return;
                loadedModules.put(module, true);
                try {
                    if (isString(module)) {
                        moduleFn = angularModule(module);
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                        for (invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
                            var invokeArgs = invokeQueue[i], provider = providerInjector.get(invokeArgs[0]);
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                        }
                    } else if (isFunction(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else if (isArray(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else {
                        assertArgFn(module, "module");
                    }
                } catch (e) {
                    if (isArray(module)) {
                        module = module[module.length - 1];
                    }
                    if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                        e = e.message + "\n" + e.stack;
                    }
                    throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                }
            });
            return runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    }
                    return cache[serviceName];
                } else {
                    try {
                        path.unshift(serviceName);
                        cache[serviceName] = INSTANTIATING;
                        return cache[serviceName] = factory(serviceName);
                    } catch (err) {
                        if (cache[serviceName] === INSTANTIATING) {
                            delete cache[serviceName];
                        }
                        throw err;
                    } finally {
                        path.shift();
                    }
                }
            }
            function invoke(fn, self, locals) {
                var args = [], $inject = annotate(fn), length, i, key;
                for (i = 0, length = $inject.length; i < length; i++) {
                    key = $inject[i];
                    if (typeof key !== "string") {
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    }
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
                }
                if (isArray(fn)) {
                    fn = fn[length];
                }
                return fn.apply(self, args);
            }
            function instantiate(Type, locals) {
                var Constructor = function() {}, instance, returnedValue;
                Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
                instance = new Constructor();
                returnedValue = invoke(Type, instance, locals);
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
        };
        this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            var document = $window.document;
            function getFirstAnchor(list) {
                var result = null;
                forEach(list, function(element) {
                    if (!result && lowercase(element.nodeName) === "a") result = element;
                });
                return result;
            }
            function scroll() {
                var hash = $location.hash(), elm;
                if (!hash) $window.scrollTo(0, 0); else if (elm = document.getElementById(hash)) elm.scrollIntoView(); else if (elm = getFirstAnchor(document.getElementsByName(hash))) elm.scrollIntoView(); else if (hash === "top") $window.scrollTo(0, 0);
            }
            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {
                    return $location.hash();
                }, function autoScrollWatchAction() {
                    $rootScope.$evalAsync(scroll);
                });
            }
            return scroll;
        } ];
    }
    var $animateMinErr = minErr("$animate");
    var $AnimateProvider = [ "$provide", function($provide) {
        this.$$selectors = {};
        this.register = function(name, factory) {
            var key = name + "-animation";
            if (name && name.charAt(0) != ".") throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            this.$$selectors[name.substr(1)] = key;
            $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
            if (arguments.length === 1) {
                this.$$classNameFilter = expression instanceof RegExp ? expression : null;
            }
            return this.$$classNameFilter;
        };
        this.$get = [ "$timeout", "$$asyncCallback", function($timeout, $$asyncCallback) {
            function async(fn) {
                fn && $$asyncCallback(fn);
            }
            return {
                enter: function(element, parent, after, done) {
                    if (after) {
                        after.after(element);
                    } else {
                        if (!parent || !parent[0]) {
                            parent = after.parent();
                        }
                        parent.append(element);
                    }
                    async(done);
                },
                leave: function(element, done) {
                    element.remove();
                    async(done);
                },
                move: function(element, parent, after, done) {
                    this.enter(element, parent, after, done);
                },
                addClass: function(element, className, done) {
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "";
                    forEach(element, function(element) {
                        jqLiteAddClass(element, className);
                    });
                    async(done);
                },
                removeClass: function(element, className, done) {
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "";
                    forEach(element, function(element) {
                        jqLiteRemoveClass(element, className);
                    });
                    async(done);
                },
                setClass: function(element, add, remove, done) {
                    forEach(element, function(element) {
                        jqLiteAddClass(element, add);
                        jqLiteRemoveClass(element, remove);
                    });
                    async(done);
                },
                enabled: noop
            };
        } ];
    } ];
    function $$AsyncCallbackProvider() {
        this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
            return $$rAF.supported ? function(fn) {
                return $$rAF(fn);
            } : function(fn) {
                return $timeout(fn, 0, false);
            };
        } ];
    }
    function Browser(window, document, $log, $sniffer) {
        var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                outstandingRequestCount--;
                if (outstandingRequestCount === 0) {
                    while (outstandingRequestCallbacks.length) {
                        try {
                            outstandingRequestCallbacks.pop()();
                        } catch (e) {
                            $log.error(e);
                        }
                    }
                }
            }
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
            forEach(pollFns, function(pollFn) {
                pollFn();
            });
            if (outstandingRequestCount === 0) {
                callback();
            } else {
                outstandingRequestCallbacks.push(callback);
            }
        };
        var pollFns = [], pollTimeout;
        self.addPollFn = function(fn) {
            if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
            pollFns.push(fn);
            return fn;
        };
        function startPoller(interval, setTimeout) {
            (function check() {
                forEach(pollFns, function(pollFn) {
                    pollFn();
                });
                pollTimeout = setTimeout(check, interval);
            })();
        }
        var lastBrowserUrl = location.href, baseElement = document.find("base"), newLocation = null;
        self.url = function(url, replace) {
            if (location !== window.location) location = window.location;
            if (history !== window.history) history = window.history;
            if (url) {
                if (lastBrowserUrl == url) return;
                lastBrowserUrl = url;
                if ($sniffer.history) {
                    if (replace) history.replaceState(null, "", url); else {
                        history.pushState(null, "", url);
                        baseElement.attr("href", baseElement.attr("href"));
                    }
                } else {
                    newLocation = url;
                    if (replace) {
                        location.replace(url);
                    } else {
                        location.href = url;
                    }
                }
                return self;
            } else {
                return newLocation || location.href.replace(/%27/g, "'");
            }
        };
        var urlChangeListeners = [], urlChangeInit = false;
        function fireUrlChange() {
            newLocation = null;
            if (lastBrowserUrl == self.url()) return;
            lastBrowserUrl = self.url();
            forEach(urlChangeListeners, function(listener) {
                listener(self.url());
            });
        }
        self.onUrlChange = function(callback) {
            if (!urlChangeInit) {
                if ($sniffer.history) jqLite(window).on("popstate", fireUrlChange);
                if ($sniffer.hashchange) jqLite(window).on("hashchange", fireUrlChange); else self.addPollFn(fireUrlChange);
                urlChangeInit = true;
            }
            urlChangeListeners.push(callback);
            return callback;
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        var lastCookies = {};
        var lastCookieString = "";
        var cookiePath = self.baseHref();
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (name) {
                if (value === undefined) {
                    rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
                } else {
                    if (isString(value)) {
                        cookieLength = (rawDocument.cookie = escape(name) + "=" + escape(value) + ";path=" + cookiePath).length + 1;
                        if (cookieLength > 4096) {
                            $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
                        }
                    }
                }
            } else {
                if (rawDocument.cookie !== lastCookieString) {
                    lastCookieString = rawDocument.cookie;
                    cookieArray = lastCookieString.split("; ");
                    lastCookies = {};
                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf("=");
                        if (index > 0) {
                            name = unescape(cookie.substring(0, index));
                            if (lastCookies[name] === undefined) {
                                lastCookies[name] = unescape(cookie.substring(index + 1));
                            }
                        }
                    }
                }
                return lastCookies;
            }
        };
        self.defer = function(fn, delay) {
            var timeoutId;
            outstandingRequestCount++;
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId];
                completeOutstandingRequest(fn);
            }, delay || 0);
            pendingDeferIds[timeoutId] = true;
            return timeoutId;
        };
        self.defer.cancel = function(deferId) {
            if (pendingDeferIds[deferId]) {
                delete pendingDeferIds[deferId];
                clearTimeout(deferId);
                completeOutstandingRequest(noop);
                return true;
            }
            return false;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            var caches = {};
            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                }
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (isUndefined(value)) return;
                        if (!(key in data)) size++;
                        data[key] = value;
                        if (size > capacity) {
                            this.remove(staleEnd.key);
                        }
                        return value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            if (lruEntry == freshEnd) freshEnd = lruEntry.p;
                            if (lruEntry == staleEnd) staleEnd = lruEntry.n;
                            link(lruEntry.n, lruEntry.p);
                            delete lruHash[key];
                        }
                        delete data[key];
                        size--;
                    },
                    removeAll: function() {
                        data = {};
                        size = 0;
                        lruHash = {};
                        freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null;
                        stats = null;
                        lruHash = null;
                        delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
                function refresh(entry) {
                    if (entry != freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry;
                        } else if (staleEnd == entry) {
                            staleEnd = entry.n;
                        }
                        link(entry.n, entry.p);
                        link(entry, freshEnd);
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                }
                function link(nextEntry, prevEntry) {
                    if (nextEntry != prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry;
                        if (prevEntry) prevEntry.n = nextEntry;
                    }
                }
            }
            cacheFactory.info = function() {
                var info = {};
                forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                });
                return info;
            };
            cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            };
            return cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    var $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w_\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w_\-]+)(?:\:([^;]+))?;?)/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        this.directive = function registerDirective(name, directiveFactory) {
            assertNotHasOwnProperty(name, "directive");
            if (isString(name)) {
                assertArg(directiveFactory, "directiveFactory");
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = [];
                    $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                        var directives = [];
                        forEach(hasDirectives[name], function(directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                if (isFunction(directive)) {
                                    directive = {
                                        compile: valueFn(directive)
                                    };
                                } else if (!directive.compile && directive.link) {
                                    directive.compile = valueFn(directive.link);
                                }
                                directive.priority = directive.priority || 0;
                                directive.index = index;
                                directive.name = directive.name || name;
                                directive.require = directive.require || directive.controller && directive.name;
                                directive.restrict = directive.restrict || "A";
                                directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                        return directives;
                    } ]);
                }
                hasDirectives[name].push(directiveFactory);
            } else {
                forEach(name, reverseParams(registerDirective));
            }
            return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
            }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
            }
        };
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$http", "$templateCache", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            var Attributes = function(element, attr) {
                this.$$element = element;
                this.$attr = attr || {};
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.addClass(this.$$element, classVal);
                    }
                },
                $removeClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.removeClass(this.$$element, classVal);
                    }
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    if (toAdd.length === 0) {
                        $animate.removeClass(this.$$element, toRemove);
                    } else if (toRemove.length === 0) {
                        $animate.addClass(this.$$element, toAdd);
                    } else {
                        $animate.setClass(this.$$element, toAdd, toRemove);
                    }
                },
                $set: function(key, value, writeAttr, attrName) {
                    var booleanKey = getBooleanAttrName(this.$$element[0], key), normalizedVal, nodeName;
                    if (booleanKey) {
                        this.$$element.prop(key, value);
                        attrName = booleanKey;
                    }
                    this[key] = value;
                    if (attrName) {
                        this.$attr[key] = attrName;
                    } else {
                        attrName = this.$attr[key];
                        if (!attrName) {
                            this.$attr[key] = attrName = snake_case(key, "-");
                        }
                    }
                    nodeName = nodeName_(this.$$element);
                    if (nodeName === "A" && key === "href" || nodeName === "IMG" && key === "src") {
                        this[key] = value = $$sanitizeUri(value, key === "src");
                    }
                    if (writeAttr !== false) {
                        if (value === null || value === undefined) {
                            this.$$element.removeAttr(attrName);
                        } else {
                            this.$$element.attr(attrName, value);
                        }
                    }
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[key], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
                    listeners.push(fn);
                    $rootScope.$evalAsync(function() {
                        if (!listeners.$$inter) {
                            fn(attrs[key]);
                        }
                    });
                    return fn;
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == "{{" || endSymbol == "}}" ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            return compile;
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                    $compileNodes = jqLite($compileNodes);
                }
                forEach($compileNodes, function(node, index) {
                    if (node.nodeType == 3 && node.nodeValue.match(/\S+/)) {
                        $compileNodes[index] = node = jqLite(node).wrap("<span></span>").parent()[0];
                    }
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                safeAddClass($compileNodes, "ng-scope");
                return function publicLinkFn(scope, cloneConnectFn, transcludeControllers, parentBoundTranscludeFn) {
                    assertArg(scope, "scope");
                    var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
                    forEach(transcludeControllers, function(instance, name) {
                        $linkNode.data("$" + name + "Controller", instance);
                    });
                    for (var i = 0, ii = $linkNode.length; i < ii; i++) {
                        var node = $linkNode[i], nodeType = node.nodeType;
                        if (nodeType === 1 || nodeType === 9) {
                            $linkNode.eq(i).data("$scope", scope);
                        }
                    }
                    if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                    if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                    return $linkNode;
                };
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound;
                for (var i = 0; i < nodeList.length; i++) {
                    attrs = new Attributes();
                    directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                    if (nodeLinkFn && nodeLinkFn.scope) {
                        safeAddClass(attrs.$$element, "ng-scope");
                    }
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                    linkFns.push(nodeLinkFn, childLinkFn);
                    linkFnFound = linkFnFound || nodeLinkFn || childLinkFn;
                    previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, n, childBoundTranscludeFn;
                    var nodeListLength = nodeList.length, stableNodeList = new Array(nodeListLength);
                    for (i = 0; i < nodeListLength; i++) {
                        stableNodeList[i] = nodeList[i];
                    }
                    for (i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
                        node = stableNodeList[n];
                        nodeLinkFn = linkFns[i++];
                        childLinkFn = linkFns[i++];
                        if (nodeLinkFn) {
                            if (nodeLinkFn.scope) {
                                childScope = scope.$new();
                                jqLite.data(node, "$scope", childScope);
                            } else {
                                childScope = scope;
                            }
                            if (nodeLinkFn.transcludeOnThisElement) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                childBoundTranscludeFn = parentBoundTranscludeFn;
                            } else if (!parentBoundTranscludeFn && transcludeFn) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                            } else {
                                childBoundTranscludeFn = null;
                            }
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                        } else if (childLinkFn) {
                            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                        }
                    }
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers) {
                    var scopeCreated = false;
                    if (!transcludedScope) {
                        transcludedScope = scope.$new();
                        transcludedScope.$$transcluded = true;
                        scopeCreated = true;
                    }
                    var clone = transcludeFn(transcludedScope, cloneFn, controllers, previousBoundTranscludeFn);
                    if (scopeCreated) {
                        clone.on("$destroy", function() {
                            transcludedScope.$destroy();
                        });
                    }
                    return clone;
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
                switch (nodeType) {
                  case 1:
                    addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = false;
                        var attrEndName = false;
                        attr = nAttrs[j];
                        if (!msie || msie >= 8 || attr.specified) {
                            name = attr.name;
                            value = trim(attr.value);
                            ngAttrName = directiveNormalize(name);
                            if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                                name = snake_case(ngAttrName.substr(6), "-");
                            }
                            var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                            if (ngAttrName === directiveNName + "Start") {
                                attrStartName = name;
                                attrEndName = name.substr(0, name.length - 5) + "end";
                                name = name.substr(0, name.length - 6);
                            }
                            nName = directiveNormalize(name.toLowerCase());
                            attrsMap[nName] = name;
                            if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                                attrs[nName] = value;
                                if (getBooleanAttrName(node, nName)) {
                                    attrs[nName] = true;
                                }
                            }
                            addAttrInterpolateDirective(node, directives, value, nName);
                            addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                        }
                    }
                    className = node.className;
                    if (isString(className) && className !== "") {
                        while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                            nName = directiveNormalize(match[2]);
                            if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[3]);
                            }
                            className = className.substr(match.index + match[0].length);
                        }
                    }
                    break;

                  case 3:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case 8:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                        if (match) {
                            nName = directiveNormalize(match[1]);
                            if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[2]);
                            }
                        }
                    } catch (e) {}
                    break;
                }
                directives.sort(byPriority);
                return directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    var startNode = node;
                    do {
                        if (!node) {
                            throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        }
                        if (node.nodeType == 1) {
                            if (node.hasAttribute(attrStart)) depth++;
                            if (node.hasAttribute(attrEnd)) depth--;
                        }
                        nodes.push(node);
                        node = node.nextSibling;
                    } while (depth > 0);
                } else {
                    nodes.push(node);
                }
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    element = groupScan(element[0], attrStart, attrEnd);
                    return linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, directiveValue;
                for (var i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start;
                    var attrEnd = directive.$$end;
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd);
                    }
                    $template = undefined;
                    if (terminalPriority > directive.priority) {
                        break;
                    }
                    if (directiveValue = directive.scope) {
                        newScopeDirective = newScopeDirective || directive;
                        if (!directive.templateUrl) {
                            assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                            if (isObject(directiveValue)) {
                                newIsolateScopeDirective = directive;
                            }
                        }
                    }
                    directiveName = directive.name;
                    if (!directive.templateUrl && directive.controller) {
                        directiveValue = directive.controller;
                        controllerDirectives = controllerDirectives || {};
                        assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                        controllerDirectives[directiveName] = directive;
                    }
                    if (directiveValue = directive.transclude) {
                        hasTranscludeDirective = true;
                        if (!directive.$$tlb) {
                            assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                            nonTlbTranscludeDirective = directive;
                        }
                        if (directiveValue == "element") {
                            hasElementTranscludeDirective = true;
                            terminalPriority = directive.priority;
                            $template = $compileNode;
                            $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " "));
                            compileNode = $compileNode[0];
                            replaceWith(jqCollection, sliceArgs($template), compileNode);
                            childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            });
                        } else {
                            $template = jqLite(jqLiteClone(compileNode)).contents();
                            $compileNode.empty();
                            childTranscludeFn = compile($template, transcludeFn);
                        }
                    }
                    if (directive.template) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                        directiveValue = denormalizeTemplate(directiveValue);
                        if (directive.replace) {
                            replaceDirective = directive;
                            if (jqLiteIsTextNode(directiveValue)) {
                                $template = [];
                            } else {
                                $template = jqLite(trim(directiveValue));
                            }
                            compileNode = $template[0];
                            if ($template.length != 1 || compileNode.nodeType !== 1) {
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                            }
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {
                                $attr: {}
                            };
                            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            if (newIsolateScopeDirective) {
                                markDirectivesAsIsolate(templateDirectives);
                            }
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                            ii = directives.length;
                        } else {
                            $compileNode.html(directiveValue);
                        }
                    }
                    if (directive.templateUrl) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        if (directive.replace) {
                            replaceDirective = directive;
                        }
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        });
                        ii = directives.length;
                    } else if (directive.compile) {
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                            if (isFunction(linkFn)) {
                                addLinkFns(null, linkFn, attrStart, attrEnd);
                            } else if (linkFn) {
                                addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                            }
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode));
                        }
                    }
                    if (directive.terminal) {
                        nodeLinkFn.terminal = true;
                        terminalPriority = Math.max(terminalPriority, directive.priority);
                    }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                        pre.require = directive.require;
                        pre.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            pre = cloneAndAnnotateFn(pre, {
                                isolateScope: true
                            });
                        }
                        preLinkFns.push(pre);
                    }
                    if (post) {
                        if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                        post.require = directive.require;
                        post.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            post = cloneAndAnnotateFn(post, {
                                isolateScope: true
                            });
                        }
                        postLinkFns.push(post);
                    }
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value, retrievalMethod = "data", optional = false;
                    if (isString(require)) {
                        while ((value = require.charAt(0)) == "^" || value == "?") {
                            require = require.substr(1);
                            if (value == "^") {
                                retrievalMethod = "inheritedData";
                            }
                            optional = optional || value == "?";
                        }
                        value = null;
                        if (elementControllers && retrievalMethod === "data") {
                            value = elementControllers[require];
                        }
                        value = value || $element[retrievalMethod]("$" + require + "Controller");
                        if (!value && !optional) {
                            throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                        }
                        return value;
                    } else if (isArray(require)) {
                        value = [];
                        forEach(require, function(require) {
                            value.push(getControllers(directiveName, require, $element, elementControllers));
                        });
                    }
                    return value;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var attrs, $element, i, ii, linkFn, controller, isolateScope, elementControllers = {}, transcludeFn;
                    attrs = compileNode === linkNode ? templateAttrs : shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
                    $element = attrs.$$element;
                    if (newIsolateScopeDirective) {
                        var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
                        isolateScope = scope.$new(true);
                        if (templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)) {
                            $element.data("$isolateScope", isolateScope);
                        } else {
                            $element.data("$isolateScopeNoTemplate", isolateScope);
                        }
                        safeAddClass($element, "ng-isolate-scope");
                        forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {
                            var match = definition.match(LOCAL_REGEXP) || [], attrName = match[3] || scopeName, optional = match[2] == "?", mode = match[1], lastValue, parentGet, parentSet, compare;
                            isolateScope.$$isolateBindings[scopeName] = mode + attrName;
                            switch (mode) {
                              case "@":
                                attrs.$observe(attrName, function(value) {
                                    isolateScope[scopeName] = value;
                                });
                                attrs.$$observers[attrName].$$scope = scope;
                                if (attrs[attrName]) {
                                    isolateScope[scopeName] = $interpolate(attrs[attrName])(scope);
                                }
                                break;

                              case "=":
                                if (optional && !attrs[attrName]) {
                                    return;
                                }
                                parentGet = $parse(attrs[attrName]);
                                if (parentGet.literal) {
                                    compare = equals;
                                } else {
                                    compare = function(a, b) {
                                        return a === b || a !== a && b !== b;
                                    };
                                }
                                parentSet = parentGet.assign || function() {
                                    lastValue = isolateScope[scopeName] = parentGet(scope);
                                    throw $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name);
                                };
                                lastValue = isolateScope[scopeName] = parentGet(scope);
                                isolateScope.$watch(function parentValueWatch() {
                                    var parentValue = parentGet(scope);
                                    if (!compare(parentValue, isolateScope[scopeName])) {
                                        if (!compare(parentValue, lastValue)) {
                                            isolateScope[scopeName] = parentValue;
                                        } else {
                                            parentSet(scope, parentValue = isolateScope[scopeName]);
                                        }
                                    }
                                    return lastValue = parentValue;
                                }, null, parentGet.literal);
                                break;

                              case "&":
                                parentGet = $parse(attrs[attrName]);
                                isolateScope[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                                break;

                              default:
                                throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", newIsolateScopeDirective.name, scopeName, definition);
                            }
                        });
                    }
                    transcludeFn = boundTranscludeFn && controllersBoundTransclude;
                    if (controllerDirectives) {
                        forEach(controllerDirectives, function(directive) {
                            var locals = {
                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                $element: $element,
                                $attrs: attrs,
                                $transclude: transcludeFn
                            }, controllerInstance;
                            controller = directive.controller;
                            if (controller == "@") {
                                controller = attrs[directive.name];
                            }
                            controllerInstance = $controller(controller, locals);
                            elementControllers[directive.name] = controllerInstance;
                            if (!hasElementTranscludeDirective) {
                                $element.data("$" + directive.name + "Controller", controllerInstance);
                            }
                            if (directive.controllerAs) {
                                locals.$scope[directive.controllerAs] = controllerInstance;
                            }
                        });
                    }
                    for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                        try {
                            linkFn = preLinkFns[i];
                            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element));
                        }
                    }
                    var scopeToChild = scope;
                    if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                        scopeToChild = isolateScope;
                    }
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                    for (i = postLinkFns.length - 1; i >= 0; i--) {
                        try {
                            linkFn = postLinkFns[i];
                            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element));
                        }
                    }
                    function controllersBoundTransclude(scope, cloneAttachFn) {
                        var transcludeControllers;
                        if (arguments.length < 2) {
                            cloneAttachFn = scope;
                            scope = undefined;
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers;
                        }
                        return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers);
                    }
                }
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                    directives[j] = inherit(directives[j], {
                        $$isolateScope: true
                    });
                }
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        try {
                            directive = directives[i];
                            if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                                if (startAttrName) {
                                    directive = inherit(directive, {
                                        $$start: startAttrName,
                                        $$end: endAttrName
                                    });
                                }
                                tDirectives.push(directive);
                                match = directive;
                            }
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                }
                return match;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    if (key.charAt(0) != "$") {
                        if (src[key] && src[key] !== value) {
                            value += (key === "style" ? ";" : " ") + src[key];
                        }
                        dst.$set(key, value, true, srcAttr[key]);
                    }
                });
                forEach(src, function(value, key) {
                    if (key == "class") {
                        safeAddClass($element, value);
                        dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value;
                    } else if (key == "style") {
                        $element.attr("style", $element.attr("style") + ";" + value);
                        dst["style"] = (dst["style"] ? dst["style"] + ";" : "") + value;
                    } else if (key.charAt(0) != "$" && !dst.hasOwnProperty(key)) {
                        dst[key] = value;
                        dstAttr[key] = srcAttr[key];
                    }
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl;
                $compileNode.empty();
                $http.get($sce.getTrustedResourceUrl(templateUrl), {
                    cache: $templateCache
                }).success(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    content = denormalizeTemplate(content);
                    if (origAsyncDirective.replace) {
                        if (jqLiteIsTextNode(content)) {
                            $template = [];
                        } else {
                            $template = jqLite(trim(content));
                        }
                        compileNode = $template[0];
                        if ($template.length != 1 || compileNode.nodeType !== 1) {
                            throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        }
                        tempTemplateAttrs = {
                            $attr: {}
                        };
                        replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        if (isObject(origAsyncDirective.scope)) {
                            markDirectivesAsIsolate(templateDirectives);
                        }
                        directives = templateDirectives.concat(directives);
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else {
                        compileNode = beforeTemplateCompileNode;
                        $compileNode.html(content);
                    }
                    directives.unshift(derivedSyncDirective);
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                    forEach($rootElement, function(node, i) {
                        if (node == compileNode) {
                            $rootElement[i] = $compileNode[0];
                        }
                    });
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                    while (linkQueue.length) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                linkNode = jqLiteClone(compileNode);
                            }
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                            safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn;
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                    }
                    linkQueue = null;
                }).error(function(response, code, headers, config) {
                    throw $compileMinErr("tpload", "Failed to load template: {0}", config.url);
                });
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    if (linkQueue) {
                        linkQueue.push(scope);
                        linkQueue.push(node);
                        linkQueue.push(rootElement);
                        linkQueue.push(childBoundTranscludeFn);
                    } else {
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                    }
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                if (diff !== 0) return diff;
                if (a.name !== b.name) return a.name < b.name ? -1 : 1;
                return a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective) {
                    throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
                }
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                    directives.push({
                        priority: 0,
                        compile: function textInterpolateCompileFn(templateNode) {
                            var parent = templateNode.parent(), hasCompileParent = parent.length;
                            if (hasCompileParent) safeAddClass(templateNode.parent(), "ng-binding");
                            return function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent(), bindings = parent.data("$binding") || [];
                                bindings.push(interpolateFn);
                                parent.data("$binding", bindings);
                                if (!hasCompileParent) safeAddClass(parent, "ng-binding");
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value;
                                });
                            };
                        }
                    });
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if (attrNormalizedName == "srcdoc") {
                    return $sce.HTML;
                }
                var tag = nodeName_(node);
                if (attrNormalizedName == "xlinkHref" || tag == "FORM" && attrNormalizedName == "action" || tag != "IMG" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc")) {
                    return $sce.RESOURCE_URL;
                }
            }
            function addAttrInterpolateDirective(node, directives, value, name) {
                var interpolateFn = $interpolate(value, true);
                if (!interpolateFn) return;
                if (name === "multiple" && nodeName_(node) === "SELECT") {
                    throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                }
                directives.push({
                    priority: 100,
                    compile: function() {
                        return {
                            pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                var $$observers = attr.$$observers || (attr.$$observers = {});
                                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                    throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                                }
                                interpolateFn = $interpolate(attr[name], true, getTrustedContext(node, name));
                                if (!interpolateFn) return;
                                attr[name] = interpolateFn(scope);
                                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                    if (name === "class" && newValue != oldValue) {
                                        attr.$updateClass(newValue, oldValue);
                                    } else {
                                        attr.$set(name, newValue);
                                    }
                                });
                            }
                        };
                    }
                });
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                if ($rootElement) {
                    for (i = 0, ii = $rootElement.length; i < ii; i++) {
                        if ($rootElement[i] == firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                            j2++) {
                                if (j2 < jj) {
                                    $rootElement[j] = $rootElement[j2];
                                } else {
                                    delete $rootElement[j];
                                }
                            }
                            $rootElement.length -= removeCount - 1;
                            break;
                        }
                    }
                }
                if (parent) {
                    parent.replaceChild(newNode, firstElementToRemove);
                }
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove);
                newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
                for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove();
                    fragment.appendChild(element);
                    delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
        } ];
    }
    var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
    function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j]) continue outer;
            }
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function $ControllerProvider() {
        var controllers = {}, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller");
            if (isObject(name)) {
                extend(controllers, name);
            } else {
                controllers[name] = constructor;
            }
        };
        this.$get = [ "$injector", "$window", function($injector, $window) {
            return function(expression, locals) {
                var instance, match, constructor, identifier;
                if (isString(expression)) {
                    match = expression.match(CNTRL_REG), constructor = match[1], identifier = match[3];
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || getter($window, constructor, true);
                    assertArgFn(expression, constructor, true);
                }
                instance = $injector.instantiate(expression, locals);
                if (identifier) {
                    if (!(locals && typeof locals.$scope === "object")) {
                        throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier);
                    }
                    locals.$scope[identifier] = instance;
                }
                return instance;
            };
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function parseHeaders(headers) {
        var parsed = {}, key, val, i;
        if (!headers) return parsed;
        forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":");
            key = lowercase(trim(line.substr(0, i)));
            val = trim(line.substr(i + 1));
            if (key) {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
        });
        return parsed;
    }
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function(name) {
            if (!headersObj) headersObj = parseHeaders(headers);
            if (name) {
                return headersObj[lowercase(name)] || null;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, fns) {
        if (isFunction(fns)) return fns(data, headers);
        forEach(fns, function(fn) {
            data = fn(data, headers);
        });
        return data;
    }
    function isSuccess(status) {
        return 200 <= status && status < 300;
    }
    function $HttpProvider() {
        var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/, CONTENT_TYPE_APPLICATION_JSON = {
            "Content-Type": "application/json;charset=utf-8"
        };
        var defaults = this.defaults = {
            transformResponse: [ function(data) {
                if (isString(data)) {
                    data = data.replace(PROTECTION_PREFIX, "");
                    if (JSON_START.test(data) && JSON_END.test(data)) data = fromJson(data);
                }
                return data;
            } ],
            transformRequest: [ function(d) {
                return isObject(d) && !isFile(d) && !isBlob(d) ? toJson(d) : d;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        };
        var interceptorFactories = this.interceptors = [];
        var responseInterceptorFactories = this.responseInterceptors = [];
        this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            var defaultCache = $cacheFactory("$http");
            var reversedInterceptors = [];
            forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            forEach(responseInterceptorFactories, function(interceptorFactory, index) {
                var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory);
                reversedInterceptors.splice(index, 0, {
                    response: function(response) {
                        return responseFn($q.when(response));
                    },
                    responseError: function(response) {
                        return responseFn($q.reject(response));
                    }
                });
            });
            function $http(requestConfig) {
                var config = {
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                };
                var headers = mergeHeaders(requestConfig);
                extend(config, requestConfig);
                config.headers = headers;
                config.method = uppercase(config.method);
                var serverRequest = function(config) {
                    headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
                    if (isUndefined(reqData)) {
                        forEach(headers, function(value, header) {
                            if (lowercase(header) === "content-type") {
                                delete headers[header];
                            }
                        });
                    }
                    if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                        config.withCredentials = defaults.withCredentials;
                    }
                    return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
                };
                var chain = [ serverRequest, undefined ];
                var promise = $q.when(config);
                forEach(reversedInterceptors, function(interceptor) {
                    if (interceptor.request || interceptor.requestError) {
                        chain.unshift(interceptor.request, interceptor.requestError);
                    }
                    if (interceptor.response || interceptor.responseError) {
                        chain.push(interceptor.response, interceptor.responseError);
                    }
                });
                while (chain.length) {
                    var thenFn = chain.shift();
                    var rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                promise.success = function(fn) {
                    promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                promise.error = function(fn) {
                    promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                return promise;
                function transformResponse(response) {
                    var resp = extend({}, response, {
                        data: transformData(response.data, response.headers, config.transformResponse)
                    });
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function mergeHeaders(config) {
                    var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) {
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                continue defaultHeadersIteration;
                            }
                        }
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    execHeaders(reqHeaders);
                    return reqHeaders;
                    function execHeaders(headers) {
                        var headerContent;
                        forEach(headers, function(headerFn, header) {
                            if (isFunction(headerFn)) {
                                headerContent = headerFn();
                                if (headerContent != null) {
                                    headers[header] = headerContent;
                                } else {
                                    delete headers[header];
                                }
                            }
                        });
                    }
                }
            }
            $http.pendingRequests = [];
            createShortMethods("get", "delete", "head", "jsonp");
            createShortMethodsWithData("post", "put");
            $http.defaults = defaults;
            return $http;
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData, reqHeaders) {
                var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, url = buildUrl(config.url, config.params);
                $http.pendingRequests.push(config);
                promise.then(removePendingReq, removePendingReq);
                if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                    cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                }
                if (cache) {
                    cachedResp = cache.get(url);
                    if (isDefined(cachedResp)) {
                        if (isPromiseLike(cachedResp)) {
                            cachedResp.then(removePendingReq, removePendingReq);
                            return cachedResp;
                        } else {
                            if (isArray(cachedResp)) {
                                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                            } else {
                                resolvePromise(cachedResp, 200, {}, "OK");
                            }
                        }
                    } else {
                        cache.put(url, promise);
                    }
                }
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    if (xsrfValue) {
                        reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                    }
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
                function done(status, response, headersString, statusText) {
                    if (cache) {
                        if (isSuccess(status)) {
                            cache.put(url, [ status, response, parseHeaders(headersString), statusText ]);
                        } else {
                            cache.remove(url);
                        }
                    }
                    resolvePromise(response, status, headersString, statusText);
                    if (!$rootScope.$$phase) $rootScope.$apply();
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = Math.max(status, 0);
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function removePendingReq() {
                    var idx = indexOf($http.pendingRequests, config);
                    if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                }
            }
            function buildUrl(url, params) {
                if (!params) return url;
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value === null || isUndefined(value)) return;
                    if (!isArray(value)) value = [ value ];
                    forEach(value, function(v) {
                        if (isObject(v)) {
                            if (isDate(v)) {
                                v = v.toISOString();
                            } else {
                                v = toJson(v);
                            }
                        }
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    });
                });
                if (parts.length > 0) {
                    url += (url.indexOf("?") == -1 ? "?" : "&") + parts.join("&");
                }
                return url;
            }
        } ];
    }
    function createXhr(method) {
        if (msie <= 8 && (!method.match(/^(get|post|head|put|delete|options)$/i) || !window.XMLHttpRequest)) {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } else if (window.XMLHttpRequest) {
            return new window.XMLHttpRequest();
        }
        throw minErr("$httpBackend")("noxhr", "This browser does not support XMLHttpRequest.");
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        var ABORTED = -1;
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            var status;
            $browser.$$incOutstandingRequestCount();
            url = url || $browser.url();
            if (lowercase(method) == "jsonp") {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data;
                    callbacks[callbackId].called = true;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text);
                    callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr(method);
                xhr.open(method, url, true);
                forEach(headers, function(value, key) {
                    if (isDefined(value)) {
                        xhr.setRequestHeader(key, value);
                    }
                });
                xhr.onreadystatechange = function() {
                    if (xhr && xhr.readyState == 4) {
                        var responseHeaders = null, response = null, statusText = "";
                        if (status !== ABORTED) {
                            responseHeaders = xhr.getAllResponseHeaders();
                            response = "response" in xhr ? xhr.response : xhr.responseText;
                        }
                        if (!(status === ABORTED && msie < 10)) {
                            statusText = xhr.statusText;
                        }
                        completeRequest(callback, status || xhr.status, response, responseHeaders, statusText);
                    }
                };
                if (withCredentials) {
                    xhr.withCredentials = true;
                }
                if (responseType) {
                    try {
                        xhr.responseType = responseType;
                    } catch (e) {
                        if (responseType !== "json") {
                            throw e;
                        }
                    }
                }
                xhr.send(post || null);
            }
            if (timeout > 0) {
                var timeoutId = $browserDefer(timeoutRequest, timeout);
            } else if (isPromiseLike(timeout)) {
                timeout.then(timeoutRequest);
            }
            function timeoutRequest() {
                status = ABORTED;
                jsonpDone && jsonpDone();
                xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                timeoutId && $browserDefer.cancel(timeoutId);
                jsonpDone = xhr = null;
                if (status === 0) {
                    status = response ? 200 : urlResolve(url).protocol == "file" ? 404 : 0;
                }
                status = status === 1223 ? 204 : status;
                statusText = statusText || "";
                callback(status, response, headersString, statusText);
                $browser.$$completeOutstandingRequest(noop);
            }
        };
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            script.type = "text/javascript";
            script.src = url;
            script.async = true;
            callback = function(event) {
                removeEventListenerFn(script, "load", callback);
                removeEventListenerFn(script, "error", callback);
                rawDocument.body.removeChild(script);
                script = null;
                var status = -1;
                var text = "unknown";
                if (event) {
                    if (event.type === "load" && !callbacks[callbackId].called) {
                        event = {
                            type: "error"
                        };
                    }
                    text = event.type;
                    status = event.type === "error" ? 404 : 200;
                }
                if (done) {
                    done(status, text);
                }
            };
            addEventListenerFn(script, "load", callback);
            addEventListenerFn(script, "error", callback);
            if (msie <= 8) {
                script.onreadystatechange = function() {
                    if (isString(script.readyState) && /loaded|complete/.test(script.readyState)) {
                        script.onreadystatechange = null;
                        callback({
                            type: "load"
                        });
                    }
                };
            }
            rawDocument.body.appendChild(script);
            return callback;
        }
    }
    var $interpolateMinErr = minErr("$interpolate");
    function $InterpolateProvider() {
        var startSymbol = "{{";
        var endSymbol = "}}";
        this.startSymbol = function(value) {
            if (value) {
                startSymbol = value;
                return this;
            } else {
                return startSymbol;
            }
        };
        this.endSymbol = function(value) {
            if (value) {
                endSymbol = value;
                return this;
            } else {
                return endSymbol;
            }
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
            function $interpolate(text, mustHaveExpression, trustedContext) {
                var startIndex, endIndex, index = 0, parts = [], length = text.length, hasInterpolation = false, fn, exp, concat = [];
                while (index < length) {
                    if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
                        index != startIndex && parts.push(text.substring(index, startIndex));
                        parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
                        fn.exp = exp;
                        index = endIndex + endSymbolLength;
                        hasInterpolation = true;
                    } else {
                        index != length && parts.push(text.substring(index));
                        index = length;
                    }
                }
                if (!(length = parts.length)) {
                    parts.push("");
                    length = 1;
                }
                if (trustedContext && parts.length > 1) {
                    throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
                }
                if (!mustHaveExpression || hasInterpolation) {
                    concat.length = length;
                    fn = function(context) {
                        try {
                            for (var i = 0, ii = length, part; i < ii; i++) {
                                if (typeof (part = parts[i]) == "function") {
                                    part = part(context);
                                    if (trustedContext) {
                                        part = $sce.getTrusted(trustedContext, part);
                                    } else {
                                        part = $sce.valueOf(part);
                                    }
                                    if (part == null) {
                                        part = "";
                                    } else {
                                        switch (typeof part) {
                                          case "string":
                                            {
                                                break;
                                            }

                                          case "number":
                                            {
                                                part = "" + part;
                                                break;
                                            }

                                          default:
                                            {
                                                part = toJson(part);
                                            }
                                        }
                                    }
                                }
                                concat[i] = part;
                            }
                            return concat.join("");
                        } catch (err) {
                            var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                            $exceptionHandler(newErr);
                        }
                    };
                    fn.exp = text;
                    fn.parts = parts;
                    return fn;
                }
            }
            $interpolate.startSymbol = function() {
                return startSymbol;
            };
            $interpolate.endSymbol = function() {
                return endSymbol;
            };
            return $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", function($rootScope, $window, $q) {
            var intervals = {};
            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval, clearInterval = $window.clearInterval, deferred = $q.defer(), promise = deferred.promise, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply;
                count = isDefined(count) ? count : 0;
                promise.then(null, null, fn);
                promise.$$intervalId = setInterval(function tick() {
                    deferred.notify(iteration++);
                    if (count > 0 && iteration >= count) {
                        deferred.resolve(iteration);
                        clearInterval(promise.$$intervalId);
                        delete intervals[promise.$$intervalId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                intervals[promise.$$intervalId] = deferred;
                return promise;
            }
            interval.cancel = function(promise) {
                if (promise && promise.$$intervalId in intervals) {
                    intervals[promise.$$intervalId].reject("canceled");
                    $window.clearInterval(promise.$$intervalId);
                    delete intervals[promise.$$intervalId];
                    return true;
                }
                return false;
            };
            return interval;
        } ];
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [ {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "",
                        posSuf: "",
                        negPre: "(",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    } ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: [ "AM", "PM" ],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a"
                },
                pluralCat: function(num) {
                    if (num === 1) {
                        return "one";
                    }
                    return "other";
                }
            };
        };
    }
    var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    };
    var $locationMinErr = minErr("$location");
    function encodePath(path) {
        var segments = path.split("/"), i = segments.length;
        while (i--) {
            segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
        var parsedUrl = urlResolve(absoluteUrl, appBase);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj, appBase) {
        var prefixed = relativeUrl.charAt(0) !== "/";
        if (prefixed) {
            relativeUrl = "/" + relativeUrl;
        }
        var match = urlResolve(relativeUrl, appBase);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != "/") {
            locationObj.$$path = "/" + locationObj.$$path;
        }
    }
    function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
            return whole.substr(begin.length);
        }
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return index == -1 ? url : url.substr(0, index);
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this, appBase);
        this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) {
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            }
            parseAppUrl(pathUrl, this, appBase);
            if (!this.$$path) {
                this.$$path = "/";
            }
            this.$$compose();
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$rewrite = function(url) {
            var appUrl, prevAppUrl;
            if ((appUrl = beginsWith(appBase, url)) !== undefined) {
                prevAppUrl = appUrl;
                if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
                    return appBaseNoFile + (beginsWith("/", appUrl) || appUrl);
                } else {
                    return appBase + prevAppUrl;
                }
            } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
                return appBaseNoFile + appUrl;
            } else if (appBaseNoFile == url + "/") {
                return appBaseNoFile;
            }
        };
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this, appBase);
        this.$$parse = function(url) {
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            var withoutHashUrl = withoutBaseUrl.charAt(0) == "#" ? beginsWith(hashPrefix, withoutBaseUrl) : this.$$html5 ? withoutBaseUrl : "";
            if (!isString(withoutHashUrl)) {
                throw $locationMinErr("ihshprfx", 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
            }
            parseAppUrl(withoutHashUrl, this, appBase);
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
            this.$$compose();
            function removeWindowsDriveName(path, url, base) {
                var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                var firstPathSegmentMatch;
                if (url.indexOf(base) === 0) {
                    url = url.replace(base, "");
                }
                if (windowsFilePathExp.exec(url)) {
                    return path;
                }
                firstPathSegmentMatch = windowsFilePathExp.exec(path);
                return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
            }
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        };
        this.$$rewrite = function(url) {
            if (stripHash(appBase) == stripHash(url)) {
                return url;
            }
        };
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$rewrite = function(url) {
            var appUrl;
            if (appBase == stripHash(url)) {
                return url;
            } else if (appUrl = beginsWith(appBaseNoFile, url)) {
                return appBase + hashPrefix + appUrl;
            } else if (appBaseNoFile === url + "/") {
                return appBaseNoFile;
            }
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    LocationHashbangInHtml5Url.prototype = LocationHashbangUrl.prototype = LocationHtml5Url.prototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            if (match[1]) this.path(decodeURIComponent(match[1]));
            if (match[2] || match[1]) this.search(match[3] || "");
            this.hash(match[5] || "");
            return this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            path = path ? path.toString() : "";
            return path.charAt(0) == "/" ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) {
                    search = search.toString();
                    this.$$search = parseKeyValue(search);
                } else if (isObject(search)) {
                    forEach(search, function(value, key) {
                        if (value == null) delete search[key];
                    });
                    this.$$search = search;
                } else {
                    throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                }
                break;

              default:
                if (isUndefined(paramValue) || paramValue === null) {
                    delete this.$$search[search];
                } else {
                    this.$$search[search] = paramValue;
                }
            }
            this.$$compose();
            return this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return hash ? hash.toString() : "";
        }),
        replace: function() {
            this.$$replace = true;
            return this;
        }
    };
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            if (isUndefined(value)) return this[property];
            this[property] = preprocess(value);
            this.$$compose();
            return this;
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = false;
        this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        };
        this.html5Mode = function(mode) {
            if (isDefined(mode)) {
                html5Mode = mode;
                return this;
            } else {
                return html5Mode;
            }
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", function($rootScope, $browser, $sniffer, $rootElement) {
            var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
            if (html5Mode) {
                appBase = serverBase(initialUrl) + (baseHref || "/");
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
            }
            $location = new LocationMode(appBase, "#" + hashPrefix);
            $location.$$parse($location.$$rewrite(initialUrl));
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            $rootElement.on("click", function(event) {
                if (event.ctrlKey || event.metaKey || event.which == 2) return;
                var elm = jqLite(event.target);
                while (lowercase(elm[0].nodeName) !== "a") {
                    if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                }
                var absHref = elm.prop("href");
                if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                    absHref = urlResolve(absHref.animVal).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref)) return;
                if (LocationMode === LocationHashbangInHtml5Url) {
                    var href = elm.attr("href") || elm.attr("xlink:href");
                    if (href && href.indexOf("://") < 0) {
                        var prefix = "#" + hashPrefix;
                        if (href[0] == "/") {
                            absHref = appBase + prefix + href;
                        } else if (href[0] == "#") {
                            absHref = appBase + prefix + ($location.path() || "/") + href;
                        } else {
                            var stack = $location.path().split("/"), parts = href.split("/");
                            if (stack.length === 2 && !stack[1]) stack.length = 1;
                            for (var i = 0; i < parts.length; i++) {
                                if (parts[i] == ".") continue; else if (parts[i] == "..") stack.pop(); else if (parts[i].length) stack.push(parts[i]);
                            }
                            absHref = appBase + prefix + stack.join("/");
                        }
                    }
                }
                var rewrittenUrl = $location.$$rewrite(absHref);
                if (absHref && !elm.attr("target") && rewrittenUrl && !event.isDefaultPrevented()) {
                    event.preventDefault();
                    if (rewrittenUrl != $browser.url()) {
                        $location.$$parse(rewrittenUrl);
                        $rootScope.$apply();
                        window.angular["ff-684208-preventDefault"] = true;
                    }
                }
            });
            if ($location.absUrl() != initialUrl) {
                $browser.url($location.absUrl(), true);
            }
            $browser.onUrlChange(function(newUrl) {
                if ($location.absUrl() != newUrl) {
                    $rootScope.$evalAsync(function() {
                        var oldUrl = $location.absUrl();
                        $location.$$parse(newUrl);
                        if ($rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl).defaultPrevented) {
                            $location.$$parse(oldUrl);
                            $browser.url(oldUrl);
                        } else {
                            afterLocationChange(oldUrl);
                        }
                    });
                    if (!$rootScope.$$phase) $rootScope.$digest();
                }
            });
            var changeCounter = 0;
            $rootScope.$watch(function $locationWatch() {
                var oldUrl = $browser.url();
                var currentReplace = $location.$$replace;
                if (!changeCounter || oldUrl != $location.absUrl()) {
                    changeCounter++;
                    $rootScope.$evalAsync(function() {
                        if ($rootScope.$broadcast("$locationChangeStart", $location.absUrl(), oldUrl).defaultPrevented) {
                            $location.$$parse(oldUrl);
                        } else {
                            $browser.url($location.absUrl(), currentReplace);
                            afterLocationChange(oldUrl);
                        }
                    });
                }
                $location.$$replace = false;
                return changeCounter;
            });
            return $location;
            function afterLocationChange(oldUrl) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl);
            }
        } ];
    }
    function $LogProvider() {
        var debug = true, self = this;
        this.debugEnabled = function(flag) {
            if (isDefined(flag)) {
                debug = flag;
                return this;
            } else {
                return debug;
            }
        };
        this.$get = [ "$window", function($window) {
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        if (debug) {
                            fn.apply(self, arguments);
                        }
                    };
                }()
            };
            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack) {
                        arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                    }
                }
                return arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                if (hasApply) {
                    return function() {
                        var args = [];
                        forEach(arguments, function(arg) {
                            args.push(formatError(arg));
                        });
                        return logFn.apply(console, args);
                    };
                }
                return function(arg1, arg2) {
                    logFn(arg1, arg2 == null ? "" : arg2);
                };
            }
        } ];
    }
    var $parseMinErr = minErr("$parse");
    var promiseWarningCache = {};
    var promiseWarning;
    function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
            throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! " + "Expression: {0}", fullExpression);
        }
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.document && obj.location && obj.alert && obj.setInterval) {
                throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === Object) {
                throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
        return obj;
    }
    var CALL = Function.prototype.call;
    var APPLY = Function.prototype.apply;
    var BIND = Function.prototype.bind;
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === CALL || obj === APPLY || BIND && obj === BIND) {
                throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
    }
    var OPERATORS = {
        "null": function() {
            return null;
        },
        "true": function() {
            return true;
        },
        "false": function() {
            return false;
        },
        undefined: noop,
        "+": function(self, locals, a, b) {
            a = a(self, locals);
            b = b(self, locals);
            if (isDefined(a)) {
                if (isDefined(b)) {
                    return a + b;
                }
                return a;
            }
            return isDefined(b) ? b : undefined;
        },
        "-": function(self, locals, a, b) {
            a = a(self, locals);
            b = b(self, locals);
            return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
        },
        "*": function(self, locals, a, b) {
            return a(self, locals) * b(self, locals);
        },
        "/": function(self, locals, a, b) {
            return a(self, locals) / b(self, locals);
        },
        "%": function(self, locals, a, b) {
            return a(self, locals) % b(self, locals);
        },
        "^": function(self, locals, a, b) {
            return a(self, locals) ^ b(self, locals);
        },
        "=": noop,
        "===": function(self, locals, a, b) {
            return a(self, locals) === b(self, locals);
        },
        "!==": function(self, locals, a, b) {
            return a(self, locals) !== b(self, locals);
        },
        "==": function(self, locals, a, b) {
            return a(self, locals) == b(self, locals);
        },
        "!=": function(self, locals, a, b) {
            return a(self, locals) != b(self, locals);
        },
        "<": function(self, locals, a, b) {
            return a(self, locals) < b(self, locals);
        },
        ">": function(self, locals, a, b) {
            return a(self, locals) > b(self, locals);
        },
        "<=": function(self, locals, a, b) {
            return a(self, locals) <= b(self, locals);
        },
        ">=": function(self, locals, a, b) {
            return a(self, locals) >= b(self, locals);
        },
        "&&": function(self, locals, a, b) {
            return a(self, locals) && b(self, locals);
        },
        "||": function(self, locals, a, b) {
            return a(self, locals) || b(self, locals);
        },
        "&": function(self, locals, a, b) {
            return a(self, locals) & b(self, locals);
        },
        "|": function(self, locals, a, b) {
            return b(self, locals)(self, locals, a(self, locals));
        },
        "!": function(self, locals, a) {
            return !a(self, locals);
        }
    };
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "\x0B",
        "'": "'",
        '"': '"'
    };
    var Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            this.text = text;
            this.index = 0;
            this.ch = undefined;
            this.lastCh = ":";
            this.tokens = [];
            while (this.index < this.text.length) {
                this.ch = this.text.charAt(this.index);
                if (this.is("\"'")) {
                    this.readString(this.ch);
                } else if (this.isNumber(this.ch) || this.is(".") && this.isNumber(this.peek())) {
                    this.readNumber();
                } else if (this.isIdent(this.ch)) {
                    this.readIdent();
                } else if (this.is("(){}[].,;:?")) {
                    this.tokens.push({
                        index: this.index,
                        text: this.ch
                    });
                    this.index++;
                } else if (this.isWhitespace(this.ch)) {
                    this.index++;
                    continue;
                } else {
                    var ch2 = this.ch + this.peek();
                    var ch3 = ch2 + this.peek(2);
                    var fn = OPERATORS[this.ch];
                    var fn2 = OPERATORS[ch2];
                    var fn3 = OPERATORS[ch3];
                    if (fn3) {
                        this.tokens.push({
                            index: this.index,
                            text: ch3,
                            fn: fn3
                        });
                        this.index += 3;
                    } else if (fn2) {
                        this.tokens.push({
                            index: this.index,
                            text: ch2,
                            fn: fn2
                        });
                        this.index += 2;
                    } else if (fn) {
                        this.tokens.push({
                            index: this.index,
                            text: this.ch,
                            fn: fn
                        });
                        this.index += 1;
                    } else {
                        this.throwError("Unexpected next character ", this.index, this.index + 1);
                    }
                }
                this.lastCh = this.ch;
            }
            return this.tokens;
        },
        is: function(chars) {
            return chars.indexOf(this.ch) !== -1;
        },
        was: function(chars) {
            return chars.indexOf(this.lastCh) !== -1;
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9";
        },
        isWhitespace: function(ch) {
            return ch === " " || ch === "\r" || ch === "	" || ch === "\n" || ch === "\x0B" || ch === "";
        },
        isIdent: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$";
        },
        isExpOperator: function(ch) {
            return ch === "-" || ch === "+" || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            var number = "";
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = lowercase(this.text.charAt(this.index));
                if (ch == "." || this.isNumber(ch)) {
                    number += ch;
                } else {
                    var peekCh = this.peek();
                    if (ch == "e" && this.isExpOperator(peekCh)) {
                        number += ch;
                    } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == "e") {
                        number += ch;
                    } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == "e") {
                        this.throwError("Invalid exponent");
                    } else {
                        break;
                    }
                }
                this.index++;
            }
            number = 1 * number;
            this.tokens.push({
                index: start,
                text: number,
                literal: true,
                constant: true,
                fn: function() {
                    return number;
                }
            });
        },
        readIdent: function() {
            var parser = this;
            var ident = "";
            var start = this.index;
            var lastDot, peekIndex, methodName, ch;
            while (this.index < this.text.length) {
                ch = this.text.charAt(this.index);
                if (ch === "." || this.isIdent(ch) || this.isNumber(ch)) {
                    if (ch === ".") lastDot = this.index;
                    ident += ch;
                } else {
                    break;
                }
                this.index++;
            }
            if (lastDot) {
                peekIndex = this.index;
                while (peekIndex < this.text.length) {
                    ch = this.text.charAt(peekIndex);
                    if (ch === "(") {
                        methodName = ident.substr(lastDot - start + 1);
                        ident = ident.substr(0, lastDot - start);
                        this.index = peekIndex;
                        break;
                    }
                    if (this.isWhitespace(ch)) {
                        peekIndex++;
                    } else {
                        break;
                    }
                }
            }
            var token = {
                index: start,
                text: ident
            };
            if (OPERATORS.hasOwnProperty(ident)) {
                token.fn = OPERATORS[ident];
                token.literal = true;
                token.constant = true;
            } else {
                var getter = getterFn(ident, this.options, this.text);
                token.fn = extend(function(self, locals) {
                    return getter(self, locals);
                }, {
                    assign: function(self, value) {
                        return setter(self, ident, value, parser.text, parser.options);
                    }
                });
            }
            this.tokens.push(token);
            if (methodName) {
                this.tokens.push({
                    index: lastDot,
                    text: "."
                });
                this.tokens.push({
                    index: lastDot + 1,
                    text: methodName
                });
            }
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                rawString += ch;
                if (escape) {
                    if (ch === "u") {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        if (!hex.match(/[\da-f]{4}/i)) this.throwError("Invalid unicode escape [\\u" + hex + "]");
                        this.index += 4;
                        string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string = string + (rep || ch);
                    }
                    escape = false;
                } else if (ch === "\\") {
                    escape = true;
                } else if (ch === quote) {
                    this.index++;
                    this.tokens.push({
                        index: start,
                        text: rawString,
                        string: string,
                        literal: true,
                        constant: true,
                        fn: function() {
                            return string;
                        }
                    });
                    return;
                } else {
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
    };
    Parser.ZERO = extend(function() {
        return 0;
    }, {
        constant: true
    });
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            this.text = text;
            this.tokens = this.lexer.lex(text);
            var value = this.statements();
            if (this.tokens.length !== 0) {
                this.throwError("is an unexpected token", this.tokens[0]);
            }
            value.literal = !!value.literal;
            value.constant = !!value.constant;
            return value;
        },
        primary: function() {
            var primary;
            if (this.expect("(")) {
                primary = this.filterChain();
                this.consume(")");
            } else if (this.expect("[")) {
                primary = this.arrayDeclaration();
            } else if (this.expect("{")) {
                primary = this.object();
            } else {
                var token = this.expect();
                primary = token.fn;
                if (!primary) {
                    this.throwError("not a primary expression", token);
                }
                primary.literal = !!token.literal;
                primary.constant = !!token.constant;
            }
            var next, context;
            while (next = this.expect("(", "[", ".")) {
                if (next.text === "(") {
                    primary = this.functionCall(primary, context);
                    context = null;
                } else if (next.text === "[") {
                    context = primary;
                    primary = this.objectIndex(primary);
                } else if (next.text === ".") {
                    context = primary;
                    primary = this.fieldAccess(primary);
                } else {
                    this.throwError("IMPOSSIBLE");
                }
            }
            return primary;
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        peekToken: function() {
            if (this.tokens.length === 0) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            if (this.tokens.length > 0) {
                var token = this.tokens[0];
                var t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                    return token;
                }
            }
            return false;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            if (token) {
                this.tokens.shift();
                return token;
            }
            return false;
        },
        consume: function(e1) {
            if (!this.expect(e1)) {
                this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
            }
        },
        unaryFn: function(fn, right) {
            return extend(function(self, locals) {
                return fn(self, locals, right);
            }, {
                constant: right.constant
            });
        },
        ternaryFn: function(left, middle, right) {
            return extend(function(self, locals) {
                return left(self, locals) ? middle(self, locals) : right(self, locals);
            }, {
                constant: left.constant && middle.constant && right.constant
            });
        },
        binaryFn: function(left, fn, right) {
            return extend(function(self, locals) {
                return fn(self, locals, left, right);
            }, {
                constant: left.constant && right.constant
            });
        },
        statements: function() {
            var statements = [];
            while (true) {
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) statements.push(this.filterChain());
                if (!this.expect(";")) {
                    return statements.length === 1 ? statements[0] : function(self, locals) {
                        var value;
                        for (var i = 0; i < statements.length; i++) {
                            var statement = statements[i];
                            if (statement) {
                                value = statement(self, locals);
                            }
                        }
                        return value;
                    };
                }
            }
        },
        filterChain: function() {
            var left = this.expression();
            var token;
            while (true) {
                if (token = this.expect("|")) {
                    left = this.binaryFn(left, token.fn, this.filter());
                } else {
                    return left;
                }
            }
        },
        filter: function() {
            var token = this.expect();
            var fn = this.$filter(token.text);
            var argsFn = [];
            while (true) {
                if (token = this.expect(":")) {
                    argsFn.push(this.expression());
                } else {
                    var fnInvoke = function(self, locals, input) {
                        var args = [ input ];
                        for (var i = 0; i < argsFn.length; i++) {
                            args.push(argsFn[i](self, locals));
                        }
                        return fn.apply(self, args);
                    };
                    return function() {
                        return fnInvoke;
                    };
                }
            }
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var left = this.ternary();
            var right;
            var token;
            if (token = this.expect("=")) {
                if (!left.assign) {
                    this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token);
                }
                right = this.ternary();
                return function(scope, locals) {
                    return left.assign(scope, right(scope, locals), locals);
                };
            }
            return left;
        },
        ternary: function() {
            var left = this.logicalOR();
            var middle;
            var token;
            if (token = this.expect("?")) {
                middle = this.assignment();
                if (token = this.expect(":")) {
                    return this.ternaryFn(left, middle, this.assignment());
                } else {
                    this.throwError("expected :", token);
                }
            } else {
                return left;
            }
        },
        logicalOR: function() {
            var left = this.logicalAND();
            var token;
            while (true) {
                if (token = this.expect("||")) {
                    left = this.binaryFn(left, token.fn, this.logicalAND());
                } else {
                    return left;
                }
            }
        },
        logicalAND: function() {
            var left = this.equality();
            var token;
            if (token = this.expect("&&")) {
                left = this.binaryFn(left, token.fn, this.logicalAND());
            }
            return left;
        },
        equality: function() {
            var left = this.relational();
            var token;
            if (token = this.expect("==", "!=", "===", "!==")) {
                left = this.binaryFn(left, token.fn, this.equality());
            }
            return left;
        },
        relational: function() {
            var left = this.additive();
            var token;
            if (token = this.expect("<", ">", "<=", ">=")) {
                left = this.binaryFn(left, token.fn, this.relational());
            }
            return left;
        },
        additive: function() {
            var left = this.multiplicative();
            var token;
            while (token = this.expect("+", "-")) {
                left = this.binaryFn(left, token.fn, this.multiplicative());
            }
            return left;
        },
        multiplicative: function() {
            var left = this.unary();
            var token;
            while (token = this.expect("*", "/", "%")) {
                left = this.binaryFn(left, token.fn, this.unary());
            }
            return left;
        },
        unary: function() {
            var token;
            if (this.expect("+")) {
                return this.primary();
            } else if (token = this.expect("-")) {
                return this.binaryFn(Parser.ZERO, token.fn, this.unary());
            } else if (token = this.expect("!")) {
                return this.unaryFn(token.fn, this.unary());
            } else {
                return this.primary();
            }
        },
        fieldAccess: function(object) {
            var parser = this;
            var field = this.expect().text;
            var getter = getterFn(field, this.options, this.text);
            return extend(function(scope, locals, self) {
                return getter(self || object(scope, locals));
            }, {
                assign: function(scope, value, locals) {
                    var o = object(scope, locals);
                    if (!o) object.assign(scope, o = {});
                    return setter(o, field, value, parser.text, parser.options);
                }
            });
        },
        objectIndex: function(obj) {
            var parser = this;
            var indexFn = this.expression();
            this.consume("]");
            return extend(function(self, locals) {
                var o = obj(self, locals), i = indexFn(self, locals), v, p;
                ensureSafeMemberName(i, parser.text);
                if (!o) return undefined;
                v = ensureSafeObject(o[i], parser.text);
                if (v && v.then && parser.options.unwrapPromises) {
                    p = v;
                    if (!("$$v" in v)) {
                        p.$$v = undefined;
                        p.then(function(val) {
                            p.$$v = val;
                        });
                    }
                    v = v.$$v;
                }
                return v;
            }, {
                assign: function(self, value, locals) {
                    var key = ensureSafeMemberName(indexFn(self, locals), parser.text);
                    var o = ensureSafeObject(obj(self, locals), parser.text);
                    if (!o) obj.assign(self, o = {});
                    return o[key] = value;
                }
            });
        },
        functionCall: function(fn, contextGetter) {
            var argsFn = [];
            if (this.peekToken().text !== ")") {
                do {
                    argsFn.push(this.expression());
                } while (this.expect(","));
            }
            this.consume(")");
            var parser = this;
            return function(scope, locals) {
                var args = [];
                var context = contextGetter ? contextGetter(scope, locals) : scope;
                for (var i = 0; i < argsFn.length; i++) {
                    args.push(ensureSafeObject(argsFn[i](scope, locals), parser.text));
                }
                var fnPtr = fn(scope, locals, context) || noop;
                ensureSafeObject(context, parser.text);
                ensureSafeFunction(fnPtr, parser.text);
                var v = fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
                return ensureSafeObject(v, parser.text);
            };
        },
        arrayDeclaration: function() {
            var elementFns = [];
            var allConstant = true;
            if (this.peekToken().text !== "]") {
                do {
                    if (this.peek("]")) {
                        break;
                    }
                    var elementFn = this.expression();
                    elementFns.push(elementFn);
                    if (!elementFn.constant) {
                        allConstant = false;
                    }
                } while (this.expect(","));
            }
            this.consume("]");
            return extend(function(self, locals) {
                var array = [];
                for (var i = 0; i < elementFns.length; i++) {
                    array.push(elementFns[i](self, locals));
                }
                return array;
            }, {
                literal: true,
                constant: allConstant
            });
        },
        object: function() {
            var keyValues = [];
            var allConstant = true;
            if (this.peekToken().text !== "}") {
                do {
                    if (this.peek("}")) {
                        break;
                    }
                    var token = this.expect(), key = token.string || token.text;
                    this.consume(":");
                    var value = this.expression();
                    keyValues.push({
                        key: key,
                        value: value
                    });
                    if (!value.constant) {
                        allConstant = false;
                    }
                } while (this.expect(","));
            }
            this.consume("}");
            return extend(function(self, locals) {
                var object = {};
                for (var i = 0; i < keyValues.length; i++) {
                    var keyValue = keyValues[i];
                    object[keyValue.key] = keyValue.value(self, locals);
                }
                return object;
            }, {
                literal: true,
                constant: allConstant
            });
        }
    };
    function setter(obj, path, setValue, fullExp, options) {
        ensureSafeObject(obj, fullExp);
        options = options || {};
        var element = path.split("."), key;
        for (var i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = ensureSafeObject(obj[key], fullExp);
            if (!propertyObj) {
                propertyObj = {};
                obj[key] = propertyObj;
            }
            obj = propertyObj;
            if (obj.then && options.unwrapPromises) {
                promiseWarning(fullExp);
                if (!("$$v" in obj)) {
                    (function(promise) {
                        promise.then(function(val) {
                            promise.$$v = val;
                        });
                    })(obj);
                }
                if (obj.$$v === undefined) {
                    obj.$$v = {};
                }
                obj = obj.$$v;
            }
        }
        key = ensureSafeMemberName(element.shift(), fullExp);
        ensureSafeObject(obj[key], fullExp);
        obj[key] = setValue;
        return setValue;
    }
    var getterFnCache = {};
    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
        ensureSafeMemberName(key0, fullExp);
        ensureSafeMemberName(key1, fullExp);
        ensureSafeMemberName(key2, fullExp);
        ensureSafeMemberName(key3, fullExp);
        ensureSafeMemberName(key4, fullExp);
        return !options.unwrapPromises ? function cspSafeGetter(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            if (pathVal == null) return pathVal;
            pathVal = pathVal[key0];
            if (!key1) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = pathVal[key1];
            if (!key2) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = pathVal[key2];
            if (!key3) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = pathVal[key3];
            if (!key4) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = pathVal[key4];
            return pathVal;
        } : function cspSafePromiseEnabledGetter(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope, promise;
            if (pathVal == null) return pathVal;
            pathVal = pathVal[key0];
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp);
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) {
                        promise.$$v = val;
                    });
                }
                pathVal = pathVal.$$v;
            }
            if (!key1) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = pathVal[key1];
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp);
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) {
                        promise.$$v = val;
                    });
                }
                pathVal = pathVal.$$v;
            }
            if (!key2) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = pathVal[key2];
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp);
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) {
                        promise.$$v = val;
                    });
                }
                pathVal = pathVal.$$v;
            }
            if (!key3) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = pathVal[key3];
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp);
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) {
                        promise.$$v = val;
                    });
                }
                pathVal = pathVal.$$v;
            }
            if (!key4) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = pathVal[key4];
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp);
                if (!("$$v" in pathVal)) {
                    promise = pathVal;
                    promise.$$v = undefined;
                    promise.then(function(val) {
                        promise.$$v = val;
                    });
                }
                pathVal = pathVal.$$v;
            }
            return pathVal;
        };
    }
    function getterFn(path, options, fullExp) {
        if (getterFnCache.hasOwnProperty(path)) {
            return getterFnCache[path];
        }
        var pathKeys = path.split("."), pathKeysLength = pathKeys.length, fn;
        if (options.csp) {
            if (pathKeysLength < 6) {
                fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, options);
            } else {
                fn = function(scope, locals) {
                    var i = 0, val;
                    do {
                        val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, options)(scope, locals);
                        locals = undefined;
                        scope = val;
                    } while (i < pathKeysLength);
                    return val;
                };
            }
        } else {
            var code = "var p;\n";
            forEach(pathKeys, function(key, index) {
                ensureSafeMemberName(key, fullExp);
                code += "if(s == null) return undefined;\n" + "s=" + (index ? "s" : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ";\n" + (options.unwrapPromises ? "if (s && s.then) {\n" + ' pw("' + fullExp.replace(/(["\r\n])/g, "\\$1") + '");\n' + ' if (!("$$v" in s)) {\n' + " p=s;\n" + " p.$$v = undefined;\n" + " p.then(function(v) {p.$$v=v;});\n" + "}\n" + " s=s.$$v\n" + "}\n" : "");
            });
            code += "return s;";
            var evaledFnGetter = new Function("s", "k", "pw", code);
            evaledFnGetter.toString = valueFn(code);
            fn = options.unwrapPromises ? function(scope, locals) {
                return evaledFnGetter(scope, locals, promiseWarning);
            } : evaledFnGetter;
        }
        if (path !== "hasOwnProperty") {
            getterFnCache[path] = fn;
        }
        return fn;
    }
    function $ParseProvider() {
        var cache = {};
        var $parseOptions = {
            csp: false,
            unwrapPromises: false,
            logPromiseWarnings: true
        };
        this.unwrapPromises = function(value) {
            if (isDefined(value)) {
                $parseOptions.unwrapPromises = !!value;
                return this;
            } else {
                return $parseOptions.unwrapPromises;
            }
        };
        this.logPromiseWarnings = function(value) {
            if (isDefined(value)) {
                $parseOptions.logPromiseWarnings = value;
                return this;
            } else {
                return $parseOptions.logPromiseWarnings;
            }
        };
        this.$get = [ "$filter", "$sniffer", "$log", function($filter, $sniffer, $log) {
            $parseOptions.csp = $sniffer.csp;
            promiseWarning = function promiseWarningFn(fullExp) {
                if (!$parseOptions.logPromiseWarnings || promiseWarningCache.hasOwnProperty(fullExp)) return;
                promiseWarningCache[fullExp] = true;
                $log.warn("[$parse] Promise found in the expression `" + fullExp + "`. " + "Automatic unwrapping of promises in Angular expressions is deprecated.");
            };
            return function(exp) {
                var parsedExpression;
                switch (typeof exp) {
                  case "string":
                    if (cache.hasOwnProperty(exp)) {
                        return cache[exp];
                    }
                    var lexer = new Lexer($parseOptions);
                    var parser = new Parser(lexer, $filter, $parseOptions);
                    parsedExpression = parser.parse(exp);
                    if (exp !== "hasOwnProperty") {
                        cache[exp] = parsedExpression;
                    }
                    return parsedExpression;

                  case "function":
                    return exp;

                  default:
                    return noop;
                }
            };
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        var defer = function() {
            var pending = [], value, deferred;
            deferred = {
                resolve: function(val) {
                    if (pending) {
                        var callbacks = pending;
                        pending = undefined;
                        value = ref(val);
                        if (callbacks.length) {
                            nextTick(function() {
                                var callback;
                                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                    callback = callbacks[i];
                                    value.then(callback[0], callback[1], callback[2]);
                                }
                            });
                        }
                    }
                },
                reject: function(reason) {
                    deferred.resolve(createInternalRejectedPromise(reason));
                },
                notify: function(progress) {
                    if (pending) {
                        var callbacks = pending;
                        if (pending.length) {
                            nextTick(function() {
                                var callback;
                                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                    callback = callbacks[i];
                                    callback[2](progress);
                                }
                            });
                        }
                    }
                },
                promise: {
                    then: function(callback, errback, progressback) {
                        var result = defer();
                        var wrappedCallback = function(value) {
                            try {
                                result.resolve((isFunction(callback) ? callback : defaultCallback)(value));
                            } catch (e) {
                                result.reject(e);
                                exceptionHandler(e);
                            }
                        };
                        var wrappedErrback = function(reason) {
                            try {
                                result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
                            } catch (e) {
                                result.reject(e);
                                exceptionHandler(e);
                            }
                        };
                        var wrappedProgressback = function(progress) {
                            try {
                                result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress));
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        };
                        if (pending) {
                            pending.push([ wrappedCallback, wrappedErrback, wrappedProgressback ]);
                        } else {
                            value.then(wrappedCallback, wrappedErrback, wrappedProgressback);
                        }
                        return result.promise;
                    },
                    "catch": function(callback) {
                        return this.then(null, callback);
                    },
                    "finally": function(callback) {
                        function makePromise(value, resolved) {
                            var result = defer();
                            if (resolved) {
                                result.resolve(value);
                            } else {
                                result.reject(value);
                            }
                            return result.promise;
                        }
                        function handleCallback(value, isResolved) {
                            var callbackOutput = null;
                            try {
                                callbackOutput = (callback || defaultCallback)();
                            } catch (e) {
                                return makePromise(e, false);
                            }
                            if (isPromiseLike(callbackOutput)) {
                                return callbackOutput.then(function() {
                                    return makePromise(value, isResolved);
                                }, function(error) {
                                    return makePromise(error, false);
                                });
                            } else {
                                return makePromise(value, isResolved);
                            }
                        }
                        return this.then(function(value) {
                            return handleCallback(value, true);
                        }, function(error) {
                            return handleCallback(error, false);
                        });
                    }
                }
            };
            return deferred;
        };
        var ref = function(value) {
            if (isPromiseLike(value)) return value;
            return {
                then: function(callback) {
                    var result = defer();
                    nextTick(function() {
                        result.resolve(callback(value));
                    });
                    return result.promise;
                }
            };
        };
        var reject = function(reason) {
            var result = defer();
            result.reject(reason);
            return result.promise;
        };
        var createInternalRejectedPromise = function(reason) {
            return {
                then: function(callback, errback) {
                    var result = defer();
                    nextTick(function() {
                        try {
                            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
                        } catch (e) {
                            result.reject(e);
                            exceptionHandler(e);
                        }
                    });
                    return result.promise;
                }
            };
        };
        var when = function(value, callback, errback, progressback) {
            var result = defer(), done;
            var wrappedCallback = function(value) {
                try {
                    return (isFunction(callback) ? callback : defaultCallback)(value);
                } catch (e) {
                    exceptionHandler(e);
                    return reject(e);
                }
            };
            var wrappedErrback = function(reason) {
                try {
                    return (isFunction(errback) ? errback : defaultErrback)(reason);
                } catch (e) {
                    exceptionHandler(e);
                    return reject(e);
                }
            };
            var wrappedProgressback = function(progress) {
                try {
                    return (isFunction(progressback) ? progressback : defaultCallback)(progress);
                } catch (e) {
                    exceptionHandler(e);
                }
            };
            nextTick(function() {
                ref(value).then(function(value) {
                    if (done) return;
                    done = true;
                    result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback));
                }, function(reason) {
                    if (done) return;
                    done = true;
                    result.resolve(wrappedErrback(reason));
                }, function(progress) {
                    if (done) return;
                    result.notify(wrappedProgressback(progress));
                });
            });
            return result.promise;
        };
        function defaultCallback(value) {
            return value;
        }
        function defaultErrback(reason) {
            return reject(reason);
        }
        function all(promises) {
            var deferred = defer(), counter = 0, results = isArray(promises) ? [] : {};
            forEach(promises, function(promise, key) {
                counter++;
                ref(promise).then(function(value) {
                    if (results.hasOwnProperty(key)) return;
                    results[key] = value;
                    if (!--counter) deferred.resolve(results);
                }, function(reason) {
                    if (results.hasOwnProperty(key)) return;
                    deferred.reject(reason);
                });
            });
            if (counter === 0) {
                deferred.resolve(results);
            }
            return deferred.promise;
        }
        return {
            defer: defer,
            reject: reject,
            when: when,
            all: all
        };
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame;
            var raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, false);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            raf.supported = rafSupported;
            return raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr("$rootScope");
        var lastDirtyWatch = null;
        this.digestTtl = function(value) {
            if (arguments.length) {
                TTL = value;
            }
            return TTL;
        };
        this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function Scope() {
                this.$id = nextUid();
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this["this"] = this.$root = this;
                this.$$destroyed = false;
                this.$$asyncQueue = [];
                this.$$postDigestQueue = [];
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$isolateBindings = {};
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate) {
                    var ChildScope, child;
                    if (isolate) {
                        child = new Scope();
                        child.$root = this.$root;
                        child.$$asyncQueue = this.$$asyncQueue;
                        child.$$postDigestQueue = this.$$postDigestQueue;
                    } else {
                        if (!this.$$childScopeClass) {
                            this.$$childScopeClass = function() {
                                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                                this.$$listeners = {};
                                this.$$listenerCount = {};
                                this.$id = nextUid();
                                this.$$childScopeClass = null;
                            };
                            this.$$childScopeClass.prototype = this;
                        }
                        child = new this.$$childScopeClass();
                    }
                    child["this"] = child;
                    child.$parent = this;
                    child.$$prevSibling = this.$$childTail;
                    if (this.$$childHead) {
                        this.$$childTail.$$nextSibling = child;
                        this.$$childTail = child;
                    } else {
                        this.$$childHead = this.$$childTail = child;
                    }
                    return child;
                },
                $watch: function(watchExp, listener, objectEquality) {
                    var scope = this, get = compileToFn(watchExp, "watch"), array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: watchExp,
                        eq: !!objectEquality
                    };
                    lastDirtyWatch = null;
                    if (!isFunction(listener)) {
                        var listenFn = compileToFn(listener || noop, "listener");
                        watcher.fn = function(newVal, oldVal, scope) {
                            listenFn(scope);
                        };
                    }
                    if (typeof watchExp == "string" && get.constant) {
                        var originalFn = watcher.fn;
                        watcher.fn = function(newVal, oldVal, scope) {
                            originalFn.call(this, newVal, oldVal, scope);
                            arrayRemove(array, watcher);
                        };
                    }
                    if (!array) {
                        array = scope.$$watchers = [];
                    }
                    array.unshift(watcher);
                    return function deregisterWatch() {
                        arrayRemove(array, watcher);
                        lastDirtyWatch = null;
                    };
                },
                $watchCollection: function(obj, listener) {
                    var self = this;
                    var newValue;
                    var oldValue;
                    var veryOldValue;
                    var trackVeryOldValue = listener.length > 1;
                    var changeDetected = 0;
                    var objGetter = $parse(obj);
                    var internalArray = [];
                    var internalObject = {};
                    var initRun = true;
                    var oldLength = 0;
                    function $watchCollectionWatch() {
                        newValue = objGetter(self);
                        var newLength, key, bothNaN;
                        if (!isObject(newValue)) {
                            if (oldValue !== newValue) {
                                oldValue = newValue;
                                changeDetected++;
                            }
                        } else if (isArrayLike(newValue)) {
                            if (oldValue !== internalArray) {
                                oldValue = internalArray;
                                oldLength = oldValue.length = 0;
                                changeDetected++;
                            }
                            newLength = newValue.length;
                            if (oldLength !== newLength) {
                                changeDetected++;
                                oldValue.length = oldLength = newLength;
                            }
                            for (var i = 0; i < newLength; i++) {
                                bothNaN = oldValue[i] !== oldValue[i] && newValue[i] !== newValue[i];
                                if (!bothNaN && oldValue[i] !== newValue[i]) {
                                    changeDetected++;
                                    oldValue[i] = newValue[i];
                                }
                            }
                        } else {
                            if (oldValue !== internalObject) {
                                oldValue = internalObject = {};
                                oldLength = 0;
                                changeDetected++;
                            }
                            newLength = 0;
                            for (key in newValue) {
                                if (newValue.hasOwnProperty(key)) {
                                    newLength++;
                                    if (oldValue.hasOwnProperty(key)) {
                                        bothNaN = oldValue[key] !== oldValue[key] && newValue[key] !== newValue[key];
                                        if (!bothNaN && oldValue[key] !== newValue[key]) {
                                            changeDetected++;
                                            oldValue[key] = newValue[key];
                                        }
                                    } else {
                                        oldLength++;
                                        oldValue[key] = newValue[key];
                                        changeDetected++;
                                    }
                                }
                            }
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) {
                                    if (oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key)) {
                                        oldLength--;
                                        delete oldValue[key];
                                    }
                                }
                            }
                        }
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun) {
                            initRun = false;
                            listener(newValue, newValue, self);
                        } else {
                            listener(newValue, veryOldValue, self);
                        }
                        if (trackVeryOldValue) {
                            if (!isObject(newValue)) {
                                veryOldValue = newValue;
                            } else if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length);
                                for (var i = 0; i < newValue.length; i++) {
                                    veryOldValue[i] = newValue[i];
                                }
                            } else {
                                veryOldValue = {};
                                for (var key in newValue) {
                                    if (hasOwnProperty.call(newValue, key)) {
                                        veryOldValue[key] = newValue[key];
                                    }
                                }
                            }
                        }
                    }
                    return this.$watch($watchCollectionWatch, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, asyncQueue = this.$$asyncQueue, postDigestQueue = this.$$postDigestQueue, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask;
                    beginPhase("$digest");
                    $browser.$$checkUrlChange();
                    lastDirtyWatch = null;
                    do {
                        dirty = false;
                        current = target;
                        while (asyncQueue.length) {
                            try {
                                asyncTask = asyncQueue.shift();
                                asyncTask.scope.$eval(asyncTask.expression);
                            } catch (e) {
                                clearPhase();
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) {
                                length = watchers.length;
                                while (length--) {
                                    try {
                                        watch = watchers[length];
                                        if (watch) {
                                            if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === "number" && typeof last === "number" && isNaN(value) && isNaN(last))) {
                                                dirty = true;
                                                lastDirtyWatch = watch;
                                                watch.last = watch.eq ? copy(value, null) : value;
                                                watch.fn(value, last === initWatchVal ? value : last, current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                    logMsg = isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp;
                                                    logMsg += "; newVal: " + toJson(value) + "; oldVal: " + toJson(last);
                                                    watchLog[logIdx].push(logMsg);
                                                }
                                            } else if (watch === lastDirtyWatch) {
                                                dirty = false;
                                                break traverseScopesLoop;
                                            }
                                        }
                                    } catch (e) {
                                        clearPhase();
                                        $exceptionHandler(e);
                                    }
                                }
                            }
                            if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                                while (current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) {
                            clearPhase();
                            throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, toJson(watchLog));
                        }
                    } while (dirty || asyncQueue.length);
                    clearPhase();
                    while (postDigestQueue.length) {
                        try {
                            postDigestQueue.shift()();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                },
                $destroy: function() {
                    if (this.$$destroyed) return;
                    var parent = this.$parent;
                    this.$broadcast("$destroy");
                    this.$$destroyed = true;
                    if (this === $rootScope) return;
                    forEach(this.$$listenerCount, bind(null, decrementListenerCount, this));
                    if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
                    if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
                    if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                    if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                    this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = null;
                    this.$$listeners = {};
                    this.$$watchers = this.$$asyncQueue = this.$$postDigestQueue = [];
                    this.$destroy = this.$digest = this.$apply = noop;
                    this.$on = this.$watch = function() {
                        return noop;
                    };
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr) {
                    if (!$rootScope.$$phase && !$rootScope.$$asyncQueue.length) {
                        $browser.defer(function() {
                            if ($rootScope.$$asyncQueue.length) {
                                $rootScope.$digest();
                            }
                        });
                    }
                    this.$$asyncQueue.push({
                        scope: this,
                        expression: expr
                    });
                },
                $$postDigest: function(fn) {
                    this.$$postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        return this.$eval(expr);
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            $exceptionHandler(e);
                            throw e;
                        }
                    }
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    if (!namedListeners) {
                        this.$$listeners[name] = namedListeners = [];
                    }
                    namedListeners.push(listener);
                    var current = this;
                    do {
                        if (!current.$$listenerCount[name]) {
                            current.$$listenerCount[name] = 0;
                        }
                        current.$$listenerCount[name]++;
                    } while (current = current.$parent);
                    var self = this;
                    return function() {
                        namedListeners[indexOf(namedListeners, listener)] = null;
                        decrementListenerCount(self, 1, name);
                    };
                },
                $emit: function(name, args) {
                    var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = true;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    }, listenerArgs = concat([ event ], arguments, 1), i, length;
                    do {
                        namedListeners = scope.$$listeners[name] || empty;
                        event.currentScope = scope;
                        for (i = 0, length = namedListeners.length; i < length; i++) {
                            if (!namedListeners[i]) {
                                namedListeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                namedListeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (stopPropagation) return event;
                        scope = scope.$parent;
                    } while (scope);
                    return event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    }, listenerArgs = concat([ event ], arguments, 1), listeners, i, length;
                    while (current = next) {
                        event.currentScope = current;
                        listeners = current.$$listeners[name] || [];
                        for (i = 0, length = listeners.length; i < length; i++) {
                            if (!listeners[i]) {
                                listeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                listeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                            while (current !== target && !(next = current.$$nextSibling)) {
                                current = current.$parent;
                            }
                        }
                    }
                    return event;
                }
            };
            var $rootScope = new Scope();
            return $rootScope;
            function beginPhase(phase) {
                if ($rootScope.$$phase) {
                    throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                }
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function compileToFn(exp, name) {
                var fn = $parse(exp);
                assertArgFn(fn, name);
                return fn;
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count;
                    if (current.$$listenerCount[name] === 0) {
                        delete current.$$listenerCount[name];
                    }
                } while (current = current.$parent);
            }
            function initWatchVal() {}
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                aHrefSanitizationWhitelist = regexp;
                return this;
            }
            return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                imgSrcSanitizationWhitelist = regexp;
                return this;
            }
            return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
            return function sanitizeUri(uri, isImage) {
                var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                var normalizedVal;
                if (!msie || msie >= 8) {
                    normalizedVal = urlResolve(uri).href;
                    if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                        return "unsafe:" + normalizedVal;
                    }
                }
                return uri;
            };
        };
    }
    var $sceMinErr = minErr("$sce");
    var SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    };
    function escapeForRegexp(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }
    function adjustMatcher(matcher) {
        if (matcher === "self") {
            return matcher;
        } else if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) {
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            }
            matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*");
            return new RegExp("^" + matcher + "$");
        } else if (isRegExp(matcher)) {
            return new RegExp("^" + matcher.source + "$");
        } else {
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
        }
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
            forEach(matchers, function(matcher) {
                adjustedMatchers.push(adjustMatcher(matcher));
            });
        }
        return adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            if (arguments.length) {
                resourceUrlWhitelist = adjustMatchers(value);
            }
            return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
            if (arguments.length) {
                resourceUrlBlacklist = adjustMatchers(value);
            }
            return resourceUrlBlacklist;
        };
        this.$get = [ "$injector", function($injector) {
            var htmlSanitizer = function htmlSanitizer(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            if ($injector.has("$sanitize")) {
                htmlSanitizer = $injector.get("$sanitize");
            }
            function matchUrl(matcher, parsedUrl) {
                if (matcher === "self") {
                    return urlIsSameOrigin(parsedUrl);
                } else {
                    return !!matcher.exec(parsedUrl.href);
                }
            }
            function isResourceUrlAllowedByPolicy(url) {
                var parsedUrl = urlResolve(url.toString());
                var i, n, allowed = false;
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = true;
                        break;
                    }
                }
                if (allowed) {
                    for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = false;
                            break;
                        }
                    }
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                if (Base) {
                    holderType.prototype = new Base();
                }
                holderType.prototype.valueOf = function sceValueOf() {
                    return this.$$unwrapTrustedValue();
                };
                holderType.prototype.toString = function sceToString() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return holderType;
            }
            var trustedValueHolderBase = generateHolderType(), byType = {};
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) {
                    throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                }
                if (trustedValue === null || trustedValue === undefined || trustedValue === "") {
                    return trustedValue;
                }
                if (typeof trustedValue !== "string") {
                    throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                }
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                    return maybeTrusted.$$unwrapTrustedValue();
                } else {
                    return maybeTrusted;
                }
            }
            function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === "") {
                    return maybeTrusted;
                }
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) {
                    return maybeTrusted.$$unwrapTrustedValue();
                }
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                        return maybeTrusted;
                    } else {
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                    }
                } else if (type === SCE_CONTEXTS.HTML) {
                    return htmlSanitizer(maybeTrusted);
                }
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            return {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
            if (arguments.length) {
                enabled = !!value;
            }
            return enabled;
        };
        this.$get = [ "$parse", "$sniffer", "$sceDelegate", function($parse, $sniffer, $sceDelegate) {
            if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) {
                throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
                sce.trustAs = sce.getTrusted = function(type, value) {
                    return value;
                };
                sce.valueOf = identity;
            }
            sce.parseAs = function sceParseAs(type, expr) {
                var parsed = $parse(expr);
                if (parsed.literal && parsed.constant) {
                    return parsed;
                } else {
                    return function sceParseAsTrusted(self, locals) {
                        return sce.getTrusted(type, parsed(self, locals));
                    };
                }
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                };
                sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                };
                sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            });
            return sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, documentMode = document.documentMode, vendorPrefix, vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
            if (bodyStyle) {
                for (var prop in bodyStyle) {
                    if (match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0];
                        vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                        break;
                    }
                }
                if (!vendorPrefix) {
                    vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit";
                }
                transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle);
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle);
                if (android && (!transitions || !animations)) {
                    transitions = isString(document.body.style.webkitTransition);
                    animations = isString(document.body.style.webkitAnimation);
                }
            }
            return {
                history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
                hashchange: "onhashchange" in $window && (!documentMode || documentMode > 7),
                hasEvent: function(event) {
                    if (event == "input" && msie == 9) return false;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android,
                msie: msie,
                msieDocumentMode: documentMode
            };
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$exceptionHandler", function($rootScope, $browser, $q, $exceptionHandler) {
            var deferreds = {};
            function timeout(fn, delay, invokeApply) {
                var deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply, timeoutId;
                timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn());
                    } catch (e) {
                        deferred.reject(e);
                        $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                promise.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise;
            }
            timeout.cancel = function(promise) {
                if (promise && promise.$$timeoutId in deferreds) {
                    deferreds[promise.$$timeoutId].reject("canceled");
                    delete deferreds[promise.$$timeoutId];
                    return $browser.defer.cancel(promise.$$timeoutId);
                }
                return false;
            };
            return timeout;
        } ];
    }
    var urlParsingNode = document.createElement("a");
    var originUrl = urlResolve(window.location.href, true);
    function urlResolve(url, base) {
        var href = url;
        if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    $FilterProvider.$inject = [ "$provide" ];
    function $FilterProvider($provide) {
        var suffix = "Filter";
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                });
                return filters;
            } else {
                return $provide.factory(name + suffix, factory);
            }
        }
        this.register = register;
        this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ];
        register("currency", currencyFilter);
        register("date", dateFilter);
        register("filter", filterFilter);
        register("json", jsonFilter);
        register("limitTo", limitToFilter);
        register("lowercase", lowercaseFilter);
        register("number", numberFilter);
        register("orderBy", orderByFilter);
        register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArray(array)) return array;
            var comparatorType = typeof comparator, predicates = [];
            predicates.check = function(value) {
                for (var j = 0; j < predicates.length; j++) {
                    if (!predicates[j](value)) {
                        return false;
                    }
                }
                return true;
            };
            if (comparatorType !== "function") {
                if (comparatorType === "boolean" && comparator) {
                    comparator = function(obj, text) {
                        return angular.equals(obj, text);
                    };
                } else {
                    comparator = function(obj, text) {
                        if (obj && text && typeof obj === "object" && typeof text === "object") {
                            for (var objKey in obj) {
                                if (objKey.charAt(0) !== "$" && hasOwnProperty.call(obj, objKey) && comparator(obj[objKey], text[objKey])) {
                                    return true;
                                }
                            }
                            return false;
                        }
                        text = ("" + text).toLowerCase();
                        return ("" + obj).toLowerCase().indexOf(text) > -1;
                    };
                }
            }
            var search = function(obj, text) {
                if (typeof text == "string" && text.charAt(0) === "!") {
                    return !search(obj, text.substr(1));
                }
                switch (typeof obj) {
                  case "boolean":
                  case "number":
                  case "string":
                    return comparator(obj, text);

                  case "object":
                    switch (typeof text) {
                      case "object":
                        return comparator(obj, text);

                      default:
                        for (var objKey in obj) {
                            if (objKey.charAt(0) !== "$" && search(obj[objKey], text)) {
                                return true;
                            }
                        }
                        break;
                    }
                    return false;

                  case "array":
                    for (var i = 0; i < obj.length; i++) {
                        if (search(obj[i], text)) {
                            return true;
                        }
                    }
                    return false;

                  default:
                    return false;
                }
            };
            switch (typeof expression) {
              case "boolean":
              case "number":
              case "string":
                expression = {
                    $: expression
                };

              case "object":
                for (var key in expression) {
                    (function(path) {
                        if (typeof expression[path] === "undefined") return;
                        predicates.push(function(value) {
                            return search(path == "$" ? value : value && value[path], expression[path]);
                        });
                    })(key);
                }
                break;

              case "function":
                predicates.push(expression);
                break;

              default:
                return array;
            }
            var filtered = [];
            for (var j = 0; j < array.length; j++) {
                var value = array[j];
                if (predicates.check(value)) {
                    filtered.push(value);
                }
            }
            return filtered;
        };
    }
    currencyFilter.$inject = [ "$locale" ];
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol) {
            if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;
            return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
        };
    }
    numberFilter.$inject = [ "$locale" ];
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    var DECIMAL_SEP = ".";
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (number == null || !isFinite(number) || isObject(number)) return "";
        var isNegative = number < 0;
        number = Math.abs(number);
        var numStr = number + "", formatedText = "", parts = [];
        var hasExponent = false;
        if (numStr.indexOf("e") !== -1) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            if (match && match[2] == "-" && match[3] > fractionSize + 1) {
                numStr = "0";
                number = 0;
            } else {
                formatedText = numStr;
                hasExponent = true;
            }
        }
        if (!hasExponent) {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            if (isUndefined(fractionSize)) {
                fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
            }
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            if (number === 0) {
                isNegative = false;
            }
            var fraction = ("" + number).split(DECIMAL_SEP);
            var whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) {
                pos = whole.length - lgroup;
                for (i = 0; i < pos; i++) {
                    if ((pos - i) % group === 0 && i !== 0) {
                        formatedText += groupSep;
                    }
                    formatedText += whole.charAt(i);
                }
            }
            for (i = pos; i < whole.length; i++) {
                if ((whole.length - i) % lgroup === 0 && i !== 0) {
                    formatedText += groupSep;
                }
                formatedText += whole.charAt(i);
            }
            while (fraction.length < fractionSize) {
                fraction += "0";
            }
            if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
            if (fractionSize > 0 && number > -1 && number < 1) {
                formatedText = number.toFixed(fractionSize);
            }
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre);
        parts.push(formatedText);
        parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        if (num < 0) {
            neg = "-";
            num = -num;
        }
        num = "" + num;
        while (num.length < digits) num = "0" + num;
        if (trim) num = num.substr(num.length - digits);
        return neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
            var value = date["get" + name]();
            if (offset > 0 || value > -offset) value += offset;
            if (value === 0 && offset == -12) value = 12;
            return padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name]();
            var get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset();
        var paddedZone = zone >= 0 ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, true),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", true),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", true),
        a: ampmGetter,
        Z: timeZoneGetter
    };
    var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                if (match[9]) {
                    tzHour = int(match[9] + match[10]);
                    tzMin = int(match[9] + match[11]);
                }
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour;
                var m = int(match[5] || 0) - tzMin;
                var s = int(match[6] || 0);
                var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
                timeSetter.call(date, h, m, s, ms);
                return date;
            }
            return string;
        }
        return function(date, format) {
            var text = "", parts = [], fn, match;
            format = format || "mediumDate";
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
                date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date);
            }
            if (isNumber(date)) {
                date = new Date(date);
            }
            if (!isDate(date)) {
                return date;
            }
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    parts.push(format);
                    format = null;
                }
            }
            forEach(parts, function(value) {
                fn = DATE_FORMATS[value];
                text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return text;
        };
    }
    function jsonFilter() {
        return function(object) {
            return toJson(object, true);
        };
    }
    var lowercaseFilter = valueFn(lowercase);
    var uppercaseFilter = valueFn(uppercase);
    function limitToFilter() {
        return function(input, limit) {
            if (!isArray(input) && !isString(input)) return input;
            if (Math.abs(Number(limit)) === Infinity) {
                limit = Number(limit);
            } else {
                limit = int(limit);
            }
            if (isString(input)) {
                if (limit) {
                    return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
                } else {
                    return "";
                }
            }
            var out = [], i, n;
            if (limit > input.length) limit = input.length; else if (limit < -input.length) limit = -input.length;
            if (limit > 0) {
                i = 0;
                n = limit;
            } else {
                i = input.length + limit;
                n = input.length;
            }
            for (;i < n; i++) {
                out.push(input[i]);
            }
            return out;
        };
    }
    orderByFilter.$inject = [ "$parse" ];
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
            if (!isArrayLike(array)) return array;
            if (!sortPredicate) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate : [ sortPredicate ];
            sortPredicate = map(sortPredicate, function(predicate) {
                var descending = false, get = predicate || identity;
                if (isString(predicate)) {
                    if (predicate.charAt(0) == "+" || predicate.charAt(0) == "-") {
                        descending = predicate.charAt(0) == "-";
                        predicate = predicate.substring(1);
                    }
                    get = $parse(predicate);
                    if (get.constant) {
                        var key = get();
                        return reverseComparator(function(a, b) {
                            return compare(a[key], b[key]);
                        }, descending);
                    }
                }
                return reverseComparator(function(a, b) {
                    return compare(get(a), get(b));
                }, descending);
            });
            var arrayCopy = [];
            for (var i = 0; i < array.length; i++) {
                arrayCopy.push(array[i]);
            }
            return arrayCopy.sort(reverseComparator(comparator, reverseOrder));
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (comp !== 0) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return toBoolean(descending) ? function(a, b) {
                    return comp(b, a);
                } : comp;
            }
            function compare(v1, v2) {
                var t1 = typeof v1;
                var t2 = typeof v2;
                if (t1 == t2) {
                    if (isDate(v1) && isDate(v2)) {
                        v1 = v1.valueOf();
                        v2 = v2.valueOf();
                    }
                    if (t1 == "string") {
                        v1 = v1.toLowerCase();
                        v2 = v2.toLowerCase();
                    }
                    if (v1 === v2) return 0;
                    return v1 < v2 ? -1 : 1;
                } else {
                    return t1 < t2 ? -1 : 1;
                }
            }
        };
    }
    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {
                link: directive
            };
        }
        directive.restrict = directive.restrict || "AC";
        return valueFn(directive);
    }
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (msie <= 8) {
                if (!attr.href && !attr.name) {
                    attr.$set("href", "");
                }
                element.append(document.createComment("IE fix"));
            }
            if (!attr.href && !attr.xlinkHref && !attr.name) {
                return function(scope, element) {
                    var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        if (!element.attr(href)) {
                            event.preventDefault();
                        }
                    });
                };
            }
        }
    });
    var ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple") return;
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                        attr.$set(attrName, !!value);
                    });
                }
            };
        };
    });
    forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                        name = "xlinkHref";
                        attr.$attr[name] = "xlink:href";
                        propName = null;
                    }
                    attr.$observe(normalized, function(value) {
                        if (!value) {
                            if (attrName === "href") {
                                attr.$set(name, null);
                            }
                            return;
                        }
                        attr.$set(name, value);
                        if (msie && propName) element.prop(propName, attr[name]);
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop
    };
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate" ];
    function FormController(element, attrs, $scope, $animate) {
        var form = this, parentForm = element.parent().controller("form") || nullFormCtrl, invalidCount = 0, errors = form.$error = {}, controls = [];
        form.$name = attrs.name || attrs.ngForm;
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        parentForm.$addControl(form);
        element.addClass(PRISTINE_CLASS);
        toggleValidCss(true);
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
            $animate.setClass(element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey);
        }
        form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input");
            controls.push(control);
            if (control.$name) {
                form[control.$name] = control;
            }
        };
        form.$removeControl = function(control) {
            if (control.$name && form[control.$name] === control) {
                delete form[control.$name];
            }
            forEach(errors, function(queue, validationToken) {
                form.$setValidity(validationToken, true, control);
            });
            arrayRemove(controls, control);
        };
        form.$setValidity = function(validationToken, isValid, control) {
            var queue = errors[validationToken];
            if (isValid) {
                if (queue) {
                    arrayRemove(queue, control);
                    if (!queue.length) {
                        invalidCount--;
                        if (!invalidCount) {
                            toggleValidCss(isValid);
                            form.$valid = true;
                            form.$invalid = false;
                        }
                        errors[validationToken] = false;
                        toggleValidCss(true, validationToken);
                        parentForm.$setValidity(validationToken, true, form);
                    }
                }
            } else {
                if (!invalidCount) {
                    toggleValidCss(isValid);
                }
                if (queue) {
                    if (includes(queue, control)) return;
                } else {
                    errors[validationToken] = queue = [];
                    invalidCount++;
                    toggleValidCss(false, validationToken);
                    parentForm.$setValidity(validationToken, false, form);
                }
                queue.push(control);
                form.$valid = false;
                form.$invalid = true;
            }
        };
        form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS);
            $animate.addClass(element, DIRTY_CLASS);
            form.$dirty = true;
            form.$pristine = false;
            parentForm.$setDirty();
        };
        form.$setPristine = function() {
            $animate.removeClass(element, DIRTY_CLASS);
            $animate.addClass(element, PRISTINE_CLASS);
            form.$dirty = false;
            form.$pristine = true;
            forEach(controls, function(control) {
                control.$setPristine();
            });
        };
    }
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", function($timeout) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function() {
                    return {
                        pre: function(scope, formElement, attr, controller) {
                            if (!attr.action) {
                                var preventDefaultListener = function(event) {
                                    event.preventDefault ? event.preventDefault() : event.returnValue = false;
                                };
                                addEventListenerFn(formElement[0], "submit", preventDefaultListener);
                                formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", preventDefaultListener);
                                    }, 0, false);
                                });
                            }
                            var parentFormCtrl = formElement.parent().controller("form"), alias = attr.name || attr.ngForm;
                            if (alias) {
                                setter(scope, alias, controller, alias);
                            }
                            if (parentFormCtrl) {
                                formElement.on("$destroy", function() {
                                    parentFormCtrl.$removeControl(controller);
                                    if (alias) {
                                        setter(scope, alias, undefined, alias);
                                    }
                                    extend(controller, nullFormCtrl);
                                });
                            }
                        }
                    };
                }
            };
            return formDirective;
        } ];
    };
    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);
    var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
    var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
    var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
    var inputType = {
        text: textInputType,
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    };
    function validate(ctrl, validatorName, validity, value) {
        ctrl.$setValidity(validatorName, validity);
        return validity ? value : undefined;
    }
    function testFlags(validity, flags) {
        var i, flag;
        if (flags) {
            for (i = 0; i < flags.length; ++i) {
                flag = flags[i];
                if (validity[flag]) {
                    return true;
                }
            }
        }
        return false;
    }
    function addNativeHtml5Validators(ctrl, validatorName, badFlags, ignoreFlags, validity) {
        if (isObject(validity)) {
            ctrl.$$hasNativeValidators = true;
            var validator = function(value) {
                if (!ctrl.$error[validatorName] && !testFlags(validity, ignoreFlags) && testFlags(validity, badFlags)) {
                    ctrl.$setValidity(validatorName, false);
                    return;
                }
                return value;
            };
            ctrl.$parsers.push(validator);
        }
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var validity = element.prop(VALIDITY_STATE_PROPERTY);
        var placeholder = element[0].placeholder, noevent = {};
        var type = lowercase(element[0].type);
        ctrl.$$validityState = validity;
        if (!$sniffer.android) {
            var composing = false;
            element.on("compositionstart", function(data) {
                composing = true;
            });
            element.on("compositionend", function() {
                composing = false;
                listener();
            });
        }
        var listener = function(ev) {
            if (composing) return;
            var value = element.val();
            if (msie && (ev || noevent).type === "input" && element[0].placeholder !== placeholder) {
                placeholder = element[0].placeholder;
                return;
            }
            if (type !== "password" && toBoolean(attr.ngTrim || "T")) {
                value = trim(value);
            }
            var revalidate = validity && ctrl.$$hasNativeValidators;
            if (ctrl.$viewValue !== value || value === "" && revalidate) {
                if (scope.$root.$$phase) {
                    ctrl.$setViewValue(value);
                } else {
                    scope.$apply(function() {
                        ctrl.$setViewValue(value);
                    });
                }
            }
        };
        if ($sniffer.hasEvent("input")) {
            element.on("input", listener);
        } else {
            var timeout;
            var deferListener = function() {
                if (!timeout) {
                    timeout = $browser.defer(function() {
                        listener();
                        timeout = null;
                    });
                }
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) return;
                deferListener();
            });
            if ($sniffer.hasEvent("paste")) {
                element.on("paste cut", deferListener);
            }
        }
        element.on("change", listener);
        ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue);
        };
        var pattern = attr.ngPattern, patternValidator, match;
        if (pattern) {
            var validateRegex = function(regexp, value) {
                return validate(ctrl, "pattern", ctrl.$isEmpty(value) || regexp.test(value), value);
            };
            match = pattern.match(/^\/(.*)\/([gim]*)$/);
            if (match) {
                pattern = new RegExp(match[1], match[2]);
                patternValidator = function(value) {
                    return validateRegex(pattern, value);
                };
            } else {
                patternValidator = function(value) {
                    var patternObj = scope.$eval(pattern);
                    if (!patternObj || !patternObj.test) {
                        throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", pattern, patternObj, startingTag(element));
                    }
                    return validateRegex(patternObj, value);
                };
            }
            ctrl.$formatters.push(patternValidator);
            ctrl.$parsers.push(patternValidator);
        }
        if (attr.ngMinlength) {
            var minlength = int(attr.ngMinlength);
            var minLengthValidator = function(value) {
                return validate(ctrl, "minlength", ctrl.$isEmpty(value) || value.length >= minlength, value);
            };
            ctrl.$parsers.push(minLengthValidator);
            ctrl.$formatters.push(minLengthValidator);
        }
        if (attr.ngMaxlength) {
            var maxlength = int(attr.ngMaxlength);
            var maxLengthValidator = function(value) {
                return validate(ctrl, "maxlength", ctrl.$isEmpty(value) || value.length <= maxlength, value);
            };
            ctrl.$parsers.push(maxLengthValidator);
            ctrl.$formatters.push(maxLengthValidator);
        }
    }
    var numberBadFlags = [ "badInput" ];
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$parsers.push(function(value) {
            var empty = ctrl.$isEmpty(value);
            if (empty || NUMBER_REGEXP.test(value)) {
                ctrl.$setValidity("number", true);
                return value === "" ? null : empty ? value : parseFloat(value);
            } else {
                ctrl.$setValidity("number", false);
                return undefined;
            }
        });
        addNativeHtml5Validators(ctrl, "number", numberBadFlags, null, ctrl.$$validityState);
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? "" : "" + value;
        });
        if (attr.min) {
            var minValidator = function(value) {
                var min = parseFloat(attr.min);
                return validate(ctrl, "min", ctrl.$isEmpty(value) || value >= min, value);
            };
            ctrl.$parsers.push(minValidator);
            ctrl.$formatters.push(minValidator);
        }
        if (attr.max) {
            var maxValidator = function(value) {
                var max = parseFloat(attr.max);
                return validate(ctrl, "max", ctrl.$isEmpty(value) || value <= max, value);
            };
            ctrl.$parsers.push(maxValidator);
            ctrl.$formatters.push(maxValidator);
        }
        ctrl.$formatters.push(function(value) {
            return validate(ctrl, "number", ctrl.$isEmpty(value) || isNumber(value), value);
        });
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var urlValidator = function(value) {
            return validate(ctrl, "url", ctrl.$isEmpty(value) || URL_REGEXP.test(value), value);
        };
        ctrl.$formatters.push(urlValidator);
        ctrl.$parsers.push(urlValidator);
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var emailValidator = function(value) {
            return validate(ctrl, "email", ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value), value);
        };
        ctrl.$formatters.push(emailValidator);
        ctrl.$parsers.push(emailValidator);
    }
    function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
            element.attr("name", nextUid());
        }
        element.on("click", function() {
            if (element[0].checked) {
                scope.$apply(function() {
                    ctrl.$setViewValue(attr.value);
                });
            }
        });
        ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        };
        attr.$observe("value", ctrl.$render);
    }
    function checkboxInputType(scope, element, attr, ctrl) {
        var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
        if (!isString(trueValue)) trueValue = true;
        if (!isString(falseValue)) falseValue = false;
        element.on("click", function() {
            scope.$apply(function() {
                ctrl.$setViewValue(element[0].checked);
            });
        });
        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
            return value !== trueValue;
        };
        ctrl.$formatters.push(function(value) {
            return value === trueValue;
        });
        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    var inputDirective = [ "$browser", "$sniffer", function($browser, $sniffer) {
        return {
            restrict: "E",
            require: "?ngModel",
            link: function(scope, element, attr, ctrl) {
                if (ctrl) {
                    (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
                }
            }
        };
    } ];
    var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty";
    var NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$name = $attr.name;
        var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
        if (!ngModelSet) {
            throw minErr("ngModel")("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
        }
        this.$render = noop;
        this.$isEmpty = function(value) {
            return isUndefined(value) || value === "" || value === null || value !== value;
        };
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
        $element.addClass(PRISTINE_CLASS);
        toggleValidCss(true);
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
            $animate.removeClass($element, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey);
            $animate.addClass($element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        this.$setValidity = function(validationErrorKey, isValid) {
            if ($error[validationErrorKey] === !isValid) return;
            if (isValid) {
                if ($error[validationErrorKey]) invalidCount--;
                if (!invalidCount) {
                    toggleValidCss(true);
                    this.$valid = true;
                    this.$invalid = false;
                }
            } else {
                toggleValidCss(false);
                this.$invalid = true;
                this.$valid = false;
                invalidCount++;
            }
            $error[validationErrorKey] = !isValid;
            toggleValidCss(isValid, validationErrorKey);
            parentForm.$setValidity(validationErrorKey, isValid, this);
        };
        this.$setPristine = function() {
            this.$dirty = false;
            this.$pristine = true;
            $animate.removeClass($element, DIRTY_CLASS);
            $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setViewValue = function(value) {
            this.$viewValue = value;
            if (this.$pristine) {
                this.$dirty = true;
                this.$pristine = false;
                $animate.removeClass($element, PRISTINE_CLASS);
                $animate.addClass($element, DIRTY_CLASS);
                parentForm.$setDirty();
            }
            forEach(this.$parsers, function(fn) {
                value = fn(value);
            });
            if (this.$modelValue !== value) {
                this.$modelValue = value;
                ngModelSet($scope, value);
                forEach(this.$viewChangeListeners, function(listener) {
                    try {
                        listener();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                });
            }
        };
        var ctrl = this;
        $scope.$watch(function ngModelWatch() {
            var value = ngModelGet($scope);
            if (ctrl.$modelValue !== value) {
                var formatters = ctrl.$formatters, idx = formatters.length;
                ctrl.$modelValue = value;
                while (idx--) {
                    value = formatters[idx](value);
                }
                if (ctrl.$viewValue !== value) {
                    ctrl.$viewValue = value;
                    ctrl.$render();
                }
            }
            return value;
        });
    } ];
    var ngModelDirective = function() {
        return {
            require: [ "ngModel", "^?form" ],
            controller: NgModelController,
            link: function(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                formCtrl.$addControl(modelCtrl);
                scope.$on("$destroy", function() {
                    formCtrl.$removeControl(modelCtrl);
                });
            }
        };
    };
    var ngChangeDirective = valueFn({
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });
    var requiredDirective = function() {
        return {
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                attr.required = true;
                var validator = function(value) {
                    if (attr.required && ctrl.$isEmpty(value)) {
                        ctrl.$setValidity("required", false);
                        return;
                    } else {
                        ctrl.$setValidity("required", true);
                        return value;
                    }
                };
                ctrl.$formatters.push(validator);
                ctrl.$parsers.unshift(validator);
                attr.$observe("required", function() {
                    validator(ctrl.$viewValue);
                });
            }
        };
    };
    var ngListDirective = function() {
        return {
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ",";
                var parse = function(viewValue) {
                    if (isUndefined(viewValue)) return;
                    var list = [];
                    if (viewValue) {
                        forEach(viewValue.split(separator), function(value) {
                            if (value) list.push(trim(value));
                        });
                    }
                    return list;
                };
                ctrl.$parsers.push(parse);
                ctrl.$formatters.push(function(value) {
                    if (isArray(value)) {
                        return value.join(", ");
                    }
                    return undefined;
                });
                ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    };
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    var ngValueDirective = function() {
        return {
            priority: 100,
            compile: function(tpl, tplAttr) {
                if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                    return function ngValueConstantLink(scope, elm, attr) {
                        attr.$set("value", scope.$eval(attr.ngValue));
                    };
                } else {
                    return function ngValueLink(scope, elm, attr) {
                        scope.$watch(attr.ngValue, function valueWatchAction(value) {
                            attr.$set("value", value);
                        });
                    };
                }
            }
        };
    };
    var ngBindDirective = ngDirective({
        compile: function(templateElement) {
            templateElement.addClass("ng-binding");
            return function(scope, element, attr) {
                element.data("$binding", attr.ngBind);
                scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                    element.text(value == undefined ? "" : value);
                });
            };
        }
    });
    var ngBindTemplateDirective = [ "$interpolate", function($interpolate) {
        return function(scope, element, attr) {
            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
            element.addClass("ng-binding").data("$binding", interpolateFn);
            attr.$observe("ngBindTemplate", function(value) {
                element.text(value);
            });
        };
    } ];
    var ngBindHtmlDirective = [ "$sce", "$parse", function($sce, $parse) {
        return {
            compile: function(tElement) {
                tElement.addClass("ng-binding");
                return function(scope, element, attr) {
                    element.data("$binding", attr.ngBindHtml);
                    var parsed = $parse(attr.ngBindHtml);
                    function getStringValue() {
                        return (parsed(scope) || "").toString();
                    }
                    scope.$watch(getStringValue, function ngBindHtmlWatchAction(value) {
                        element.html($sce.getTrustedHtml(parsed(scope)) || "");
                    });
                };
            }
        };
    } ];
    function classDirective(name, selector) {
        name = "ngClass" + name;
        return [ "$animate", function($animate) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, true);
                    attr.$observe("class", function(value) {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    });
                    if (name !== "ngClass") {
                        scope.$watch("$index", function($index, old$index) {
                            var mod = $index & 1;
                            if (mod !== (old$index & 1)) {
                                var classes = arrayClasses(scope.$eval(attr[name]));
                                mod === selector ? addClasses(classes) : removeClasses(classes);
                            }
                        });
                    }
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {};
                        var classesToUpdate = [];
                        forEach(classes, function(className) {
                            if (count > 0 || classCounts[className]) {
                                classCounts[className] = (classCounts[className] || 0) + count;
                                if (classCounts[className] === +(count > 0)) {
                                    classesToUpdate.push(className);
                                }
                            }
                        });
                        element.data("$classCounts", classCounts);
                        return classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses);
                        var toRemove = arrayDifference(oldClasses, newClasses);
                        toRemove = digestClassCounts(toRemove, -1);
                        toAdd = digestClassCounts(toAdd, 1);
                        if (toAdd.length === 0) {
                            $animate.removeClass(element, toRemove);
                        } else if (toRemove.length === 0) {
                            $animate.addClass(element, toAdd);
                        } else {
                            $animate.setClass(element, toAdd, toRemove);
                        }
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === true || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (!oldVal) {
                                addClasses(newClasses);
                            } else if (!equals(newVal, oldVal)) {
                                var oldClasses = arrayClasses(oldVal);
                                updateClasses(oldClasses, newClasses);
                            }
                        }
                        oldVal = shallowCopy(newVal);
                    }
                }
            };
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token == tokens2[j]) continue outer;
                    }
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                if (isArray(classVal)) {
                    return classVal;
                } else if (isString(classVal)) {
                    return classVal.split(" ");
                } else if (isObject(classVal)) {
                    var classes = [], i = 0;
                    forEach(classVal, function(v, k) {
                        if (v) {
                            classes = classes.concat(k.split(" "));
                        }
                    });
                    return classes;
                }
                return classVal;
            }
        } ];
    }
    var ngClassDirective = classDirective("", true);
    var ngClassOddDirective = classDirective("Odd", 0);
    var ngClassEvenDirective = classDirective("Even", 1);
    var ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined);
            element.removeClass("ng-cloak");
        }
    });
    var ngControllerDirective = [ function() {
        return {
            scope: true,
            controller: "@",
            priority: 500
        };
    } ];
    var ngEventDirectives = {};
    var forceAsyncEvents = {
        blur: true,
        focus: true
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName]);
                    return function ngEventHandler(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                scope.$evalAsync(callback);
                            } else {
                                scope.$apply(callback);
                            }
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            transclude: "element",
            priority: 600,
            terminal: true,
            restrict: "A",
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                    if (toBoolean(value)) {
                        if (!childScope) {
                            childScope = $scope.$new();
                            $transclude(childScope, function(clone) {
                                clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " ");
                                block = {
                                    clone: clone
                                };
                                $animate.enter(clone, $element.parent(), $element);
                            });
                        }
                    } else {
                        if (previousElements) {
                            previousElements.remove();
                            previousElements = null;
                        }
                        if (childScope) {
                            childScope.$destroy();
                            childScope = null;
                        }
                        if (block) {
                            previousElements = getBlockElements(block.clone);
                            $animate.leave(previousElements, function() {
                                previousElements = null;
                            });
                            block = null;
                        }
                    }
                });
            }
        };
    } ];
    var ngIncludeDirective = [ "$http", "$templateCache", "$anchorScroll", "$animate", "$sce", function($http, $templateCache, $anchorScroll, $animate, $sce) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: true,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var changeCounter = 0, currentScope, previousElement, currentElement;
                    var cleanupLastIncludeContent = function() {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentElement) {
                            $animate.leave(currentElement, function() {
                                previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };
                    scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
                        var afterAnimation = function() {
                            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                        };
                        var thisChangeId = ++changeCounter;
                        if (src) {
                            $http.get(src, {
                                cache: $templateCache
                            }).success(function(response) {
                                if (thisChangeId !== changeCounter) return;
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, null, $element, afterAnimation);
                                });
                                currentScope = newScope;
                                currentElement = clone;
                                currentScope.$emit("$includeContentLoaded");
                                scope.$eval(onloadExp);
                            }).error(function() {
                                if (thisChangeId === changeCounter) cleanupLastIncludeContent();
                            });
                            scope.$emit("$includeContentRequested");
                        } else {
                            cleanupLastIncludeContent();
                            ctrl.template = null;
                        }
                    });
                };
            }
        };
    } ];
    var ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                $element.html(ctrl.template);
                $compile($element.contents())(scope);
            }
        };
    } ];
    var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    });
    var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1e3
    });
    var ngPluralizeDirective = [ "$locale", "$interpolate", function($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
            restrict: "EA",
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), isWhen = /^when(Minus)?(.+)$/;
                forEach(attr, function(expression, attributeName) {
                    if (isWhen.test(attributeName)) {
                        whens[lowercase(attributeName.replace("when", "").replace("Minus", "-"))] = element.attr(attr.$attr[attributeName]);
                    }
                });
                forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + "-" + offset + endSymbol));
                });
                scope.$watch(function ngPluralizeWatch() {
                    var value = parseFloat(scope.$eval(numberExp));
                    if (!isNaN(value)) {
                        if (!(value in whens)) value = $locale.pluralCat(value - offset);
                        return whensExpFns[value](scope, element, true);
                    } else {
                        return "";
                    }
                }, function ngPluralizeWatchAction(newVal) {
                    element.text(newVal);
                });
            }
        };
    } ];
    var ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        var NG_REMOVED = "$$NG_REMOVED";
        var ngRepeatMinErr = minErr("ngRepeat");
        return {
            transclude: "element",
            priority: 1e3,
            terminal: true,
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var expression = $attr.ngRepeat;
                var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/), trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, hashFnLocals = {
                    $id: hashKey
                };
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                }
                lhs = match[1];
                rhs = match[2];
                trackByExp = match[3];
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp);
                    trackByIdExpFn = function(key, value, index) {
                        if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                        hashFnLocals[valueIdentifier] = value;
                        hashFnLocals.$index = index;
                        return trackByExpGetter($scope, hashFnLocals);
                    };
                } else {
                    trackByIdArrayFn = function(key, value) {
                        return hashKey(value);
                    };
                    trackByIdObjFn = function(key) {
                        return key;
                    };
                }
                match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                }
                valueIdentifier = match[3] || match[1];
                keyIdentifier = match[2];
                var lastBlockMap = {};
                $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                    var index, length, previousNode = $element[0], nextNode, nextBlockMap = {}, arrayLength, childScope, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder = [], elementsToRemove;
                    if (isArrayLike(collection)) {
                        collectionKeys = collection;
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                    } else {
                        trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                        collectionKeys = [];
                        for (key in collection) {
                            if (collection.hasOwnProperty(key) && key.charAt(0) != "$") {
                                collectionKeys.push(key);
                            }
                        }
                        collectionKeys.sort();
                    }
                    arrayLength = collectionKeys.length;
                    length = nextBlockOrder.length = collectionKeys.length;
                    for (index = 0; index < length; index++) {
                        key = collection === collectionKeys ? index : collectionKeys[index];
                        value = collection[key];
                        trackById = trackByIdFn(key, value, index);
                        assertNotHasOwnProperty(trackById, "`track by` id");
                        if (lastBlockMap.hasOwnProperty(trackById)) {
                            block = lastBlockMap[trackById];
                            delete lastBlockMap[trackById];
                            nextBlockMap[trackById] = block;
                            nextBlockOrder[index] = block;
                        } else if (nextBlockMap.hasOwnProperty(trackById)) {
                            forEach(nextBlockOrder, function(block) {
                                if (block && block.scope) lastBlockMap[block.id] = block;
                            });
                            throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, toJson(value));
                        } else {
                            nextBlockOrder[index] = {
                                id: trackById
                            };
                            nextBlockMap[trackById] = false;
                        }
                    }
                    for (key in lastBlockMap) {
                        if (lastBlockMap.hasOwnProperty(key)) {
                            block = lastBlockMap[key];
                            elementsToRemove = getBlockElements(block.clone);
                            $animate.leave(elementsToRemove);
                            forEach(elementsToRemove, function(element) {
                                element[NG_REMOVED] = true;
                            });
                            block.scope.$destroy();
                        }
                    }
                    for (index = 0, length = collectionKeys.length; index < length; index++) {
                        key = collection === collectionKeys ? index : collectionKeys[index];
                        value = collection[key];
                        block = nextBlockOrder[index];
                        if (nextBlockOrder[index - 1]) previousNode = getBlockEnd(nextBlockOrder[index - 1]);
                        if (block.scope) {
                            childScope = block.scope;
                            nextNode = previousNode;
                            do {
                                nextNode = nextNode.nextSibling;
                            } while (nextNode && nextNode[NG_REMOVED]);
                            if (getBlockStart(block) != nextNode) {
                                $animate.move(getBlockElements(block.clone), null, jqLite(previousNode));
                            }
                            previousNode = getBlockEnd(block);
                        } else {
                            childScope = $scope.$new();
                        }
                        childScope[valueIdentifier] = value;
                        if (keyIdentifier) childScope[keyIdentifier] = key;
                        childScope.$index = index;
                        childScope.$first = index === 0;
                        childScope.$last = index === arrayLength - 1;
                        childScope.$middle = !(childScope.$first || childScope.$last);
                        childScope.$odd = !(childScope.$even = (index & 1) === 0);
                        if (!block.scope) {
                            $transclude(childScope, function(clone) {
                                clone[clone.length++] = document.createComment(" end ngRepeat: " + expression + " ");
                                $animate.enter(clone, null, jqLite(previousNode));
                                previousNode = clone;
                                block.scope = childScope;
                                block.clone = clone;
                                nextBlockMap[block.id] = block;
                            });
                        }
                    }
                    lastBlockMap = nextBlockMap;
                });
            }
        };
        function getBlockStart(block) {
            return block.clone[0];
        }
        function getBlockEnd(block) {
            return block.clone[block.clone.length - 1];
        }
    } ];
    var ngShowDirective = [ "$animate", function($animate) {
        return function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                $animate[toBoolean(value) ? "removeClass" : "addClass"](element, "ng-hide");
            });
        };
    } ];
    var ngHideDirective = [ "$animate", function($animate) {
        return function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                $animate[toBoolean(value) ? "addClass" : "removeClass"](element, "ng-hide");
            });
        };
    } ];
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && newStyles !== oldStyles) {
                forEach(oldStyles, function(val, style) {
                    element.css(style, "");
                });
            }
            if (newStyles) element.css(newStyles);
        }, true);
    });
    var ngSwitchDirective = [ "$animate", function($animate) {
        return {
            restrict: "EA",
            require: "ngSwitch",
            controller: [ "$scope", function ngSwitchController() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousElements = [], selectedScopes = [];
                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    var i, ii;
                    for (i = 0, ii = previousElements.length; i < ii; ++i) {
                        previousElements[i].remove();
                    }
                    previousElements.length = 0;
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = selectedElements[i];
                        selectedScopes[i].$destroy();
                        previousElements[i] = selected;
                        $animate.leave(selected, function() {
                            previousElements.splice(i, 1);
                        });
                    }
                    selectedElements.length = 0;
                    selectedScopes.length = 0;
                    if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                        scope.$eval(attr.change);
                        forEach(selectedTranscludes, function(selectedTransclude) {
                            var selectedScope = scope.$new();
                            selectedScopes.push(selectedScope);
                            selectedTransclude.transclude(selectedScope, function(caseElement) {
                                var anchor = selectedTransclude.element;
                                selectedElements.push(caseElement);
                                $animate.enter(caseElement, anchor.parent(), anchor);
                            });
                        });
                    }
                });
            }
        };
    } ];
    var ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 800,
        require: "^ngSwitch",
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [];
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 800,
        require: "^ngSwitch",
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [];
            ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngTranscludeDirective = ngDirective({
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) {
                throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
            }
            $transclude(function(clone) {
                $element.empty();
                $element.append(clone);
            });
        }
    });
    var scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: true,
            compile: function(element, attr) {
                if (attr.type == "text/ng-template") {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ];
    var ngOptionsMinErr = minErr("ngOptions");
    var ngOptionsDirective = valueFn({
        terminal: true
    });
    var selectDirective = [ "$compile", "$parse", function($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {
            $setViewValue: noop
        };
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
                var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
                self.databound = $attrs.ngModel;
                self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_;
                    nullOption = nullOption_;
                    unknownOption = unknownOption_;
                };
                self.addOption = function(value) {
                    assertNotHasOwnProperty(value, '"option value"');
                    optionsMap[value] = true;
                    if (ngModelCtrl.$viewValue == value) {
                        $element.val(value);
                        if (unknownOption.parent()) unknownOption.remove();
                    }
                };
                self.removeOption = function(value) {
                    if (this.hasOption(value)) {
                        delete optionsMap[value];
                        if (ngModelCtrl.$viewValue == value) {
                            this.renderUnknownOption(value);
                        }
                    }
                };
                self.renderUnknownOption = function(val) {
                    var unknownVal = "? " + hashKey(val) + " ?";
                    unknownOption.val(unknownVal);
                    $element.prepend(unknownOption);
                    $element.val(unknownVal);
                    unknownOption.prop("selected", true);
                };
                self.hasOption = function(value) {
                    return optionsMap.hasOwnProperty(value);
                };
                $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop;
                });
            } ],
            link: function(scope, element, attr, ctrls) {
                if (!ctrls[1]) return;
                var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone();
                for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
                    if (children[i].value === "") {
                        emptyOption = nullOption = children.eq(i);
                        break;
                    }
                }
                selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
                if (multiple) {
                    ngModelCtrl.$isEmpty = function(value) {
                        return !value || value.length === 0;
                    };
                }
                if (optionsExp) setupAsOptions(scope, element, ngModelCtrl); else if (multiple) setupAsMultiple(scope, element, ngModelCtrl); else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
                function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                    ngModelCtrl.$render = function() {
                        var viewValue = ngModelCtrl.$viewValue;
                        if (selectCtrl.hasOption(viewValue)) {
                            if (unknownOption.parent()) unknownOption.remove();
                            selectElement.val(viewValue);
                            if (viewValue === "") emptyOption.prop("selected", true);
                        } else {
                            if (isUndefined(viewValue) && emptyOption) {
                                selectElement.val("");
                            } else {
                                selectCtrl.renderUnknownOption(viewValue);
                            }
                        }
                    };
                    selectElement.on("change", function() {
                        scope.$apply(function() {
                            if (unknownOption.parent()) unknownOption.remove();
                            ngModelCtrl.$setViewValue(selectElement.val());
                        });
                    });
                }
                function setupAsMultiple(scope, selectElement, ctrl) {
                    var lastView;
                    ctrl.$render = function() {
                        var items = new HashMap(ctrl.$viewValue);
                        forEach(selectElement.find("option"), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    };
                    scope.$watch(function selectMultipleWatch() {
                        if (!equals(lastView, ctrl.$viewValue)) {
                            lastView = shallowCopy(ctrl.$viewValue);
                            ctrl.$render();
                        }
                    });
                    selectElement.on("change", function() {
                        scope.$apply(function() {
                            var array = [];
                            forEach(selectElement.find("option"), function(option) {
                                if (option.selected) {
                                    array.push(option.value);
                                }
                            });
                            ctrl.$setViewValue(array);
                        });
                    });
                }
                function setupAsOptions(scope, selectElement, ctrl) {
                    var match;
                    if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                        throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    }
                    var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null, optionGroupsCache = [ [ {
                        element: selectElement,
                        label: ""
                    } ] ];
                    if (nullOption) {
                        $compile(nullOption)(scope);
                        nullOption.removeClass("ng-scope");
                        nullOption.remove();
                    }
                    selectElement.empty();
                    selectElement.on("change", function() {
                        scope.$apply(function() {
                            var optionGroup, collection = valuesFn(scope) || [], locals = {}, key, value, optionElement, index, groupIndex, length, groupLength, trackIndex;
                            if (multiple) {
                                value = [];
                                for (groupIndex = 0, groupLength = optionGroupsCache.length; groupIndex < groupLength; groupIndex++) {
                                    optionGroup = optionGroupsCache[groupIndex];
                                    for (index = 1, length = optionGroup.length; index < length; index++) {
                                        if ((optionElement = optionGroup[index].element)[0].selected) {
                                            key = optionElement.val();
                                            if (keyName) locals[keyName] = key;
                                            if (trackFn) {
                                                for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                                                    locals[valueName] = collection[trackIndex];
                                                    if (trackFn(scope, locals) == key) break;
                                                }
                                            } else {
                                                locals[valueName] = collection[key];
                                            }
                                            value.push(valueFn(scope, locals));
                                        }
                                    }
                                }
                            } else {
                                key = selectElement.val();
                                if (key == "?") {
                                    value = undefined;
                                } else if (key === "") {
                                    value = null;
                                } else {
                                    if (trackFn) {
                                        for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                                            locals[valueName] = collection[trackIndex];
                                            if (trackFn(scope, locals) == key) {
                                                value = valueFn(scope, locals);
                                                break;
                                            }
                                        }
                                    } else {
                                        locals[valueName] = collection[key];
                                        if (keyName) locals[keyName] = key;
                                        value = valueFn(scope, locals);
                                    }
                                }
                            }
                            ctrl.$setViewValue(value);
                            render();
                        });
                    });
                    ctrl.$render = render;
                    scope.$watchCollection(valuesFn, render);
                    scope.$watchCollection(function() {
                        var locals = {}, values = valuesFn(scope);
                        if (values) {
                            var toDisplay = new Array(values.length);
                            for (var i = 0, ii = values.length; i < ii; i++) {
                                locals[valueName] = values[i];
                                toDisplay[i] = displayFn(scope, locals);
                            }
                            return toDisplay;
                        }
                    }, render);
                    if (multiple) {
                        scope.$watchCollection(function() {
                            return ctrl.$modelValue;
                        }, render);
                    }
                    function getSelectedSet() {
                        var selectedSet = false;
                        if (multiple) {
                            var modelValue = ctrl.$modelValue;
                            if (trackFn && isArray(modelValue)) {
                                selectedSet = new HashMap([]);
                                var locals = {};
                                for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {
                                    locals[valueName] = modelValue[trackIndex];
                                    selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
                                }
                            } else {
                                selectedSet = new HashMap(modelValue);
                            }
                        }
                        return selectedSet;
                    }
                    function render() {
                        var optionGroups = {
                            "": []
                        }, optionGroupNames = [ "" ], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, key, groupLength, length, groupIndex, index, locals = {}, selected, selectedSet = getSelectedSet(), lastElement, element, label;
                        for (index = 0; length = keys.length, index < length; index++) {
                            key = index;
                            if (keyName) {
                                key = keys[index];
                                if (key.charAt(0) === "$") continue;
                                locals[keyName] = key;
                            }
                            locals[valueName] = values[key];
                            optionGroupName = groupByFn(scope, locals) || "";
                            if (!(optionGroup = optionGroups[optionGroupName])) {
                                optionGroup = optionGroups[optionGroupName] = [];
                                optionGroupNames.push(optionGroupName);
                            }
                            if (multiple) {
                                selected = isDefined(selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)));
                            } else {
                                if (trackFn) {
                                    var modelCast = {};
                                    modelCast[valueName] = modelValue;
                                    selected = trackFn(scope, modelCast) === trackFn(scope, locals);
                                } else {
                                    selected = modelValue === valueFn(scope, locals);
                                }
                                selectedSet = selectedSet || selected;
                            }
                            label = displayFn(scope, locals);
                            label = isDefined(label) ? label : "";
                            optionGroup.push({
                                id: trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index,
                                label: label,
                                selected: selected
                            });
                        }
                        if (!multiple) {
                            if (nullOption || modelValue === null) {
                                optionGroups[""].unshift({
                                    id: "",
                                    label: "",
                                    selected: !selectedSet
                                });
                            } else if (!selectedSet) {
                                optionGroups[""].unshift({
                                    id: "?",
                                    label: "",
                                    selected: true
                                });
                            }
                        }
                        for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                            optionGroupName = optionGroupNames[groupIndex];
                            optionGroup = optionGroups[optionGroupName];
                            if (optionGroupsCache.length <= groupIndex) {
                                existingParent = {
                                    element: optGroupTemplate.clone().attr("label", optionGroupName),
                                    label: optionGroup.label
                                };
                                existingOptions = [ existingParent ];
                                optionGroupsCache.push(existingOptions);
                                selectElement.append(existingParent.element);
                            } else {
                                existingOptions = optionGroupsCache[groupIndex];
                                existingParent = existingOptions[0];
                                if (existingParent.label != optionGroupName) {
                                    existingParent.element.attr("label", existingParent.label = optionGroupName);
                                }
                            }
                            lastElement = null;
                            for (index = 0, length = optionGroup.length; index < length; index++) {
                                option = optionGroup[index];
                                if (existingOption = existingOptions[index + 1]) {
                                    lastElement = existingOption.element;
                                    if (existingOption.label !== option.label) {
                                        lastElement.text(existingOption.label = option.label);
                                    }
                                    if (existingOption.id !== option.id) {
                                        lastElement.val(existingOption.id = option.id);
                                    }
                                    if (lastElement[0].selected !== option.selected) {
                                        lastElement.prop("selected", existingOption.selected = option.selected);
                                        if (msie) {
                                            lastElement.prop("selected", existingOption.selected);
                                        }
                                    }
                                } else {
                                    if (option.id === "" && nullOption) {
                                        element = nullOption;
                                    } else {
                                        (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).text(option.label);
                                    }
                                    existingOptions.push(existingOption = {
                                        element: element,
                                        label: option.label,
                                        id: option.id,
                                        selected: option.selected
                                    });
                                    selectCtrl.addOption(option.label, element);
                                    if (lastElement) {
                                        lastElement.after(element);
                                    } else {
                                        existingParent.element.append(element);
                                    }
                                    lastElement = element;
                                }
                            }
                            index++;
                            while (existingOptions.length > index) {
                                option = existingOptions.pop();
                                selectCtrl.removeOption(option.label);
                                option.element.remove();
                            }
                        }
                        while (optionGroupsCache.length > groupIndex) {
                            optionGroupsCache.pop()[0].element.remove();
                        }
                    }
                }
            }
        };
    } ];
    var optionDirective = [ "$interpolate", function($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
        };
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), true);
                    if (!interpolateFn) {
                        attr.$set("value", element.text());
                    }
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    if (selectCtrl && selectCtrl.databound) {
                        element.prop("selected", false);
                    } else {
                        selectCtrl = nullSelectCtrl;
                    }
                    if (interpolateFn) {
                        scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                            attr.$set("value", newVal);
                            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);
                            selectCtrl.addOption(newVal);
                        });
                    } else {
                        selectCtrl.addOption(attr.value);
                    }
                    element.on("$destroy", function() {
                        selectCtrl.removeOption(attr.value);
                    });
                };
            }
        };
    } ];
    var styleDirective = valueFn({
        restrict: "E",
        terminal: true
    });
    if (window.angular.bootstrap) {
        console.log("WARNING: Tried to load angular more than once.");
        return;
    }
    bindJQuery();
    publishExternalAPI(angular);
    jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    });
})(window, document);

!window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}.ng-animate-block-transitions{transition:0s all!important;-webkit-transition:0s all!important;}.ng-hide-add-active,.ng-hide-remove{display:block!important;}</style>');

(function(window, angular, undefined) {
    "use strict";
    var $sanitizeMinErr = angular.$$minErr("$sanitize");
    function $SanitizeProvider() {
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            return function(html) {
                var buf = [];
                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));
                }));
                return buf.join("");
            };
        } ];
    }
    function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join("");
    }
    var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/, ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, BEGIN_TAG_REGEXP = /^</, BEGING_END_TAGE_REGEXP = /^<\//, COMMENT_REGEXP = /<!--(.*?)-->/g, DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i, CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
    var voidElements = makeMap("area,br,col,hr,img,wbr");
    var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = makeMap("rp,rt"), optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
    var specialElements = makeMap("script,style");
    var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);
    var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap");
    var validAttrs = angular.extend({}, uriAttrs, makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear," + "color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace," + "ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules," + "scope,scrolling,shape,size,span,start,summary,target,title,type," + "valign,value,vspace,width"));
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) obj[items[i]] = true;
        return obj;
    }
    function htmlParser(html, handler) {
        if (typeof html !== "string") {
            if (html === null || typeof html === "undefined") {
                html = "";
            } else {
                html = "" + html;
            }
        }
        var index, chars, match, stack = [], last = html, text;
        stack.last = function() {
            return stack[stack.length - 1];
        };
        while (html) {
            text = "";
            chars = true;
            if (!stack.last() || !specialElements[stack.last()]) {
                if (html.indexOf("<!--") === 0) {
                    index = html.indexOf("--", 4);
                    if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                        if (handler.comment) handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (DOCTYPE_REGEXP.test(html)) {
                    match = html.match(DOCTYPE_REGEXP);
                    if (match) {
                        html = html.replace(match[0], "");
                        chars = false;
                    }
                } else if (BEGING_END_TAGE_REGEXP.test(html)) {
                    match = html.match(END_TAG_REGEXP);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(END_TAG_REGEXP, parseEndTag);
                        chars = false;
                    }
                } else if (BEGIN_TAG_REGEXP.test(html)) {
                    match = html.match(START_TAG_REGEXP);
                    if (match) {
                        if (match[4]) {
                            html = html.substring(match[0].length);
                            match[0].replace(START_TAG_REGEXP, parseStartTag);
                        }
                        chars = false;
                    } else {
                        text += "<";
                        html = html.substring(1);
                    }
                }
                if (chars) {
                    index = html.indexOf("<");
                    text += index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? "" : html.substring(index);
                    if (handler.chars) handler.chars(decodeEntities(text));
                }
            } else {
                html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"), function(all, text) {
                    text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
                    if (handler.chars) handler.chars(decodeEntities(text));
                    return "";
                });
                parseEndTag("", stack.last());
            }
            if (html == last) {
                throw $sanitizeMinErr("badparse", "The sanitizer was unable to parse the following block " + "of html: {0}", html);
            }
            last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = angular.lowercase(tagName);
            if (blockElements[tagName]) {
                while (stack.last() && inlineElements[stack.last()]) {
                    parseEndTag("", stack.last());
                }
            }
            if (optionalEndTagElements[tagName] && stack.last() == tagName) {
                parseEndTag("", tagName);
            }
            unary = voidElements[tagName] || !!unary;
            if (!unary) stack.push(tagName);
            var attrs = {};
            rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
                attrs[name] = decodeEntities(value);
            });
            if (handler.start) handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
            var pos = 0, i;
            tagName = angular.lowercase(tagName);
            if (tagName) for (pos = stack.length - 1; pos >= 0; pos--) if (stack[pos] == tagName) break;
            if (pos >= 0) {
                for (i = stack.length - 1; i >= pos; i--) if (handler.end) handler.end(stack[i]);
                stack.length = pos;
            }
        }
    }
    var hiddenPre = document.createElement("pre");
    var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
    function decodeEntities(value) {
        if (!value) {
            return "";
        }
        var parts = spaceRe.exec(value);
        var spaceBefore = parts[1];
        var spaceAfter = parts[3];
        var content = parts[2];
        if (content) {
            hiddenPre.innerHTML = content.replace(/</g, "&lt;");
            content = "textContent" in hiddenPre ? hiddenPre.textContent : hiddenPre.innerText;
        }
        return spaceBefore + content + spaceAfter;
    }
    function encodeEntities(value) {
        return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
            var hi = value.charCodeAt(0);
            var low = value.charCodeAt(1);
            return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return "&#" + value.charCodeAt(0) + ";";
        }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary) {
                tag = angular.lowercase(tag);
                if (!ignore && specialElements[tag]) {
                    ignore = tag;
                }
                if (!ignore && validElements[tag] === true) {
                    out("<");
                    out(tag);
                    angular.forEach(attrs, function(value, key) {
                        var lkey = angular.lowercase(key);
                        var isImage = tag === "img" && lkey === "src" || lkey === "background";
                        if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                            out(" ");
                            out(key);
                            out('="');
                            out(encodeEntities(value));
                            out('"');
                        }
                    });
                    out(unary ? "/>" : ">");
                }
            },
            end: function(tag) {
                tag = angular.lowercase(tag);
                if (!ignore && validElements[tag] === true) {
                    out("</");
                    out(tag);
                    out(">");
                }
                if (tag == ignore) {
                    ignore = false;
                }
            },
            chars: function(chars) {
                if (!ignore) {
                    out(encodeEntities(chars));
                }
            }
        };
    }
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider);
    angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"]/, MAILTO_REGEXP = /^mailto:/;
        return function(text, target) {
            if (!text) return text;
            var match;
            var raw = text;
            var html = [];
            var url;
            var i;
            while (match = raw.match(LINKY_URL_REGEXP)) {
                url = match[0];
                if (match[2] == match[3]) url = "mailto:" + url;
                i = match.index;
                addText(raw.substr(0, i));
                addLink(url, match[0].replace(MAILTO_REGEXP, ""));
                raw = raw.substring(i + match[0].length);
            }
            addText(raw);
            return $sanitize(html.join(""));
            function addText(text) {
                if (!text) {
                    return;
                }
                html.push(sanitizeText(text));
            }
            function addLink(url, text) {
                html.push("<a ");
                if (angular.isDefined(target)) {
                    html.push('target="');
                    html.push(target);
                    html.push('" ');
                }
                html.push('href="');
                html.push(url);
                html.push('">');
                addText(text);
                html.push("</a>");
            }
        };
    } ]);
})(window, window.angular);

angular.module("rison", []).factory("$rison", [ function() {
    var publicMembers = {}, privateMembers = {};
    privateMembers.not_idchar = " '!:(),*@$";
    privateMembers.not_idstart = "-0123456789";
    privateMembers.idRegularExpression = "[^" + privateMembers.not_idstart + privateMembers.not_idchar + "][^" + privateMembers.not_idchar + "]*";
    privateMembers.id_ok = new RegExp("^" + privateMembers.idRegularExpression + "$");
    privateMembers.next_id = new RegExp(privateMembers.idRegularExpression, "g");
    privateMembers.sq = {
        "'": true,
        "!": true
    };
    (function() {
        var sq = {
            "'": true,
            "!": true
        }, s = {
            array: function(x) {
                var a = [ "!(" ], b, f, i, l = x.length, v;
                for (i = 0; i < l; i += 1) {
                    v = x[i];
                    f = s[typeof v];
                    if (f) {
                        v = f(v);
                        if (typeof v == "string") {
                            if (b) {
                                a[a.length] = ",";
                            }
                            a[a.length] = v;
                            b = true;
                        }
                    }
                }
                a[a.length] = ")";
                return a.join("");
            },
            "boolean": function(x) {
                if (x) return "!t";
                return "!f";
            },
            "null": function(x) {
                return "!n";
            },
            number: function(x) {
                if (!isFinite(x)) return "!n";
                return String(x).replace(/\+/, "");
            },
            object: function(x) {
                if (x) {
                    if (x instanceof Array) {
                        return s.array(x);
                    }
                    if (typeof x.__prototype__ === "object" && typeof x.__prototype__.encode_rison !== "undefined") return x.encode_rison();
                    var a = [ "(" ], b, f, i, v, ki, ks = [];
                    for (i in x) ks[ks.length] = i;
                    ks.sort();
                    for (ki = 0; ki < ks.length; ki++) {
                        i = ks[ki];
                        v = x[i];
                        f = s[typeof v];
                        if (f) {
                            v = f(v);
                            if (typeof v == "string") {
                                if (b) {
                                    a[a.length] = ",";
                                }
                                a.push(s.string(i), ":", v);
                                b = true;
                            }
                        }
                    }
                    a[a.length] = ")";
                    return a.join("");
                }
                return "!n";
            },
            string: function(x) {
                if (x === "") return "''";
                if (privateMembers.id_ok.test(x)) return x;
                x = x.replace(/(['!])/g, function(a, b) {
                    if (sq[b]) return "!" + b;
                    return b;
                });
                return "'" + x + "'";
            },
            undefined: function(x) {
                throw new Error("rison can't encode the undefined value");
            }
        };
        publicMembers.stringify = function(object) {
            return s[typeof object](object);
        };
    })();
    publicMembers.parse = function(r) {
        var errcb = function(e) {
            throw Error("rison decoder error: " + e);
        };
        var p = new privateMembers.parser(errcb);
        return p.parse(r);
    };
    privateMembers.parser = function(errcb) {
        this.errorHandler = errcb;
    };
    privateMembers.parser.WHITESPACE = "";
    privateMembers.parser.prototype.setOptions = function(options) {
        if (options.errorHandler) this.errorHandler = options.errorHandler;
    };
    privateMembers.parser.prototype.parse = function(str) {
        this.string = str;
        this.index = 0;
        this.message = null;
        var value = this.readValue();
        if (!this.message && this.next()) value = this.error("unable to parse string as rison: '" + publicMembers.encode(str) + "'");
        if (this.message && this.errorHandler) this.errorHandler(this.message, this.index);
        return value;
    };
    privateMembers.parser.prototype.error = function(message) {
        if (typeof console != "undefined") console.error("Rison parser error: ", message);
        this.message = message;
        return undefined;
    };
    privateMembers.parser.prototype.readValue = function() {
        var c = this.next();
        var fn = c && this.table[c];
        if (fn) return fn.apply(this);
        var s = this.string;
        var i = this.index - 1;
        privateMembers.next_id.lastIndex = i;
        var m = privateMembers.next_id.exec(s);
        if (m.length > 0) {
            var id = m[0];
            this.index = i + id.length;
            return id;
        }
        if (c) return this.error("invalid character: '" + c + "'");
        return this.error("empty expression");
    };
    privateMembers.parser.parse_array = function(parser) {
        var ar = [];
        var c;
        while ((c = parser.next()) != ")") {
            if (!c) return parser.error("unmatched '!('");
            if (ar.length) {
                if (c != ",") parser.error("missing ','");
            } else if (c == ",") {
                return parser.error("extra ','");
            } else --parser.index;
            var n = parser.readValue();
            if (typeof n == "undefined") return undefined;
            ar.push(n);
        }
        return ar;
    };
    privateMembers.parser.bangs = {
        t: true,
        f: false,
        n: null,
        "(": privateMembers.parser.parse_array
    };
    privateMembers.parser.prototype.table = {
        "!": function() {
            var s = this.string;
            var c = s.charAt(this.index++);
            if (!c) return this.error('"!" at end of input');
            var x = privateMembers.parser.bangs[c];
            if (typeof x == "function") {
                return x.call(null, this);
            } else if (typeof x == "undefined") {
                return this.error('unknown literal: "!' + c + '"');
            }
            return x;
        },
        "(": function() {
            var o = {};
            var c;
            var count = 0;
            while ((c = this.next()) != ")") {
                if (count) {
                    if (c != ",") this.error("missing ','");
                } else if (c == ",") {
                    return this.error("extra ','");
                } else --this.index;
                var k = this.readValue();
                if (typeof k == "undefined") return undefined;
                if (this.next() != ":") return this.error("missing ':'");
                var v = this.readValue();
                if (typeof v == "undefined") return undefined;
                o[k] = v;
                count++;
            }
            return o;
        },
        "'": function() {
            var s = this.string;
            var i = this.index;
            var start = i;
            var segments = [];
            var c;
            while ((c = s.charAt(i++)) != "'") {
                if (!c) return this.error('unmatched "\'"');
                if (c == "!") {
                    if (start < i - 1) segments.push(s.slice(start, i - 1));
                    c = s.charAt(i++);
                    if ("!'".indexOf(c) >= 0) {
                        segments.push(c);
                    } else {
                        return this.error('invalid string escape: "!' + c + '"');
                    }
                    start = i;
                }
            }
            if (start < i - 1) segments.push(s.slice(start, i - 1));
            this.index = i;
            return segments.length == 1 ? segments[0] : segments.join("");
        },
        "-": function() {
            var s = this.string;
            var i = this.index;
            var start = i - 1;
            var state = "int";
            var permittedSigns = "-";
            var transitions = {
                "int+.": "frac",
                "int+e": "exp",
                "frac+e": "exp"
            };
            do {
                var c = s.charAt(i++);
                if (!c) break;
                if ("0" <= c && c <= "9") continue;
                if (permittedSigns.indexOf(c) >= 0) {
                    permittedSigns = "";
                    continue;
                }
                state = transitions[state + "+" + c.toLowerCase()];
                if (state == "exp") permittedSigns = "-";
            } while (state);
            this.index = --i;
            s = s.slice(start, i);
            if (s == "-") return this.error("invalid number");
            return Number(s);
        }
    };
    (function(table) {
        for (var i = 0; i <= 9; i++) table[String(i)] = table["-"];
    })(privateMembers.parser.prototype.table);
    privateMembers.parser.prototype.next = function() {
        var s = this.string, i = this.index, c;
        do {
            if (i == s.length) return undefined;
            c = s.charAt(i++);
        } while (privateMembers.parser.WHITESPACE.indexOf(c) >= 0);
        this.index = i;
        return c;
    };
    return publicMembers;
} ]);

var mod;

mod = angular.module("infinite-scroll", []);

mod.directive("infiniteScroll", [ "$rootScope", "$window", "$timeout", function($rootScope, $window, $timeout) {
    return {
        link: function(scope, elem, attrs) {
            var checkWhenEnabled, handler, scrollDistance, scrollEnabled;
            $window = angular.element($window);
            scrollDistance = 0;
            if (attrs.infiniteScrollDistance != null) {
                scope.$watch(attrs.infiniteScrollDistance, function(value) {
                    return scrollDistance = parseInt(value, 10);
                });
            }
            scrollEnabled = true;
            checkWhenEnabled = false;
            if (attrs.infiniteScrollDisabled != null) {
                scope.$watch(attrs.infiniteScrollDisabled, function(value) {
                    scrollEnabled = !value;
                    if (scrollEnabled && checkWhenEnabled) {
                        checkWhenEnabled = false;
                        return handler();
                    }
                });
            }
            handler = function() {
                var elementBottom, remaining, shouldScroll, windowBottom;
                windowBottom = $window.height() + $window.scrollTop();
                elementBottom = elem.offset().top + elem.height();
                remaining = elementBottom - windowBottom;
                shouldScroll = remaining <= $window.height() * scrollDistance;
                if (shouldScroll && scrollEnabled) {
                    if ($rootScope.$$phase) {
                        return scope.$eval(attrs.infiniteScroll);
                    } else {
                        return scope.$apply(attrs.infiniteScroll);
                    }
                } else if (shouldScroll) {
                    return checkWhenEnabled = true;
                }
            };
            $window.on("scroll", handler);
            scope.$on("$destroy", function() {
                return $window.off("scroll", handler);
            });
            return $timeout(function() {
                if (attrs.infiniteScrollImmediateCheck) {
                    if (scope.$eval(attrs.infiniteScrollImmediateCheck)) {
                        return handler();
                    }
                } else {
                    return handler();
                }
            }, 0);
        }
    };
} ]);

angular.module("ui.date", []).constant("uiDateConfig", {}).directive("uiDate", [ "uiDateConfig", function(uiDateConfig) {
    "use strict";
    var options;
    options = {};
    angular.extend(options, uiDateConfig);
    return {
        require: "?ngModel",
        link: function(scope, element, attrs, controller) {
            var getOptions = function() {
                return angular.extend({}, uiDateConfig, scope.$eval(attrs.uiDate));
            };
            var initDateWidget = function() {
                var showing = false;
                var opts = getOptions();
                if (controller) {
                    var _onSelect = opts.onSelect || angular.noop;
                    opts.onSelect = function(value, picker) {
                        scope.$apply(function() {
                            showing = true;
                            controller.$setViewValue(element.datepicker("getDate"));
                            _onSelect(value, picker);
                            element.blur();
                        });
                    };
                    opts.beforeShow = function() {
                        showing = true;
                    };
                    opts.onClose = function(value, picker) {
                        showing = false;
                    };
                    element.on("blur", function() {
                        if (!showing) {
                            scope.$apply(function() {
                                element.datepicker("setDate", element.datepicker("getDate"));
                                controller.$setViewValue(element.datepicker("getDate"));
                            });
                        }
                    });
                    controller.$render = function() {
                        var date = controller.$viewValue;
                        if (angular.isDefined(date) && date !== null && !angular.isDate(date)) {
                            throw new Error("ng-Model value must be a Date object - currently it is a " + typeof date + " - use ui-date-format to convert it from a string");
                        }
                        element.datepicker("setDate", date);
                    };
                }
                element.datepicker("destroy");
                element.datepicker(opts);
                if (controller) {
                    controller.$render();
                }
            };
            scope.$watch(getOptions, initDateWidget, true);
        }
    };
} ]).constant("uiDateFormatConfig", "").directive("uiDateFormat", [ "uiDateFormatConfig", function(uiDateFormatConfig) {
    var directive = {
        require: "ngModel",
        link: function(scope, element, attrs, modelCtrl) {
            var dateFormat = attrs.uiDateFormat || uiDateFormatConfig;
            if (dateFormat) {
                modelCtrl.$formatters.push(function(value) {
                    if (angular.isString(value)) {
                        return jQuery.datepicker.parseDate(dateFormat, value);
                    }
                    return null;
                });
                modelCtrl.$parsers.push(function(value) {
                    if (value) {
                        return jQuery.datepicker.formatDate(dateFormat, value);
                    }
                    return null;
                });
            } else {
                modelCtrl.$formatters.push(function(value) {
                    if (angular.isString(value)) {
                        return new Date(value);
                    }
                    return null;
                });
                modelCtrl.$parsers.push(function(value) {
                    if (value) {
                        return value.toISOString();
                    }
                    return null;
                });
            }
        }
    };
    return directive;
} ]);
//# sourceMappingURL=/assets/js/vendor-c8e09b286fb50901cd97d367d8b03838.js.map